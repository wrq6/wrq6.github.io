<!DOCTYPE html>
<html lang="en">
<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"3IgcPbFXfKH6JIH0",ck:"3IgcPbFXfKH6JIH0",autoTrack:true,hashMode:true,screenRecord:true})</script>
<script src="LA.js"></script>
<head>
    <meta charset="UTF-8">
    <title>data structure</title>
    <style>
        body {
            font-family: Consolas, monospace;
            background-color: #f5f5f5;
            padding: 20px;
        }

        h1 {
            color: #333;
            font-size: 24px;
            margin-bottom: 20px;
        }

        h2 {
            color: #666;
            font-size: 20px;
            margin-top: 40px;
            margin-bottom: 10px;
        }

        pre {
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        code {
            display: block;
            color: #000;
        }
        .audio-wrapper {
            display: flex;
            justify-content: center;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }

        table, th, td {
            border: 1px solid black;
        }

        th, td {
            padding: 10px;
            text-align: center;
        }
        .hr-shadow {
            border: 0;
            padding-top: 10px;
            color: #d0d0d5;
            border-top: 1px solid rgba(0,0,0,.1);
            box-shadow: inset 0 10px 10px -10px;
        }

    </style>
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="js/html2canvas.min.js"></script>
    <script src="js/html2pdf.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.68/pdfmake.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.68/vfs_fonts.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.2/html2pdf.bundle.min.js"></script>



</head>
<body id="pdf">
<header>
    <h1>数据结构笔记</h1>
    <nav>
        <ul id="table-of-contents">
            <li><a href="my_html.html">不想看回到主页</a></li>
            <li><a href="#1">浅析KMP算法之Next数组</a></li>
            <li><a href="#2">图的最小生成树</a></li>
            <li><a href="#3">哈夫曼树</a></li>
            <li><a href="#4">哈希函数</a></li>
            <li><a href="#5">图的深度优先与广度优先</a></li>
            <li><a href="#5">二叉树的前中后序遍历</a></li>
            <li><a href="#6">常见的几种排序(希尔、快排、堆排、归并、基数、折半)</a></li>
            <li><a href="#7">顺序存储的线性表的操作</a></li>
            <li><a href="#8">后缀表达式的求值与转换</a></li>
            <li><a href="#9">时间复杂度、空间复杂度</a></li>
            <li><a href="#9">链表例题</a></li>
        </ul>
    </nav>
</header>
<div id="lyric-container"></div>
<div class="audio-container">
    <audio controls ontimeupdate="showLyrics()">
        <source src="music/b.mp3" type="audio/mpeg">
        是妈妈是女儿 - 黄绮珊,希林娜依高
    </audio>
</div>
<script>
    var lyricContainer = document.getElementById("lyric-container");
    var audio = document.getElementsByTagName("audio")[0];
    var lyrics = []; // 存储所有歌词的数组

    function loadLyrics() {
        // 获取歌曲名称，用于加载对应的歌词文件
        var songName = audio.getElementsByTagName("source")[0].src.split("/").pop().replace(".mp3", "");
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function () {
            if (this.readyState == 4 && this.status == 200) {
                var lyricText = this.responseText;
                lyrics = parseLyrics(lyricText); // 解析歌词文本并存储到数组中
                console.log("已加载 " + lyrics.length + " 行歌词。");
            }
        };
        xhttp.open("GET", "geci/" + songName + ".lrc", true); // 修改为您存放歌词文件的路径
        xhttp.send();
    }

    function parseLyrics(lyricText) {
        var lines = lyricText.split("\n");
        var result = [];
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            var timeRegex = /\[(\d{2}):(\d{2})\.(\d{2})\]/; // 匹配时间标签的正则表达式
            var matches = line.match(timeRegex);
            if (matches) {
                var minutes = parseInt(matches[1]);
                var seconds = parseInt(matches[2]);
                var milliseconds = parseInt(matches[3]);
                var text = line.replace(timeRegex, "").trim();
                var time = minutes * 60 + seconds + milliseconds / 100;
                result.push({ time: time, text: text });
            }
        }
        return result;
    }

    function showLyrics() {
        loadLyrics(); // 加载歌词
        var currentTime = audio.currentTime;
        var displayedLyrics = []; // 存储要显示的歌词行
        for (var i = 0; i < lyrics.length; i++) {
            if (currentTime >= lyrics[i].time) {
                displayedLyrics.push(lyrics[i]);
            }
        }
        if (displayedLyrics.length > 0) {
            var lyricsHTML = '';
            for (var j = 0; j < displayedLyrics.length; j++) {
                lyricsHTML += '<p>' + displayedLyrics[j].text + '</p>';
            }
            lyricContainer.innerHTML = lyricsHTML;
            lyricContainer.scrollTop = (displayedLyrics.length - 1) * 25; // 滚动到最后一行歌词
            lyrics.splice(0, displayedLyrics.length); // 删除已经显示的歌词行
        }
    }


    // 在音频播放时调用 showLyrics 函数
    audio.addEventListener("timeupdate", function () {
        showLyrics();
    });

</script>
<pre>
     <span style="font-size: 50px" id="1">浅析KMP算法之Next数组</span>
	<code>
首先我们需要知道KMP是干嘛的，通俗易懂的来讲是查找相同字符串的一种捷径
我们人的本能的趋简避繁，例如aababcbdaabacbbbd这样的字符串，我们需要在其中找到子串aabacb我们怎么操作？
为什么会将子串第一个字符一次对比字符串的每一个字符来判断：
=----------1---------=
aababcbdaabacbbbd
aabacb
=----------2---------=
aababcbdaabacbbbd
 aabacb
=----------3---------=
aababcbdaabacbbbd
  aabacb
=----------4---------=
aababcbdaabacbbbd
   abacb
=----------5---------=
aababcbdaabacbbbd
    abacb
=----------6---------=
aababcbdaabacbbbd
     abacb
=----------7---------=
aababcbdaabacbbbd
      abacb
=----------8---------=
aababcbdaabacbbbd
       abacb
=----------9---------=
aababcbdaabacbbbd
        abacb
=----------10---------=
aababcbdaabacbbbd
         abacb
=----------end完结撒花---------=
怎么样是不是很麻烦吧？//麻烦个嘚，我就喜欢
不是，既然计算机大拿说了麻烦咱就认行吗？
于是开头字母分别为KMP的三个人设计了一个算法叫KMP算法（具体思路自己百度，以下只解释最重要也是最难理解的Next数组该怎么求）
Next数组说白了就是求子串中每一个最长相等前后缀（听不懂没关系，往下看）
这里声明一个规则：
前缀：不包含未元素的串
后缀：不包含首元素的串
我们来举个例子这是子串|a|a|b|a|a|f|
（1）|a|
前缀以及后缀都为0  导致最长相等前后缀为0
（2）|a|a|
前缀为|a|
后缀为|a|相等
最长相等前后缀为1
（3）|a|a|b|
前缀为|a|a|
后缀为|a|b|不相等
在这有两个元素的前后缀的基础上再下一次比较
前缀|a|
后缀|b|依然不相等//注意这里的|a|和|b|不是后缀中的|a|b|拆分的，是前缀|a|a|的第一个|a|以及后缀|a|b|最后的那个|b|
最长相等前后缀为0
（4）|a|a|b|a|
前缀为|a|a|b|
后缀为|a|b|a|当然不相等
在这有三个元素的两个前后缀的基础上再下一次比较
前缀|a|a|
后缀|b|a|依然不相等
同理再比较
前缀|a|
后缀|a|相等
所以最长相等前后缀为1
（5）|a|a|b|a|a|
前缀|a|a|b|a|
后缀|a|b|a|a|不等
再前缀|a|a|b|
后缀|b|a|a|不等
再|a|a|
后缀|a|a|相等长度为2
最长相等前后缀为2
（6）|a|a|b|a|a|f|
前缀|a|a|b|a|a|
后缀|a|b|a|a|f|不等
前缀|a|a|b|a|
后缀|b|a|a|f|不等
前缀|a|a|b|
后缀|a|a|f|不等
前缀|a|a|
后缀|a|f|不等
前缀|a|
后缀|f|不等
所以最长相等前后缀为0
所以Next数组的值就是，这6个算出来的数值
即|0|1|0|1|2|0|
以上为理论部分（聪明的人会看到这里的）

以下是代码实现部分（C++）
#include < stdio.h >
#include < iostream >//c++的头文件
#include< string >
using namespace std;//c++的命名空间，如果没有这句话，很多地方会这样写std::cout等等
class solution {//定义类，c++语法
public://公共方法（好像java才说方法）以及属性
    void getnext(int* next, const string& s) {//传入next数组以及字串
        int j = 0;//j初始化为0
        next[0] = 0;//首元素设置为0
        for (int i = 1; i < s.size(); i++) {//我们假设i指向后缀的末尾，j指向前缀的末尾
            while (j > 0 && s[i] != s[j]) {//while是用来处理前后缀不相同的情况
                j = next[j - 1];//这句代码的意思是回退，回退到前一个数组元素的值为数组下标处
            }
            if (s[i] == s[j]) {//if用来处理前后缀相同的情况
                j++;//如果想相同，则会将j++，让j来表示最长相等前后缀的情况
            }
            next[i] = j;//让此处的最长相等前后缀为j的值
        }
    }
};
int main()
{
    int next[8];
    string s = "abcabcab";
    solution*a = new solution();
    a->getnext(next,s);
    for(int i=0;i<8;i++)
    printf("%d",next[i]);
}
        //放心，代码你十有八九看不懂，不过没关系，毕竟你要是自己研究出来了
        //你就是KMP的发明者了，今天看几遍，过几天再来，慢慢的就理解了
	</code>
</pre>

<pre>
     <span style="font-size: 50px" id="2">图的最小生成树</span>
    <p>          给定图，利用<span style="color: red">Kruskal算法（克鲁斯卡算法）</span>生成最小生成树</p>

    <canvas id="myCanvas" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[4], end: vertices[2], weight: 7 },
        { start: vertices[2], end: vertices[3], weight: 15 },
        { start: vertices[3], end: vertices[1], weight: 40 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[1], end: vertices[0], weight: 50 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
    (1) 找出最小的边
    即
       <canvas id="myCanvas1" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas1');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
    (2) 继续找出最小的边
    即
       <canvas id="myCanvas2" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas2');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[0], end: vertices[3], weight: 8 },
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
(3) 继续找出最小的边
    即
       <canvas id="myCanvas3" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas3');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[0], end: vertices[4], weight: 10 },
                { start: vertices[0], end: vertices[3], weight: 8 },
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
    (4) 继续找出最小的边<span style="color: red">(注意：这里之所以是选40而不是15的边是因为C和D已经有了通路)</span>
    即
       <canvas id="myCanvas4" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas4');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[3], end: vertices[1], weight: 40 },
                { start: vertices[0], end: vertices[4], weight: 10 },
                { start: vertices[0], end: vertices[3], weight: 8 },
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
    <br style="border: #6f42c1">
    <br style="border: #6f42c1">
    <br style="border: #6f42c1">
   <p>          给定图，利用<span style="color: red">Prim算法（普里姆算法）</span>生成最小生成树，给定A为初始点</p>

    <canvas id="myCanvas5" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas5');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[4], end: vertices[2], weight: 7 },
        { start: vertices[2], end: vertices[3], weight: 15 },
        { start: vertices[3], end: vertices[1], weight: 40 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[1], end: vertices[0], weight: 50 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
    (1) 选出与A相连的最小权值的边
    即
        <canvas id="myCanvas6" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas6');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[3], weight: 8 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
        (2) 选出与AD相连的最小权值的边
    即
        <canvas id="myCanvas7" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas7');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[0], end: vertices[3], weight: 8 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
            (3) 选出与ADE相连的最小权值的边
    即
        <canvas id="myCanvas8" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas8');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[4], end: vertices[2], weight: 7 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
                (4) 选出与ADEC相连的最小权值的边(注意：不能选择已经用通路的两点的边)
    即
        <canvas id="myCanvas9" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas9');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[1], end: vertices[3], weight: 40 },
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[4], end: vertices[2], weight: 7 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
    <span style="font-size: 20px">总结两种算法的结果是相同的，但是其过程是不同的，解答这类题目的答案就是需要步骤的</span>
</pre>

<pre>
     <span style="font-size: 50px" id="3">哈夫曼树</span>
    <p>          已知      <table>
        <tbody>
            <tr>
                <td>A</td>
                <td>B</td>
                <td>C</td>
                <td>D</td>
                <td>E</td>
            </tr>
            <tr>
                <td>0.15</td>
                <td>0.16</td>
                <td>0.07</td>
                <td>0.21</td>
                <td>0.41</td>
            </tr>
        </tbody>
    </table>
    (1)画出相对应的哈夫曼(Huffman)树
    (2)计算带权路径长度WPL
    (3)求A、B、C、D、E的哈夫曼(Huffman)编码</p>
    （1）取最小的两者不断重构(结合以后的生成的数再放到整个比较)
    以下是详细步骤
<span style="color: #ff00c5">1>ABCDE中A与C的数值最小于是乎先画出A C</span>
    <canvas id="myCanvas10" width="800" height="200"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas10');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [

        { x: 75, y: 25, label: '   0.22' },
        { x: 50, y: 100, label: 'A(0.15)' },
        { x: 150, y: 100, label: 'C(0.07)' },


    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    <span style="color: #ff00c5">2>把A和C的合并数值0.22当成AC再去和剩下的B、D、E比较大小，选出最小两个(也就是B和D)，这个时候刚才画的就别动，在旁边重新画一棵树</span>
        <canvas id="myCanvas11" width="800" height="200"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas11');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        // { x: 250, y: 50, label: '       |  ' },
        // { x: 150, y: 100, label: '0.59' },
        // { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 25, label: '   0.37' },
        { x: 75, y: 25, label: '   0.22' },
        { x: 50, y: 100, label: 'A(0.15)' },
        { x: 150, y: 100, label: 'C(0.07)' },
        { x: 300, y: 100, label: 'B(0.16)' },
        { x: 400, y: 100, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[4] },
        { start: vertices[0], end: vertices[5] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
<span style="color: #ff00c5">3>思想同上(别告诉我你现在还没有看明白😒😒😒)</span>
            <canvas id="myCanvas12" width="800" height="300"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas12');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label: '      1' },
        { x: 150, y: 100, label: '    0.59' },
        { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 175, label: '   0.37' },
        { x: 75, y: 175, label: '   0.22' },
        { x: 50, y: 250, label: 'A(0.15)' },
        { x: 150, y: 250, label: 'C(0.07)' },
        { x: 300, y: 250, label: 'B(0.16)' },
        { x: 400, y: 250, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    <span style="color: red">以上就是对应的完整的哈夫曼树了</span>

    (2)计算WPL（看带字母的节点，然后看这个节点到顶点经过了几条边，经过几条就数值*几就行）
    例如A，从顶点到A经过了4条边(幼儿园的都知道怎么数🤣🤣🤣)
    也就是0.15*4，总之把所有字母的边*数加起来就是WPL
    ∴WPL=1*0.41+3*0.15+3*0.07+3*0.06+3*0.21//*是乘号✖，我靠这样看起来很头疼吗？？这不就是程序员必备的？
    ∴WPL=1✖0.41+3✖0.15+3✖0.07+3✖0.06+3✖0.21//满足你

    (3)求哈夫曼编码（将哈夫曼树的左边画0，右边画1，你就知道了）

<canvas id="myCanvas13" width="800" height="300"></canvas>

<script>
    var canvas = document.getElementById('myCanvas13');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label: '      1' },
        { x: 150, y: 100, label: '    0.59' },
        { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 175, label: '   0.37' },
        { x: 75, y: 175, label: '   0.22' },
        { x: 50, y: 250, label: 'A(0.15)' },
        { x: 150, y: 250, label: 'C(0.07)' },
        { x: 275, y: 250, label: 'B(0.16)' },
        { x: 400, y: 250, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] ,weight:0},
        { start: vertices[0], end: vertices[2] ,weight:1},
        { start: vertices[1], end: vertices[3] ,weight:1},
        { start: vertices[1], end: vertices[4] ,weight:0},
        { start: vertices[4], end: vertices[5] ,weight:0},
        { start: vertices[4], end: vertices[6] ,weight:1},
        { start: vertices[3], end: vertices[7] ,weight:0},
        { start: vertices[3], end: vertices[8] ,weight:1},
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    然后就是从顶点开始往字母走，假如我们选D，D的编码就是011(简单吧🫵)
    答案就是：
    A:000
    B:010
    C:001
    D:011
    E:1
    别觉得哈夫曼编码就是固定长度(🤣🫵)
        </pre>
<pre>
     <span style="font-size: 50px" id="4">哈希函数</span>
    设散列表长为11，记录关键字集合为{15，17，28，41，37，31，56，23，45，51，73}，散列函数：H(Key) = key MOD 11，冲突处理采用线性探测法，请给出散列表的构造过程，再求平均查找程度ASL
(1)先看散列函数，H(Key) = Key MOD 11.(对每个数都取余，与11相除，取余)
    <table>
        <tbody>
            <tr>
                <td>余数</td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">7</span></td>
            </tr>
            <tr>
                <td>原数</td>
                <td>15</td>
                <td>17</td>
                <td>28</td>
                <td>41</td>
                <td>37</td>
                <td>31</td>
                <td>56</td>
                <td>23</td>
                <td>45</td>
                <td>51</td>
                <td>73</td>
            </tr>
        </tbody>
    </table>
(2)我们先写出一个0-10（11个）
        <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
        </tbody>
    </table>
我们规定，按照余数，放进这个表格中，如果冲突线性探测就是往后顺延一位（如果一位不行就再继续顺）
我们一步步来，把余数4对应的15放到4处
            <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">15</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
            </tr>
        </tbody>
    </table>
此时记录15到位4处动了（1）次，接着把17放到6处
                <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">15</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">17</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
            </tr>
        </tbody>
    </table>
记录17动了（1）次，接着放28，因为28是6，和之前的17冲突了，采用线性探测就是往后顺延一位
                    <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">15</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">17</span> </td>
                <td><span style="color: red">28</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
            </tr>
        </tbody>
    </table>
记录28动了（2）次，接着41放8处
                        <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">15</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">17</span> </td>
                <td><span style="color: red">28</span> </td>
                <td><span style="color: red">41</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
            </tr>
        </tbody>
    </table>
记录41动了（1）次，接着37，与15冲突了往后顺延1位
                            <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录37动了（2）次，接着31，放9处
                                <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录31动了（1）次，接着56放1处
                                    <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录56动了（1）次，接着23放1处冲突顺延到2处
                                        <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red">23</span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录23动了（2）次，接着45放1处冲突顺延到2处再冲突再顺延3处
                                            <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red">23</span></td>
                <td><span style="color: red">45</span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录了45动了（3）次，接着把51放7处与28冲突顺延到8冲突到9冲突于是放到10
                                                <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red">23</span></td>
                <td><span style="color: red">45</span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red">51</span></td>
            </tr>
        </tbody>
    </table>
记录51动力4次，接着73放7处冲突，再8冲突，再9冲突，再10冲突，再0放
                                                    <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red">73</span></td>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red">23</span></td>
                <td><span style="color: red">45</span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red">51</span></td>
            </tr>
        </tbody>
    </table>
以上就是表的构造过程了
    15：1次
    17：1次
    28：2次
    41：1次
    37：2次
    31：1次
    56：1次
    23：2次
    45：3次
    51：4次
    73：5次
    求ASL(平均查找程度就是将以上数加起来再除他们的总个数)
    <p>ASL= <math xmlns='http://www.w3.org/1998/Math/MathML'> <mfrac> <mrow> <mn> 1 </mn> <mo> + </mo> <mn> 1 </mn> <mo> + </mo> <mn> 2 </mn> <mo> + </mo> <mn> 1 </mn> <mo> + </mo> <mn> 2 </mn> <mo> + </mo> <mn> 1 </mn> <mo> + </mo> <mn> 1 </mn> <mo> + </mo> <mn> 2 </mn> <mo> + </mo> <mn> 3 </mn> <mo> + </mo> <mn> 4 </mn> <mo> + </mo> <mn> 5 </mn> </mrow> <mrow> <mn> 10 </mn> </mrow> </mfrac> <mo> = </mo> <mn> 2.3 </mn> </math></p>
    <span style="color: red;font-size: 25px">还有一种题目是冲突采用链地址表示法</span>
    前面求余数的步骤一样就是构造的时候采用链表的思想

    <table>
        <tbody>
            <tr>
                <td>余数</td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">7</span></td>
            </tr>
            <tr>
                <td>原数</td>
                <td>15</td>
                <td>17</td>
                <td>28</td>
                <td>41</td>
                <td>37</td>
                <td>31</td>
                <td>56</td>
                <td>23</td>
                <td>45</td>
                <td>51</td>
                <td>73</td>
            </tr>
        </tbody>
    </table>
    就是构造以下基表竖着的
        <table style="width: auto">
        <tbody>
            <tr style="">
                <td>0</td>
                <td>^</td>
            </tr>
            <tr>
                <td>1</td>
                <td>-></td>
                <td>56</td>
                <td>-></td>
                <td>23</td>
                <td>-></td>
                <td>45</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                <td>^</td>
            </tr>
            <tr>
                <td>3</td>
                <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>-></td>
                   <td>15</td>
                <td>-></td>
                   <td>37</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>^</td>
            </tr>
            <tr>
                <td>6</td>
                <td>-></td>
                <td>17</td>
                <td>-></td>
                <td>28</td>
                <td>^</td>
            </tr>
            <tr>
                <td>7</td>
                <td>-></td>
                <td>51</td>
                <td>-></td>
                <td>73</td>
                <td>^</td>
            </tr>
            <tr>
                <td>8</td>
                <td>-></td>
                <td>41</td>
                <td>^</td>
            </tr>
              <tr>
                <td>9</td>
                <td>-></td>
                  <td>31</td>
                  <td>^</td>
            </tr>
              <tr>
                <td>10</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    求ASL，就是1*第一列的个数+2*第二列的个数+3*第三列的个数...
    此题就是ASL=1*6+2*4+3*1
</pre>
<pre>
     <span style="font-size: 50px" id="5">图的深度优先与广度优先</span>
            <table style="width: auto">
        <tbody>
            <tr style="">
                <td>1</td>
                <td>-></td>
                <td>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>3</td>
                <td>-></td>
                 <td>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
我们来分析一下深度优先
    第一步    我们给1标上了①，接下来给3表上了②，于是这时候跳到了
                <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>3</td>
                <td>-></td>
                 <td>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
跳到了3处，往后给4表上③，这时候跳到
                    <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                 <td><span style="color: red">③</span>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
这时候跳到了
                     <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                 <td><span style="color: red">③</span>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">③</span>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    注意这时候，4后面没有任何东西，于是回退到上一个的最后继续标
                         <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                 <td><span style="color: red">③</span>4</td>
                 <td>-></td>
                 <td><span style="color: red">④</span>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">③</span>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    标了于是跳到5处，给5的下一个2标上
                            <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                 <td><span style="color: red">③</span>4</td>
                 <td>-></td>
                 <td><span style="color: red">④</span>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">③</span>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">④</span>5</td>
                <td>-></td>
                   <td><span style="color: red">⑤</span>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    到此为止全部的数都标完了
    于是<span style="color: #022fec"> 深度优先遍历</span>就是：1、3、4、5、2


接下来我们讨论一下<span style="color: #022fec">广度优先遍历</span>(简单的一批，就是从上到下，从左到右)
     <table style="width: auto">
        <tbody>
            <tr style="">
                <td>1</td>
                <td>-></td>
                <td>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>3</td>
                <td>-></td>
                 <td>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    就是1、3、2、4、5
</pre>
<pre>
     <span style="font-size: 50px" id="6">二叉树的前中后序遍历</span>
这类题目一般给前中/后中，来确定后/前序遍历，因为只有前中/后中才能确定唯一的二叉树，而前后序不能确定
    <hr class="hr-shadow">
    （1）给定前序ABDGHCEFI与中序GDHBAECIF，写出后序遍历。
    什么？我前中后序遍历都不知道是什么？
    接下来我们来学习，前中后，简单来说，前中后描述的是根所在的位置
    前（根左右）中（左根右）后（左右根）
   <canvas id="myCanvas14" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas14');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
    上图中，前序遍历，也就是根左右，我们一步步来看
    首先根：A
    其次左：B <span style="color: #00aa44">//很好，接下来并不是右C，而是E，因为B也是一棵子树二叉树的根</span>
    也就是根B的左：E <span style="color: #00aa44">//接下开E又是一棵子树的根</span>
    也就是根E的左：F <span style="color: #00aa44">//因为F不再是任何树的根，这时候就可以到右</span>
    也就是根E的右：G <span style="color: #00aa44">//完成以后，我们回退到E？不，因为E的左右都写完了，于是我们再回退B，根B写了左但还没写右</span>
    也就是根B的右：D <span style="color: #00aa44">//此时D又是根，于是再写D的左</span>
    也就是根D的左：H <span style="color: #00aa44">//此时H不是根了，就可以写右</span>
    也就是根D的右：I <span style="color: #00aa44">//这时候，根D左右写完，回退B，B的左右也写完了，回退A，A只写完了左，右还没有写，于是</span>
    也就是根A的右：C <span style="color: #00aa44">//到此为止，我们的前序遍历就算写完了</span>
    <span style="color: #aa0000">前序：ABEFGDHIC</span>
<hr class="hr-shadow">
本来我想图省事，直接说，中后序同理的😏😏😏
   <canvas id="myCanvas15" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas15');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
    上图中，中序（左根右）一步步来
    左：F <span style="color: #00aa44">//这个左是整个树的左</span>
    根：E <span style="color: #00aa44">//这应该能理解吧？不能理解？废了，重开吧</span>
    右：G <span style="color: #00aa44">//此时，一棵子树以及遍历完了，按理说是返回到B，但是B是根，把B看成根，也就是E子树为左，D子树为右</span>
    也就是根：B <span style="color: #00aa44">现在你肯定想说，接下来不就是D了吗？no、no、no，时刻谨记D是根，我们优先左再根再右，也就是根D树的左H</span>
    左：H
    根：D
    右：I <span style="color: #00aa44">现在D树完成，回退到B，B树的左右也完成了，回退到A，A左完成，根据左根右，也就是左完成，现在是根，于是</span>
    根：A
    右：C <span style="color: #00aa44">这还用我说？🤏🤏🤏</span>
        <span style="color: #aa0000">中序：FEGBHDIAC</span>
    <hr class="hr-shadow">
   <canvas id="myCanvas16" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas16');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
    上图中，后序（左右根），一步步来说
    左：F <span style="color: #00aa44"></span>
    右：G
    根：E <span style="color: #00aa44">//现在B的左树已经写完，根据左右根规则，我们看B的右边的树，也就是以D为根的树，但是我们肯定不是先写D，要先左</span>
    左：H
    右：I
    根：D <span style="color: #00aa44">//好了，左右子树都写完，就写根了</span>
    根：B <span style="color: #00aa44">现在总体看，A树的左子树写完了，再看A的右树</span>
    右：C
    根：A <span style="color: #00aa44">完结撒花😃😃😃😃😃</span>
    <span style="color: #aa0000">后序：FGEHIDBCA</span>
    <hr class="hr-shadow">
我了个天，扫盲结束。回到一开始我们的题目
    <span style="color: #7c00ff"> （1）给定前序ABDGHCEFI与中序GDHBAECIF，写出后序遍历。</span>
    你肯定有点思路，但我知道并不多，我们来用一种流氓的思路来解决他
    画以下的类似二维坐标系的图
<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

    <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

    <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">F</text>
    </g>
<g>
        <text x="80" y="115" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="100" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="130" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="85" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="160" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="145" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="190" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="175" font-size="12" text-anchor="middle">F</text>
</g>
    <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">I</text>
        <text x="30" y="175" font-size="12" text-anchor="end">F</text>
        <text x="30" y="160" font-size="12" text-anchor="end">E</text>
        <text x="30" y="145" font-size="12" text-anchor="end">C</text>
        <text x="30" y="130" font-size="12" text-anchor="end">H</text>
        <text x="30" y="115" font-size="12" text-anchor="end">G</text>
        <text x="30" y="100" font-size="12" text-anchor="end">D</text>
        <text x="30" y="85" font-size="12" text-anchor="end">B</text>
        <text x="30" y="70" font-size="12" text-anchor="end">A</text>
    </g>
</svg>
怎么样，画出上面的图，我们肯定知道A是根节点，别问为什么，因为前序遍历第一个肯定是总树的根节点啊😡😡😡😡
接下来我们画线
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

        <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

        <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">F</text>
    </g>
<g>
        <text x="80" y="115" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="100" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="130" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="85" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="160" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="145" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="190" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="175" font-size="12" text-anchor="middle">F</text>
        <!-- 画线 左 -->
    <line x1="160" y1="70" x2="140" y2="85" stroke="black" stroke-width="1"/>
    <line x1="140" y1="85" x2="100" y2="100" stroke="black" stroke-width="1"/>
    <line x1="100" y1="100" x2="80" y2="115" stroke="black" stroke-width="1"/>
    <line x1="100" y1="100" x2="120" y2="130" stroke="black" stroke-width="1"/>
    <!-- 画线 右 -->
    <line x1="160" y1="70" x2="200" y2="145" stroke="black" stroke-width="1"/>
    <line x1="200" y1="145" x2="180" y2="160" stroke="black" stroke-width="1"/>
    <line x1="200" y1="145" x2="240" y2="175" stroke="black" stroke-width="1"/>
    <line x1="240" y1="175" x2="220" y2="190" stroke="black" stroke-width="1"/>

</g>
        <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">I</text>
        <text x="30" y="175" font-size="12" text-anchor="end">F</text>
        <text x="30" y="160" font-size="12" text-anchor="end">E</text>
        <text x="30" y="145" font-size="12" text-anchor="end">C</text>
        <text x="30" y="130" font-size="12" text-anchor="end">H</text>
        <text x="30" y="115" font-size="12" text-anchor="end">G</text>
        <text x="30" y="100" font-size="12" text-anchor="end">D</text>
        <text x="30" y="85" font-size="12" text-anchor="end">B</text>
        <text x="30" y="70" font-size="12" text-anchor="end">A</text>
    </g>
</svg>
画这些点和线真的累死我啦🤨😥😭
    看起来是不是很简单，但是如果你现在直接把我题目抄在草稿纸上，自己去画，绝对会有地方卡住
    这就是为什么你有时候学习，以为学的很好了，看起来很简单，但是自己一动手就废了
    <span style="color: red">注意看我画的图，你怎么知道A必须连接B？为什么不左连接D，右连B？等等问题</span>
    在这里我们遵循几个原则
    1.这是二叉树，最多只有两个子树，也就是最多只能有两个孩子
    2.左孩子的x不会大于根的x
    3.根一定在孩子上方
    4.与最近的结合
    行了，以上是我瞎总结的，这些就是经验，教科书又臭又长，但是学懂了，根本不需要记住那么多东西
    就是自然而然的。
    然后就是喜闻乐见的，答题环节
    <span style="color: red" >后序遍历：GHDBEIFCA</span> <span style="color: #00aa44">//你可能还是困惑为什么E在C前面，I在F前面，真的想一巴掌拍晕你，左右根，A的右树开始是C，但是C是A右子树的根啊，所以开始E，然后C的右，右F也是一棵子树，F也是根所以先I再F啊</span>
     <span style="color: #7c00ff"> （2）给定后序ACDBGIHFE与中序ABCDEFGHI求前序遍历</span>
    在解答这道题前别着急写，别以为学了点东西就以为天下无敌了，乱拳打不死老师傅
    仔细想想中序遍历不管他，我们前一题给的是前序遍历，在y轴上当然A最在最上面，因为A是全部的根
    但是后序呢？最后一个字母E才是根，如果还按之前的y轴排，E在最下面，那成啥了？
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

        <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

        <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">I</text>
    </g>
<g>
        <text x="80" y="190" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="145" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="175" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="160" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="85" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="130" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="100" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="115" font-size="12" text-anchor="middle">I</text>

</g>
        <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">A</text>
        <text x="30" y="175" font-size="12" text-anchor="end">C</text>
        <text x="30" y="160" font-size="12" text-anchor="end">D</text>
        <text x="30" y="145" font-size="12" text-anchor="end">B</text>
        <text x="30" y="130" font-size="12" text-anchor="end">G</text>
        <text x="30" y="115" font-size="12" text-anchor="end">I</text>
        <text x="30" y="100" font-size="12" text-anchor="end">H</text>
        <text x="30" y="85" font-size="12" text-anchor="end">F</text>
        <text x="30" y="70" font-size="12" text-anchor="end">E</text>
    </g>
</svg>
    按照同样的思路连线，你可以自己尝试一下，再来看我画的
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

        <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

        <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">I</text>
    </g>
<g>
        <text x="80" y="190" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="145" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="175" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="160" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="85" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="130" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="100" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="115" font-size="12" text-anchor="middle">I</text>
    <!-- 画线 左 -->
    <line x1="160" y1="70" x2="100" y2="145" stroke="black" stroke-width="1"/>
    <line x1="100" y1="145" x2="140" y2="160" stroke="black" stroke-width="1"/>
    <line x1="140" y1="160" x2="120" y2="175" stroke="black" stroke-width="1"/>
    <line x1="100" y1="145" x2="80" y2="190" stroke="black" stroke-width="1"/>
    <!-- 画线 右 -->
    <line x1="160" y1="70" x2="180" y2="85" stroke="black" stroke-width="1"/>
    <line x1="180" y1="85" x2="220" y2="100" stroke="black" stroke-width="1"/>
    <line x1="220" y1="100" x2="200" y2="130" stroke="black" stroke-width="1"/>
    <line x1="220" y1="100" x2="240" y2="115" stroke="black" stroke-width="1"/>

</g>
        <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">A</text>
        <text x="30" y="175" font-size="12" text-anchor="end">C</text>
        <text x="30" y="160" font-size="12" text-anchor="end">D</text>
        <text x="30" y="145" font-size="12" text-anchor="end">B</text>
        <text x="30" y="130" font-size="12" text-anchor="end">G</text>
        <text x="30" y="115" font-size="12" text-anchor="end">I</text>
        <text x="30" y="100" font-size="12" text-anchor="end">H</text>
        <text x="30" y="85" font-size="12" text-anchor="end">F</text>
        <text x="30" y="70" font-size="12" text-anchor="end">E</text>
    </g>
</svg>
    我知道你如果自己试了的话，有可能在C为什么不连A，而是B连A，这个问题在于，B作为一个根，你将其从上到下看成一个金箍棒
    如果C连的左子树为A，那么A大概率在B这根金箍棒的右边而不是左边
    下面是题目的答案
    <span style="color: red"> 前序遍历：EBADCFHGI</span>
    <span style="color: #00ebff"> 一开始学习的时候我问过一个问题：
        第三中，给定前后序，怎么求中序啊？（不知道你会不会有这种想法）
    还记得我们一开始说的吗？只有前中以及后中才能确定一棵树，而前后并不能确定唯一的一棵树</span>
</pre>
<pre>
     <span style="font-size: 50px" id="7">常见的几种排序</span>
    <span style="color: #0d66c2;font-size: 15px">希尔排序、快速排序、堆排序、归并排序、基数排序、折半查找</span>
       <hr class="hr-shadow">
(1) 归并排序
    <span style="color: #00daff">对{40，24，80，39，43，18，20，10，90，70} 进行从小到大排序过程(两两分组比较)</span>
    <svg width="500" height="300" xmlns="http://www.w3.org/2000/svg">
        <g>
        <text x="40" y="40" font-size="12" text-anchor="middle">[40]</text>
        <text x="80" y="40" font-size="12" text-anchor="middle">[24]</text>
        <text x="120" y="40" font-size="12" text-anchor="middle">[80]</text>
        <text x="160" y="40" font-size="12" text-anchor="middle">[39]</text>
        <text x="200" y="40" font-size="12" text-anchor="middle">[43]</text>
        <text x="240" y="40" font-size="12" text-anchor="middle">[18]</text>
        <text x="280" y="40" font-size="12" text-anchor="middle">[20]</text>
        <text x="320" y="40" font-size="12" text-anchor="middle">[10]</text>
        <text x="360" y="40" font-size="12" text-anchor="middle">[90]</text>
        <text x="400" y="40" font-size="12" text-anchor="middle">[70]</text>
        </g>

        <g>
        <text x="60" y="80" font-size="12" text-anchor="middle">[24，40]</text>
        <text x="140" y="80" font-size="12" text-anchor="middle">[39，80]</text>
        <text x="220" y="80" font-size="12" text-anchor="middle">[18，43]</text>
        <text x="300" y="80" font-size="12" text-anchor="middle">[10，20]</text>
        <text x="380" y="80" font-size="12" text-anchor="middle">[70，90]</text>
            <!-- 画线 -->
    <line x1="40" y1="40" x2="60" y2="80" stroke="black" stroke-width="1"/>
    <line x1="80" y1="40" x2="60" y2="80" stroke="black" stroke-width="1"/>
    <line x1="120" y1="40" x2="140" y2="80" stroke="black" stroke-width="1"/>
    <line x1="160" y1="40" x2="140" y2="80" stroke="black" stroke-width="1"/>
    <line x1="200" y1="40" x2="220" y2="80" stroke="black" stroke-width="1"/>
    <line x1="240" y1="40" x2="220" y2="80" stroke="black" stroke-width="1"/>
    <line x1="280" y1="40" x2="300" y2="80" stroke="black" stroke-width="1"/>
    <line x1="320" y1="40" x2="300" y2="80" stroke="black" stroke-width="1"/>
    <line x1="280" y1="40" x2="300" y2="80" stroke="black" stroke-width="1"/>
    <line x1="320" y1="40" x2="300" y2="80" stroke="black" stroke-width="1"/>
    <line x1="360" y1="40" x2="380" y2="80" stroke="black" stroke-width="1"/>
    <line x1="400" y1="40" x2="380" y2="80" stroke="black" stroke-width="1"/>
        </g>

<g>
        <text x="100" y="120" font-size="12" text-anchor="middle">[24，39，40，80]</text>
        <text x="260" y="120" font-size="12" text-anchor="middle">[10，18，20，43]</text>
        <text x="380" y="120" font-size="12" text-anchor="middle">[70，90]</text>
        <line x1="60" y1="80" x2="100" y2="120" stroke="black" stroke-width="1"/>
        <line x1="140" y1="80" x2="100" y2="120" stroke="black" stroke-width="1"/>
        <line x1="220" y1="80" x2="260" y2="120" stroke="black" stroke-width="1"/>
        <line x1="300" y1="80" x2="260" y2="120" stroke="black" stroke-width="1"/>
        <line x1="380" y1="80" x2="380" y2="120" stroke="black" stroke-width="1"/>
</g>
<g>
        <text x="180" y="160" font-size="12" text-anchor="middle">[10，18，20，24，39，40，43，80]</text>
        <text x="380" y="160" font-size="12" text-anchor="middle">[70，90]</text>
        <line x1="100" y1="120" x2="180" y2="160" stroke="black" stroke-width="1"/>
        <line x1="260" y1="120" x2="180" y2="160" stroke="black" stroke-width="1"/>
        <line x1="380" y1="120" x2="380" y2="160" stroke="black" stroke-width="1"/>
</g>
<g>
        <text x="260" y="200" font-size="12" text-anchor="middle">[10，18，20，24，39，40，43，70，80，90]</text>
        <line x1="180" y1="160" x2="260" y2="200" stroke="black" stroke-width="1"/>
        <line x1="380" y1="160" x2="260" y2="200" stroke="black" stroke-width="1"/>
</g>
    </svg>
    <span style="color: #00aa44">这应该看得懂吧？一目了然了都😏😏</span>
       <hr class="hr-shadow">
(2) 快速排序
    <span style="color: #00daff">对{46，58，15，45，90，18，10，62}进行快速排序</span>
    以第一个数为基准提出来
        ___  58  15  45  90  18  10  62
        ___  58  15  45  90  18  10  62<--
    <span style="color: #00aa44">这时候比较最后一个数与第一个数46的大小，62>46(不动)</span>
        ___  58  15  45  90  18  10<--  62
    <span style="color: #00aa44">这时候比较向前移动一位比较10和46大小，10<46(将10移动到46原本在的第一位)</span>
        10  58  15  45  90  18  ___  62
    <span style="color: #00aa44">这个时候比较的指向是从前面也就是10的后面开始</span>
        10  58<--  15  45  90  18  ___  62
    <span style="color: #00aa44">58>45(将58移动到10原本的位置)</span>
        10  ___  15  45  90  18  58  62
    <span style="color: #00aa44">这时候再从后面也就是58的前面</span>
        10  ___  15  45  90  18<--  58  62
    <span style="color: #00aa44">18<46(移动到58原本所在的前面)</span>
        10  18  15  45  90  ___  58  62
    <span style="color: #00aa44">再从18的后面开始比较</span>
        10  18  15<--  45  90  ___  58  62
    <span style="color: #00aa44">15<46(不动)</span>
        10  18  15  45<--  90  ___  58  62
    <span style="color: #00aa44">45<46(不动)</span>
        10  18  15  45  90<--  ___  58  62
    <span style="color: #00aa44">90>46(移动到后面的空位去)</span>
        10  18  15  45  ___  90  58  62
    <span style="color: #00aa44">到此为止全部元素都和46比较过了，于是把46放到空位处</span>
        10  18  15  45  <span style="color: red">46</span>  90  58  62
    <span style="color: #00aa44">此时46的位置已经确定了，46所在的位置就是这里，你可能也感觉出来了，这一轮比较就是把比46小的一股脑丢46前面，比46大的一股脑丢到后面去</span>
    <span style="color: #00aa44">既然46确定了，只需要比较两块内容就行了，也就是46前面的，和46后面的就行，还是按照之前的方法</span>
        ___  18  15  45<--  <span style="color: red">46</span>  ___  58   62<--
    <span style="color: #00aa44">哈哈哈，开启双开模式，前面提10，后面提90</span>
    <span style="color: #00aa44">45>10(不动);62<90(动)</span>
        10  18  15<--  45  <span style="color: red">46</span>  62  58<--  ___
        10  18<--  15  45  <span style="color: red">46</span>  62  58  <span style="color: red">90</span>
    <span style="color: #00aa44">我会把比较完成的数标红</span>
        <span style="color: red">10</span>  18  15 45  <span style="color: red">46</span>  62  58  <span style="color: red">90</span>
        <span style="color: red">10</span>  ___  15 45<--  <span style="color: red">46</span>  ___  58<--  <span style="color: red">90</span>
        <span style="color: red">10</span>  ___  15<-- 45  <span style="color: red">46</span>  58  ___  <span style="color: red">90</span>
        <span style="color: red">10</span>  <span style="color: red">15  18  45</span>  <span style="color: red">46</span>  <span style="color: red"> 58  62</span>  <span style="color: red">90</span>
   <hr class="hr-shadow">
(3) 希尔排序
    <span style="color: #00daff">利用希尔排序对关键字系列{40，24，80，39，43，18，20，10，90，70}从小到大排序(增量5，3，1)</span>
    增量的意思就是每个x个为一个组比较大小
    当增量为5时
    <span style="color: red">40</span>，24，80，39，43，<span style="color: red">18</span>，20，10，90，70
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，80，39，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，10，90，70
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，39，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，90，70
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，<span style="color: #00feff"> 39</span>，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，<span style="color: #00feff">90</span>，70
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，<span style="color: #00feff"> 39</span>，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，<span style="color: #00feff">90</span>，70
    最终我们得出增量为5的分组（颜色不同来区分）
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，<span style="color: #00feff"> 39</span>，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，<span style="color: #00feff">90</span>，70
    （把小的放前，大的放后就行）
    <span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，<span style="color: #00feff"> 39</span>，43，<span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，<span style="color: #00feff">90</span>，70
    就是以上的第一次增量，当增量为3的时候
    <span style="color: red">18</span>，<span style="color: blueviolet">20</span>, 39，<span style="color: red">43</span>，<span style="color: blueviolet">40</span>，24，<span style="color: red">80</span>，<span style="color: blueviolet">90</span>，70
    <span style="color: red">18</span>，<span style="color: blueviolet">20</span>, 24，<span style="color: red">43</span>，<span style="color: blueviolet">40</span>，39，<span style="color: red">80</span>，<span style="color: blueviolet">90</span>，70
    完成，以下是增量为1的
    18，20, 24，43，40，39，80，90，70
    18，20，24，39，40，43，70，80，90
    完成
    <hr class="hr-shadow">
(4)基数排序
    <span style="color: #00daff">对{457,131,481,219,392,674,350,815,315}进行基数排序</span>
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
    <line x1="100" y1="50" x2="100" y2="200" stroke="black" stroke-width="2"/>
    <line x1="125" y1="50" x2="125" y2="200" stroke="black" stroke-width="2"/>
    <line x1="150" y1="50" x2="150" y2="200" stroke="black" stroke-width="2"/>
    <line x1="175" y1="50" x2="175" y2="200" stroke="black" stroke-width="2"/>
    <line x1="200" y1="50" x2="200" y2="200" stroke="black" stroke-width="2"/>
    <line x1="225" y1="50" x2="225" y2="200" stroke="black" stroke-width="2"/>
     <line x1="250" y1="50" x2="250" y2="200" stroke="black" stroke-width="2"/>
     <line x1="275" y1="50" x2="275" y2="200" stroke="black" stroke-width="2"/>
     <line x1="300" y1="50" x2="300" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">看</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">位</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">数</text>
        <text x="30" y="160" font-size="12" text-anchor="middle">放</text>
        </g>

        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle">Q_0</text>
        <text x="85" y="50" font-size="12" text-anchor="middle">Q_1</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">Q_2</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">Q_3</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">Q_4</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">Q_5</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">Q_6</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">Q_7</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">Q_8</text>
        <text x="285" y="50" font-size="12" text-anchor="middle">Q_9</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="10" text-anchor="middle"  >350</text>
        <text x="85" y="80" font-size="10" text-anchor="middle"  >481</text>
        <text x="110" y="80" font-size="10" text-anchor="middle" >392</text>
        <text x="160" y="80" font-size="10" text-anchor="middle" >674</text>
        <text x="185" y="80" font-size="10" text-anchor="middle" >475</text>
        <text x="185" y="110" font-size="10" text-anchor="middle" >815</text>
        <text x="185" y="140" font-size="10" text-anchor="middle" >315</text>
        <text x="235" y="80" font-size="10" text-anchor="middle" >137</text>
        <text x="285" y="80" font-size="10" text-anchor="middle" >219</text>
        </g>
    </svg>
<span style="color: #fa0a0a">接下来就是收集（从上到下，从左到右）：{350,481,392,674,475,815,315,137,219}</span>
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
    <line x1="100" y1="50" x2="100" y2="200" stroke="black" stroke-width="2"/>
    <line x1="125" y1="50" x2="125" y2="200" stroke="black" stroke-width="2"/>
    <line x1="150" y1="50" x2="150" y2="200" stroke="black" stroke-width="2"/>
    <line x1="175" y1="50" x2="175" y2="200" stroke="black" stroke-width="2"/>
    <line x1="200" y1="50" x2="200" y2="200" stroke="black" stroke-width="2"/>
    <line x1="225" y1="50" x2="225" y2="200" stroke="black" stroke-width="2"/>
     <line x1="250" y1="50" x2="250" y2="200" stroke="black" stroke-width="2"/>
     <line x1="275" y1="50" x2="275" y2="200" stroke="black" stroke-width="2"/>
     <line x1="300" y1="50" x2="300" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">看</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">十</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">位</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">数</text>
        <text x="30" y="160" font-size="12" text-anchor="middle">放</text>
        </g>

        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle">Q_0</text>
        <text x="85" y="50" font-size="12" text-anchor="middle">Q_1</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">Q_2</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">Q_3</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">Q_4</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">Q_5</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">Q_6</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">Q_7</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">Q_8</text>
        <text x="285" y="50" font-size="12" text-anchor="middle">Q_9</text>
        </g>
        <g id="loading-txt">
        <text x="85" y="80" font-size="10" text-anchor="middle"  >815</text>
        <text x="85" y="110" font-size="10" text-anchor="middle"  >315</text>
        <text x="85" y="140" font-size="10" text-anchor="middle" >219</text>
        <text x="135" y="80" font-size="10" text-anchor="middle" >137</text>
        <text x="185" y="80" font-size="10" text-anchor="middle" >350</text>
        <text x="235" y="80" font-size="10" text-anchor="middle">674</text>
        <text x="235" y="110" font-size="10" text-anchor="middle">475</text>
        <text x="260" y="80" font-size="10" text-anchor="middle" >481</text>
        <text x="285" y="80" font-size="10" text-anchor="middle" >392</text>
        </g>
    </svg>
<span style="color: #fa0a0a">接下来就是收集（从上到下，从左到右）：{815,315,219,137,350,674,475,481,392}</span>
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
    <line x1="100" y1="50" x2="100" y2="200" stroke="black" stroke-width="2"/>
    <line x1="125" y1="50" x2="125" y2="200" stroke="black" stroke-width="2"/>
    <line x1="150" y1="50" x2="150" y2="200" stroke="black" stroke-width="2"/>
    <line x1="175" y1="50" x2="175" y2="200" stroke="black" stroke-width="2"/>
    <line x1="200" y1="50" x2="200" y2="200" stroke="black" stroke-width="2"/>
    <line x1="225" y1="50" x2="225" y2="200" stroke="black" stroke-width="2"/>
     <line x1="250" y1="50" x2="250" y2="200" stroke="black" stroke-width="2"/>
     <line x1="275" y1="50" x2="275" y2="200" stroke="black" stroke-width="2"/>
     <line x1="300" y1="50" x2="300" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">看</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">百</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">位</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">数</text>
        <text x="30" y="160" font-size="12" text-anchor="middle">放</text>
        </g>

        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle">Q_0</text>
        <text x="85" y="50" font-size="12" text-anchor="middle">Q_1</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">Q_2</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">Q_3</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">Q_4</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">Q_5</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">Q_6</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">Q_7</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">Q_8</text>
        <text x="285" y="50" font-size="12" text-anchor="middle">Q_9</text>
        </g>
        <g id="loading-txt">
        <text x="85" y="80" font-size="10" text-anchor="middle"  >137</text>
        <text x="110" y="80" font-size="10" text-anchor="middle"  >219</text>
        <text x="135" y="80" font-size="10" text-anchor="middle" >315</text>
        <text x="135" y="110" font-size="10" text-anchor="middle" >350</text>
        <text x="135" y="140" font-size="10" text-anchor="middle" >392</text>
        <text x="235" y="80" font-size="10" text-anchor="middle">475</text>
        <text x="235" y="110" font-size="10" text-anchor="middle">481</text>
        <text x="210" y="80" font-size="10" text-anchor="middle" >674</text>
        <text x="260" y="80" font-size="10" text-anchor="middle" >815</text>
        </g>
    </svg>
<span style="color: #fa0a0a">接下来就是收集（从上到下，从左到右）：{137，219，315，350，392，475，481，674，815}</span>
至此你也看出来了，它到底是怎么运作来实现排序的
也不难，先个位数，再十位数，再百位数，一步步确保
    <hr class="hr-shadow">
(5)折半查找
    <span style="color: #00daff">对{5,13,17,29,37,41,61,79,89}利用折半查找值为29的元素</span>
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="100" font-size="12" text-anchor="middle" >↑</text>
        <text x="160" y="100" font-size="12" text-anchor="middle">↑</text>
        <text x="260" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="110" font-size="12" text-anchor="middle" >low</text>
        <text x="160" y="110" font-size="12" text-anchor="middle">mid</text>
        <text x="260" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>
我们规定了首尾都有一个指针，其次mid的指针由下面式子给出
    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>0</mn><mo>+</mo><mn>8</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>4</mn></mrow></math></span>
是的，折半的想法，此时mid指向的值为<span style="color: red">37</span>比我们要找的值29大
这就是说明我们的中间的指针是比这个大的(😏废话)
所以我们把高指针的指向重新定义为mid(中间指针)的<span style="color: red">前一个</span>
如果你对为什么是前一个没有疑虑，那么你很聪明
因为我们比较的就是中间指针肯定是要么大要么小，如果相同的就结束了啊
所以这个相当于不属于我们下一次查找的范围了

<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="100" font-size="12" text-anchor="middle" >↑</text>
        <text x="85" y="100" font-size="12" text-anchor="middle">↑</text>
        <text x="135" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="110" font-size="12" text-anchor="middle" >low</text>
        <text x="85" y="110" font-size="12" text-anchor="middle">mid</text>
        <text x="135" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>

    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>0</mn><mo>+</mo><mn>3</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>1</mn></mrow></math></span>(向下取整)
mid指向的是13，比29小，我们把low(小)指针改为mid(中间指针)的后面一个
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="110" y="100" font-size="12" text-anchor="middle" >↑</text>
        <text x="110" y="130" font-size="12" text-anchor="middle">↑</text>
        <text x="135" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="110" y="110" font-size="12" text-anchor="middle" >low</text>
        <text x="110" y="140" font-size="12" text-anchor="middle">mid</text>
        <text x="135" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>

    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mo>+</mo><mn>3</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>2</mn></mrow></math></span>(向下取整)
此时mid指向的是17还是比29小，于是把low指针指向mid的下一个
<svg width="400" height="200" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="135" y="160" font-size="12" text-anchor="middle" >↑</text>
        <text x="135" y="130" font-size="12" text-anchor="middle">↑</text>
        <text x="135" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="135" y="170" font-size="12" text-anchor="middle" >low</text>
        <text x="135" y="140" font-size="12" text-anchor="middle">mid</text>
        <text x="135" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>
    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>3</mn><mo>+</mo><mn>3</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>3</mn></mrow></math></span>
bingo！mid指向29，刚好是我们要找的，好吧，麻烦是麻烦了点
但是编程实现起来比其他简单啊🤨

<hr class="hr-shadow">

(6)堆排序（大根堆/小根堆）
    <span style="color: #00daff">对{5,1,6,9,2}如何构造大/小根堆</span>
    怎么说呢，就是大小根堆简单就是根是最大/小的就是
    我们操作的步骤第一步就是将给出的数列按完全二叉树排列(完全二叉树不知道的话那，废了)
    <canvas id="myCanvas17" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas17');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'5    【1】' },
        { x: 150, y: 100,label:'1    【2】' },
        { x: 400, y: 100,label:'6    【3】' },
        { x: 100, y: 175, label:'9    【4】' },
        { x: 190, y: 175, label:'2    【5】' },

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
我们这样5个数，我们取一半（向下取整）
    <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mn>5</mn><mn>2</mn></mfrac><mo>=</mo><mn>2</mn></mrow></math>
我们从第二个数开始即1【2】开始比较它与它的左右孩子们的大小，大的放根上就行
    <canvas id="myCanvas18" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas18');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'5    【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'6    【3】' },
        { x: 100, y: 175, label:'1    【4】' },
        { x: 190, y: 175, label:'2    【5】' },

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
    然后再第1个数即5【1】比较它与它的左右孩子大小
    <canvas id="myCanvas19" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas19');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'9    【1】' },
        { x: 150, y: 100,label:'5    【2】' },
        { x: 400, y: 100,label:'6    【3】' },
        { x: 100, y: 175, label:'1    【4】' },
        { x: 190, y: 175, label:'2    【5】' },

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
以上就是大根堆的构造过程，小根堆同理但是这只是简单数字比较少的时候的情况
一旦数字过多就会出现，一些没讲过的情况例如
    {9,43,-54,4,-13,10,36}(初步一看就不是最大根堆/最小根堆，因为第一个数既不是最大也不是最小)
<canvas id="myCanvas20" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas20');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'9   【1】' },
        { x: 150, y: 100,label:'43    【2】' },
        { x: 400, y: 100,label:'-54  【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'36   【7】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
我们构造大根堆，第一步还是总个数/2
    <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mn>7</mn><mn>2</mn></mfrac><mo>=</mo><mn>3</mn></mrow></math>(向下取整)
比较第三个与它的左右孩子的大小，大的放根上
<canvas id="myCanvas22" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas22');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'9   【1】' },
        { x: 150, y: 100,label:'43    【2】' },
        { x: 400, y: 100,label:'36   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'-54   【7】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
接着比较第二个数与它的左右孩子的大小，大的放根上
<canvas id="myCanvas21" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas21');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'9   【1】' },
        { x: 150, y: 100,label:'43    【2】' },
        { x: 400, y: 100,label:'36   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'-54   【7】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
接着比较第一个数与它的左右孩子的大小大的放根上
<canvas id="myCanvas23" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas23');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'43   【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'36   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'-54   【7】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
OK，此时就是最大根堆了，哎呀呀，我想说的那种情况没有发生，
    就是那种像最后一步的时候，9和43不是换了嘛，9到新位置以后如果它的左右孩子有比它小的，也要再调换

然后就是仅仅这样不算是堆排序，这一步只是把最大值选出来了
我们可以通过移除最大值，来继续排但这样多此一举
不如直接让这个根（最大值）和我们的第七个数（大概率最小值）调换
调换以后，我们可以忽略它，然后重新排序
    按照我们说的，继续
<canvas id="myCanvas24" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas24');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'-54   【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'36   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'43   【被灭了】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
    嘿嘿
    <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mn>6</mn><mn>2</mn></mfrac><mo>=</mo><mn>3</mn></mrow></math>
    还是比较第三个数和它的左右孩子，但是这次，它只有左孩子了
    然后就是第二个数和它的左右孩子，9还是最大的，然后我们比较
    第一个数，发现36是最大的调上去
<canvas id="myCanvas25" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas25');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'36   【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'-54   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'43   【被灭了】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
    <span style="color: red">到这里并没有结束，我之前说的情况发生了</span>
    就是第六个数10比第三个数（掉下来的）-54大，此时同样需要换
    最终就是
<canvas id="myCanvas26" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas26');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'36   【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'10   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'-54 【6】' },
        { x: 440, y: 175, label:'43   【被灭了】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
然后就是再把根36和最后位第六位调换，然后重新排，以此往复
直到排完就是一个以完全二叉树的从小到大的排序了
小根堆是同理的。（暂时更到这里，累死我了😭😣🤤😬😰😨🥶🥵🥴😵‍💫🤧🤮🤢🫵😗）
</pre>
<pre>
    <span style="font-size: 50px" id="8"><span style="color: red">顺序存储</span>的<span style="color: #00aa00">线性表</span>的操作（初版）纯手打（原创）</span>
	<code>
        /*
* 线性表的ADT（抽象）
* 1.初始化。2.增删改查。3.判空。4.销毁。
* InitList(&L) 初始化
* ListInsert(&L,i,e) 插入操作，因为要修改表所以传入其本身
* ListDelete(&L,i,&e) 删除操作，因为也要删除表中元素所以传入其本身
* ListAlert(&L,i,e) 修改操作，因为同样修改表中元素所以传入其本身
* ListGetElem(L,i) 获取操作，因为并不需要修改表，所以只需要副本即可
* ElemIsNull(L) 判空操作，同样因为不需要修改表，所以只需要副本即可
* GetLength_List(L) 获取表长 同理
* DestroyList(&L) 销毁操作，因为要销毁表本身，所以要传入本身
* ShowList(L)
*/
#include< stdio.h >
#include< iostream >
#include< stdlib.h >//开辟内存空间必需的头文件
using namespace std;

//线性表的实现
//1.有限的序列
//2.序列中的每个元素都有唯一的前驱和后继，除了开头和结尾两个节点
//3.逻辑顺序与物理顺序相同
#define MaxSize 30//定义线性表的最大长度
//线性表的存储类型描述
typedef struct
{
	int data[MaxSize];
	int length;
}List;//List是别名 是整个结构体定义语句的替代者

bool InitList(List& L);
int ListInsert(List& L, int i, int e);
bool ListDelete(List& L, int i, int& e);
bool ListAlert(List& L, int i, int e);
int ListGetElem(List L, int i);
bool ElemIsNull(List L);
int GetLength_List(List L);
void DestroyList(List& L);
int ShowList(List L);

bool InitList(List &L)//初始化
{
	for (int i = 0; i < MaxSize; i++)
	{
		L.data[i] = 0;
		L.length = 0;
	}//一般初始化都是这样吧？如果没有赋值就会出现混乱
	return true;

}
int GetLength_List(List L)//获取表长
{
	//首先这个函数我本来不想添加的，因为结构体中的一个表长元素已经定义了表长
	//实现的角度来看就是将，结构体中的length赋值返回
	return L.length;
	//其实我是很纠结要不要减一的，被题目骗怕了
	//但是仔细一想，表长就是元素的个数，而不是数组小标
}
int ListInsert(List &L, int i,int  e)//插入
{
	//插入的算法的实现，就是传入插入的位置以及插入的元素值
	//其实我们拿到了表的本身也好改
	//我们先遍历到需要插入的，nonono，我突然想到，这位置不就是数组的下标-1吗？我把链表搞混了
	//但是我们的基本盘不变，要让程序变得壮硕
	//我们还要判断表能不能插入，有没有位置
	while(i <= 0 || i > MaxSize)
	{
		printf("插入输入不合法！请重新输入\n");
		scanf_s("%d%d", &i, &e);
	}
	if (L.length == MaxSize)
	{
		return 1;//1代表表现在已经不能插入数据了
	}
	//接下来我们就可以插入操作了记住数组的插入等，是需要将其后面的元素全部后移的
	//此时我们的插入位置i，并不是下标，而是下标+1=插入位置i
	for (int j = L.length -1 ; j >= i - 1;j--)
	{
		L.data[j + 1] = L.data[j];//我们这时候执行的是将插入位置（包括插入位置）的元素全部后移
	}
	//后移完成以后，我们将元素插入
	L.data[i - 1] = e;
	L.length++;//记得将长度加一
	return 2;//2代表程序已经成功插入元素
}

bool ListDelete(List &L, int i, int &e)//删除
{
	//表的元素删除操作，这不是删除表，而是删除表中的元素
	//删除是和增加反着来的，就是删了以后它后面的全部元素前移
	//第一步我们还是健壮性
	if (!ElemIsNull(L))
	{
		return 0;//返回0代表的是表是空的，没办法进行删除
	}
	//删除的位置一定是在表长范围内的
	if (i > L.length)
		return 0;
	//第二步就是删除了，我们还是先前移，再删除
	//等等，你有没有发现，我既然前移了，我直接把你覆盖不就是删除了？
	//牛逼,我们先把元素传出去
	e = L.data[i - 1];
	for (int j = i - 1; j < L.length - 1; j++)//为什么这里是表长 -1 ，而且还是小于号？就是我们不是想前移动吗？
		//假如此时j是倒数第二个，j++不就是倒数第一个了，这就是最后一次循环

	{
		L.data[j] = L.data[j++];
	}
	return 1;//成功删除返回一
}

bool ListAlert(List&L,int i,int e) //修改
{
	//判断表是否空，同时，修改的这个元素是否在表中，也就是这个删除的位置一定是小于等于表长的
	if (!ElemIsNull(L))
		return false;
	if (i > L.length)
		return false;
	//表的修改，我有点感觉多余了，但是这也是我学数据库得来的，增删改查一个不少
	L.data[i - 1] = e;
	return true;//修改成功返回真
}
int ListGetElem(List L,int i)//获取元素值
{
	//同样判断表空以及位置是否越界
	if (!ElemIsNull(L))
	{
		printf("表空\n");
		return 0;
	}
	if (i > L.length)
	{
		printf("你要删除的不存在\n");
		return 0;
	}
	//直接返回就行了
	return L.data[i - 1];
}
bool ElemIsNull(List L)//判空
{
	if (L.length == 0)
	{
		return false;
	}
	if (L.length != 0)
	{
		return true;
	}
}
void DestroyList(List &L)//销毁
{
	//销毁的操作,但是这个不是动态分配的内存所以不能手动销毁
	//这个是栈上的内存

}
int ShowList(List L)
{
	if (!ElemIsNull)
	{
		printf("表是空的或者不存在\n");
		return 0;
	}
	else {
		for (int i = 0; i < L.length; i++)
			printf("|%d|\n", L.data[i]);
	}
	return 1;

}


int main()
{
	int i = 0;
	int j=0, e=0;
	List L;
	printf("请选择你的操作：\n1.初始化\n2.增加元素\n3.修改元素\n4.删除元素\n5.查找元素\n6.打印所有元素值\n7.结束\n");
	scanf_s("%d", &i);
	while (i != 7) {
		switch (i) {
		case 1:

			if (InitList(L))
			{
				printf("初始化成功\n");
			}
			break;
		case 2:

			printf("请输入插入位置以及值\n");
			scanf_s("%d%d", &j, &e);
			ListInsert(L,j,e);
			break;
		case 3:

			printf("请输入需要修改的元素位置\n");
			scanf_s("%d", &i);
			printf("请输入需要修改的值\n");
			scanf_s("%d", &j);
			ListAlert(L, i, j);
			break;
		case 4:

			printf("请输入需要删除的位置\n");
			scanf_s("%d", &j);
			ListDelete(L,j,e);
			printf("第%d个元素值%d删除成功\n", j, e);
			break;
		case 5:

			printf("请输入你要查找的第几个元素\n");
			scanf_s("%d",&j);
			e = ListGetElem(L, j);
			printf("第%d个元素的值为%d\n",j,e);
			break;
		case 6:
			ShowList(L);
			break;
		case 7:
			return 0;
			break;
		}
		printf("请选择你的操作：\n1.初始化\n2.增加元素\n3.修改元素\n4.删除元素\n5.查找元素\n6.打印所有元素值\n7.结束\n");
		scanf_s("%d", &i);
	}
	return 0;
}
    </code>

</pre>
<pre>
    <span style="font-size: 50px" id="9"><span style="color: red">后缀表达式</span>的<span style="color: #00aa00">求值与转换</span></span>
    <span style="color: #00daff">四则运算表达式转化为后缀表达式的规则：</span>
    <span style="color: #e600ff">
        1.数字直接写
        2.运算符号如果级别高于栈顶的，直接入栈写上，如果等于或者低于栈顶的让栈顶先出，自己再进去
        3.左括号不管入，遇到右括号，将左括号上面的所有出栈
    </span>
    我们来举个例子：9+（3-1）×3+10
    数字直接写：<span style="color: red">9</span>
    然后就是+号，符号入栈
	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    然后就是（入
    	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >(</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是3，直接写
    <span style="color: red">93</span>
    然后就是-入
     	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >(</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >-</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是1，数字直接写
    <span style="color: red"> 931</span>
    然后就是）右括号，你瞧，直接打包出来，其实也没有就一个-号，收获不大啊，竹篮打水一场空
    <span style="color: red"> 931-</span>
       	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    然后就是x，和此时的栈顶+比较，谁牛逼，显然x牛点，所以入栈
           	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >x</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是3，数字直接写
    <span style="color: red">931-3</span>
    然后就是+，比较栈顶的x，哦豁，没有它厉害，乖乖让x出来
    就是
    <span style="color: red">931-3x</span>
    此时栈：
          	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    还没有完，还要继续比较现在的栈顶，是+和即将入的+是相等的，让栈顶出来
    <span style="color: red">931-3x+</span>
           	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        </g>
    </svg>
    这个时候，我们的+再入栈
      <span style="color: red">931-3x+</span>
           	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
                 <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是10，数字直接写
    <span style="color: red">931-3x+10</span>
    然后没了，栈里面的给我滚出来吧
    <span style="color: red">931-3x+10+</span>
    <hr>
    以上就是中转后缀表达式，下面讲讲如何模拟计算机一样，直接计算后缀表达式
    <span style="color: #e600ff">
    1.当是数字的时候直接入栈

    2.当是运算符号的时候

    3.就将栈的最上面两个数拿出进行运算 后 再将结果进栈 记住（栈顶元素永远在运算符号的右边）
    </span>
    看9 3 1 - 3 * + 10 2 / +
    9 3 1依次入栈，没有异议

    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >3</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >1</text>
        </g>
    </svg>
    接下来是-，取出栈顶的两个元素，分别是1 3，1是栈顶，放-号的右边
    就是3-1=2
    将2入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >2</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是 3 入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >2</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >3</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是*，取出来运算
    2*3=6，即便是*这种不在意次序的，你也务必养成习惯将栈顶放右边
    6入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >6</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是+，取出运算
    9+6=15，15入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是10，数字入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >10</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是
    2入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >10</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >2</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是/，取出两个运算
    10/2=5入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >5</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是+，取出来运算
    15 + 5 = 20
    好了，这就是最后结果了，不信你自己算嘛，给你9+（3-1）x 3+10/2

</pre>
<pre>
    <span style="font-size: 50px;color: red" id="10">时间复杂度、空间复杂度</span>
<code>
#include < iostream >
#include < vector >
using namespace std;
bool find(vector< int > &nums);
int main()
{
    //时间复杂度，假设输入的数据量大小为N
    //时间复杂度统计的是【计算的操作数量】而不是【运行的绝对时间】
    //其次【计算的操作数量】和【运行的绝对时间】的正相关(并不是相等)
    //再次，运行时间受到【运行环境、语言、处理器】的影响
    //⬯[最差]、⊝[平均]、Ω[最佳]
    vector< int > a;
    a.push_back(1);
    a.push_back(2);
    a.push_back(7);
    if (find(a))
    {
        cout << "找到啦！" << endl;
    }
    else
    {
        cout << "没有找到" << endl;
    }
}
bool find(vector< int > &nums)
{
    for (int i=0;i < nums.size();i++)
    {
        if (nums[i] == 7)
        {
            return true;
        }
    }
    return false;
}
//最好的情况就是【7,a,b,c,e,d,da,a,s,sa,】第一次就找到了
//最坏的情况就是整个数组都没有7，循环了一遍也没有
//常见的算法时间复杂度有：⬯(1)<⬯(log N)<⬯(N)<⬯(N log N)<⬯(N²)<⬯(2^N)<⬯(N!)
//⬯(1)表示运行次数不随输入数据大小N的变化而变化
int algo(int N)
{
    int a = 1;
    int b = 2;
    int x = a * b + N;
    return 1;

}
//⬯(N)运行次数和N大小是线性关系
int algo1(int N)
{
    int a = 0;
    for (int i = 0; i < N; i++)//运行了N次
    {
        a++;
    }
    return a;
}
//⬯(N²)表示运行次数和N还是线性关系，但是是N²的关系
int algo2(int N)
{
    int a = 0;
    for (int i = 0; i < N; i++)//此处运行了N次
    {
        for (int j = 0; j < N; j++)//又运行了N次
        {
            a++;
        }
    }//总体上运行了N的平方次
}
//⬯(2^N)是指数级，类似我们的细胞分裂，一分为二，二分为四，四分为八
int algo3(int N)
{
    if (N <= 0)
        return 0;
    int a = algo3(N - 1);//递归调用，自我递归叫做直接递归
    int b = algo3(N - 1);//这两个式子，就是让每一个都可以一分为二
    return a + b;
}
//⬯(N!)这个是一开始分裂的是N个，然后每一层分裂比上一层少一个
int algo4(int N)
{
    if (N <= 0)return 1;
    int a = 0;
    for (int i = 0; i < N; i++)
    {
        a += algo4(N - 1);//为什么这里用循环，因为循环的次数的外层循环×上内层循环的次数，每向内一层的循环次数-1就能达到我们想要的效果
    }
    return a;
}
//⬯(log N)对数阶和指数阶是相反的，指数阶是每轮分裂，这个是每轮结合，也就是八合四，四合二，二合一
int algo5(int N)
{
    int a = 0;
    float i = N;
    while (i > 1)
    {
        i = i / 2;
        a++;
    }
    return a;
}
//⬯(N log N)，相信你已经明白了，不就是套个N的循环嘛，yes
int algo6(int N)
{
    int a = 0;
    float i = N;
    while (i > 1)//while循环次数为log N，因为每次减半
    {
        i = i / 2;
        for (int j = 0; j < N; j++)//循环次数为N
        {
            a += 1;
        }
    }
    return a;
 }
//------------------------------------------------------------------------
//空间复杂度
//栈帧空间
int test()
{
    return 0;
}
int algor(int N)
{
    for (int i = 0; i < N; i++)
    {
        test();//这个循环中每次调用函数test以后，栈帧空间就会被释放
    }
}//因此这个函数的空间复杂度为⬯(1)

//---------------------------------------

int algor1(int N)
{
    if (N <= 1)
    {
        return 1;
    }
    return algor1(N - 1) + 1;//注意这是个递归函数，每次使用了，栈帧空间是不释放的
}//因此空间复杂度为⬯(N)
</code>
</pre>
<pre>
    <span style="font-size: 50px;color: red" id="11">链表例题</span>
     问题如下：我们实现图书的管理员手上有一张链表图书表，其中int为图书编号，现在我们需要倒序输出图书的编号
    <code>
#include< stdio.h >
#include< iostream >
using namespace std;
struct book
{
	int head;
	book* prev;
	book* next;
};
int main()
{
	int a = 0;
	cout << "请输入你想要添加书本的数量" << endl;
	cin >> a;
	cout << sizeof(book) << endl;
	book* b = (book*)malloc(sizeof(book));

	book* p = b;
	for (int i = 0; i < a; i++)
	{
		int j = 0;
		cout << "请输入第"<< i+1<<"本书的编号" << endl;
		cin >> j;
		b->head = j;
		//book* temp = b;
		b->next = (book*)malloc(sizeof(book));
		b->next->prev = b;
		b = b->next;
		//b->prev = temp;
	}
	b = b->prev;
	cout << "书本倒序的编号为：" << endl;
	for (int i = 0;i < a;i++)
	{

			cout << b->head << endl;
			b = b->prev;

	}

	return 0;
}
        我们具体来分析一下思路，结构体定义，没话可说吧？我一开始只定义了后续节点的指针，导致我倒序输出，没办法，当然硬实现还是可以的，反正耍赖谁都会
        我是那种理论学的太多了，实践就傻眼了，结构体初始化，我竟然还是数组的那种思想
        就是我以为一开始就初始化好就行了，但是细看就是内存谁知道在哪里，怎么初始化？我这段话看起来可能有点语无伦次
        事实上也是如此，好了，就是说链表其实是动态的主动的给分配内存的，b->next = (book*)malloc(sizeof(book));的作用就是分配内存


    </code>
</pre>


<pre>
    <span style="font-size: 50px;color: red" id="12">栈与队列</span>
     栈是限定在表尾进行修改操作的线性表
    允许操作的一端为栈顶(top)，另一端为栈底(bottom)
    <code>
ADT 栈
Data
	 同线性表，元素具有相同类型，相邻元素具有前驱和后继关系
Operation
	InitStack(*S):初始化，建立栈
	DestroyStack(*S):若栈存在就摧毁
	ClearStack(*S):将栈清空
	StackEmpty(S):若栈为空，返回true，否则返回false
	GetTop(S,*e):若栈存在且非空，用e返回栈顶元素
	Push(*S,e):若栈存在，插入新元素e到栈中成为新栈顶
	Pop(*S,*e):删除栈S中栈顶元素，并用e返回其值
	StackLength(S):返回栈S的元素个数
endADT
        别觉得不重要，当你真的到那种境界的时候，看以上的东西就够了
        别问，问就是答：我当然没有到那种境界了
----------------------------------------
typedef struct
{
	int data[MaxSize];//栈
	int top;//栈顶指针
}stack;
-----------------------------------------
    </code>
</pre>



<button id="downloadBtn">下载 本页面PDF</button>

<script>
    var downloadBtn = document.getElementById('downloadBtn');
    downloadBtn.addEventListener('click', function () {
        var element = document.getElementById('pdf');

        html2pdf(element);
    });
</script>




</body>
</html>