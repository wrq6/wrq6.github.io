<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>data structure</title>
    <style>
        body {
            font-family: Consolas, monospace;
            background-color: #f5f5f5;
            padding: 20px;
        }

        h1 {
            color: #333;
            font-size: 24px;
            margin-bottom: 20px;
        }

        h2 {
            color: #666;
            font-size: 20px;
            margin-top: 40px;
            margin-bottom: 10px;
        }

        pre {
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        code {
            display: block;
            color: #000;
        }
        .audio-wrapper {
            display: flex;
            justify-content: center;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }

        table, th, td {
            border: 1px solid black;
        }

        th, td {
            padding: 10px;
            text-align: center;
        }
    </style>
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>

<div id="lyric-container"></div>
<div class="audio-container">
    <audio controls ontimeupdate="showLyrics()">
        <source src="music/b.mp3" type="audio/mpeg">
        是妈妈是女儿 - 黄绮珊,希林娜依高
    </audio>
</div>
<script>
    var lyricContainer = document.getElementById("lyric-container");
    var audio = document.getElementsByTagName("audio")[0];
    var lyrics = []; // 存储所有歌词的数组

    function loadLyrics() {
        // 获取歌曲名称，用于加载对应的歌词文件
        var songName = audio.getElementsByTagName("source")[0].src.split("/").pop().replace(".mp3", "");
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function () {
            if (this.readyState == 4 && this.status == 200) {
                var lyricText = this.responseText;
                lyrics = parseLyrics(lyricText); // 解析歌词文本并存储到数组中
                console.log("已加载 " + lyrics.length + " 行歌词。");
            }
        };
        xhttp.open("GET", "geci/" + songName + ".lrc", true); // 修改为您存放歌词文件的路径
        xhttp.send();
    }

    function parseLyrics(lyricText) {
        var lines = lyricText.split("\n");
        var result = [];
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            var timeRegex = /\[(\d{2}):(\d{2})\.(\d{2})\]/; // 匹配时间标签的正则表达式
            var matches = line.match(timeRegex);
            if (matches) {
                var minutes = parseInt(matches[1]);
                var seconds = parseInt(matches[2]);
                var milliseconds = parseInt(matches[3]);
                var text = line.replace(timeRegex, "").trim();
                var time = minutes * 60 + seconds + milliseconds / 100;
                result.push({ time: time, text: text });
            }
        }
        return result;
    }

    function showLyrics() {
        loadLyrics(); // 加载歌词
        var currentTime = audio.currentTime;
        var displayedLyrics = []; // 存储要显示的歌词行
        for (var i = 0; i < lyrics.length; i++) {
            if (currentTime >= lyrics[i].time) {
                displayedLyrics.push(lyrics[i]);
            }
        }
        if (displayedLyrics.length > 0) {
            var lyricsHTML = '';
            for (var j = 0; j < displayedLyrics.length; j++) {
                lyricsHTML += '<p>' + displayedLyrics[j].text + '</p>';
            }
            lyricContainer.innerHTML = lyricsHTML;
            lyricContainer.scrollTop = (displayedLyrics.length - 1) * 25; // 滚动到最后一行歌词
            lyrics.splice(0, displayedLyrics.length); // 删除已经显示的歌词行
        }
    }


    // 在音频播放时调用 showLyrics 函数
    audio.addEventListener("timeupdate", function () {
        showLyrics();
    });

</script>
<pre>
     <span style="font-size: 50px">浅析KMP算法之Next数组</span>
	<code>
首先我们需要知道KMP是干嘛的，通俗易懂的来讲是查找相同字符串的一种捷径
我们人的本能的趋简避繁，例如aababcbdaabacbbbd这样的字符串，我们需要在其中找到子串aabacb我们怎么操作？
为什么会将子串第一个字符一次对比字符串的每一个字符来判断：
=----------1---------=
aababcbdaabacbbbd
aabacb
=----------2---------=
aababcbdaabacbbbd
 aabacb
=----------3---------=
aababcbdaabacbbbd
  aabacb
=----------4---------=
aababcbdaabacbbbd
   abacb
=----------5---------=
aababcbdaabacbbbd
    abacb
=----------6---------=
aababcbdaabacbbbd
     abacb
=----------7---------=
aababcbdaabacbbbd
      abacb
=----------8---------=
aababcbdaabacbbbd
       abacb
=----------9---------=
aababcbdaabacbbbd
        abacb
=----------10---------=
aababcbdaabacbbbd
         abacb
=----------end完结撒花---------=
怎么样是不是很麻烦吧？//麻烦个嘚，我就喜欢
不是，既然计算机大拿说了麻烦咱就认行吗？
于是开头字母分别为KMP的三个人设计了一个算法叫KMP算法（具体思路自己百度，以下只解释最重要也是最难理解的Next数组该怎么求）
Next数组说白了就是求子串中每一个最长相等前后缀（听不懂没关系，往下看）
这里声明一个规则：
前缀：不包含未元素的串
后缀：不包含首元素的串
我们来举个例子这是子串|a|a|b|a|a|f|
（1）|a|
前缀以及后缀都为0  导致最长相等前后缀为0
（2）|a|a|
前缀为|a|
后缀为|a|相等
最长相等前后缀为1
（3）|a|a|b|
前缀为|a|a|
后缀为|a|b|不相等
在这有两个元素的前后缀的基础上再下一次比较
前缀|a|
后缀|b|依然不相等//注意这里的|a|和|b|不是后缀中的|a|b|拆分的，是前缀|a|a|的第一个|a|以及后缀|a|b|最后的那个|b|
最长相等前后缀为0
（4）|a|a|b|a|
前缀为|a|a|b|
后缀为|a|b|a|当然不相等
在这有三个元素的两个前后缀的基础上再下一次比较
前缀|a|a|
后缀|b|a|依然不相等
同理再比较
前缀|a|
后缀|a|相等
所以最长相等前后缀为1
（5）|a|a|b|a|a|
前缀|a|a|b|a|
后缀|a|b|a|a|不等
再前缀|a|a|b|
后缀|b|a|a|不等
再|a|a|
后缀|a|a|相等长度为2
最长相等前后缀为2
（6）|a|a|b|a|a|f|
前缀|a|a|b|a|a|
后缀|a|b|a|a|f|不等
前缀|a|a|b|a|
后缀|b|a|a|f|不等
前缀|a|a|b|
后缀|a|a|f|不等
前缀|a|a|
后缀|a|f|不等
前缀|a|
后缀|f|不等
所以最长相等前后缀为0
所以Next数组的值就是，这6个算出来的数值
即|0|1|0|1|2|0|
以上为理论部分（聪明的人会看到这里的）

以下是代码实现部分（C++）
#include < stdio.h >
#include < iostream >//c++的头文件
#include< string >
using namespace std;//c++的命名空间，如果没有这句话，很多地方会这样写std::cout等等
class solution {//定义类，c++语法
public://公共方法（好像java才说方法）以及属性
    void getnext(int* next, const string& s) {//传入next数组以及字串
        int j = 0;//j初始化为0
        next[0] = 0;//首元素设置为0
        for (int i = 1; i < s.size(); i++) {//我们假设i指向后缀的末尾，j指向前缀的末尾
            while (j > 0 && s[i] != s[j]) {//while是用来处理前后缀不相同的情况
                j = next[j - 1];//这句代码的意思是回退，回退到前一个数组元素的值为数组下标处
            }
            if (s[i] == s[j]) {//if用来处理前后缀相同的情况
                j++;//如果想相同，则会将j++，让j来表示最长相等前后缀的情况
            }
            next[i] = j;//让此处的最长相等前后缀为j的值
        }
    }
};
int main()
{
    int next[8];
    string s = "abcabcab";
    solution*a = new solution();
    a->getnext(next,s);
    for(int i=0;i<8;i++)
    printf("%d",next[i]);
}
        //放心，代码你十有八九看不懂，不过没关系，毕竟你要是自己研究出来了
        //你就是KMP的发明者了，今天看几遍，过几天再来，慢慢的就理解了
	</code>
</pre>

<pre>
     <span style="font-size: 50px">图的最小生成树</span>
    <p>          给定图，利用<span style="color: red">Kruskal算法（克鲁斯卡算法）</span>生成最小生成树</p>

    <canvas id="myCanvas" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[4], end: vertices[2], weight: 7 },
        { start: vertices[2], end: vertices[3], weight: 15 },
        { start: vertices[3], end: vertices[1], weight: 40 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[1], end: vertices[0], weight: 50 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
    (1) 找出最小的边
    即
       <canvas id="myCanvas1" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas1');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
    (2) 继续找出最小的边
    即
       <canvas id="myCanvas2" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas2');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[0], end: vertices[3], weight: 8 },
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
(3) 继续找出最小的边
    即
       <canvas id="myCanvas3" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas3');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[0], end: vertices[4], weight: 10 },
                { start: vertices[0], end: vertices[3], weight: 8 },
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
    (4) 继续找出最小的边<span style="color: red">(注意：这里之所以是选40而不是15的边是因为C和D已经有了通路)</span>
    即
       <canvas id="myCanvas4" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas4');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[3], end: vertices[1], weight: 40 },
                { start: vertices[0], end: vertices[4], weight: 10 },
                { start: vertices[0], end: vertices[3], weight: 8 },
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
    <br style="border: #6f42c1">
    <br style="border: #6f42c1">
    <br style="border: #6f42c1">
   <p>          给定图，利用<span style="color: red">Prim算法（普里姆算法）</span>生成最小生成树，给定A为初始点</p>

    <canvas id="myCanvas5" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas5');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[4], end: vertices[2], weight: 7 },
        { start: vertices[2], end: vertices[3], weight: 15 },
        { start: vertices[3], end: vertices[1], weight: 40 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[1], end: vertices[0], weight: 50 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
    (1) 选出与A相连的最小权值的边
    即
        <canvas id="myCanvas6" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas6');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[3], weight: 8 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
        (2) 选出与AD相连的最小权值的边
    即
        <canvas id="myCanvas7" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas7');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[0], end: vertices[3], weight: 8 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
            (3) 选出与ADE相连的最小权值的边
    即
        <canvas id="myCanvas8" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas8');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[4], end: vertices[2], weight: 7 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
                (4) 选出与ADEC相连的最小权值的边(注意：不能选择已经用通路的两点的边)
    即
        <canvas id="myCanvas9" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas9');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[1], end: vertices[3], weight: 40 },
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[4], end: vertices[2], weight: 7 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
    <span style="font-size: 20px">总结两种算法的结果是相同的，但是其过程是不同的，解答这类题目的答案就是需要步骤的</span>
</pre>

<pre>
     <span style="font-size: 50px">哈夫曼树</span>
    <p>          已知      <table>
        <tbody>
            <tr>
                <td>A</td>
                <td>B</td>
                <td>C</td>
                <td>D</td>
                <td>E</td>
            </tr>
            <tr>
                <td>0.15</td>
                <td>0.16</td>
                <td>0.07</td>
                <td>0.21</td>
                <td>0.41</td>
            </tr>
        </tbody>
    </table>
    (1)画出相对应的哈夫曼(Huffman)树
    (2)计算带权路径长度WPL
    (3)求A、B、C、D、E的哈夫曼(Huffman)编码</p>
    （1）取最小的两者不断重构(结合以后的生成的数再放到整个比较)
    以下是详细步骤
<span style="color: #ff00c5">1>ABCDE中A与C的数值最小于是乎先画出A C</span>
    <canvas id="myCanvas10" width="800" height="200"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas10');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [

        { x: 75, y: 25, label: '   0.22' },
        { x: 50, y: 100, label: 'A(0.15)' },
        { x: 150, y: 100, label: 'C(0.07)' },


    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    <span style="color: #ff00c5">2>把A和C的合并数值0.22当成AC再去和剩下的B、D、E比较大小，选出最小两个(也就是B和D)，这个时候刚才画的就别动，在旁边重新画一棵树</span>
        <canvas id="myCanvas11" width="800" height="200"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas11');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        // { x: 250, y: 50, label: '       |  ' },
        // { x: 150, y: 100, label: '0.59' },
        // { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 25, label: '   0.37' },
        { x: 75, y: 25, label: '   0.22' },
        { x: 50, y: 100, label: 'A(0.15)' },
        { x: 150, y: 100, label: 'C(0.07)' },
        { x: 300, y: 100, label: 'B(0.16)' },
        { x: 400, y: 100, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[4] },
        { start: vertices[0], end: vertices[5] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
<span style="color: #ff00c5">3>思想同上(别告诉我你现在还没有看明白😒😒😒)</span>
            <canvas id="myCanvas12" width="800" height="300"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas12');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label: '      1' },
        { x: 150, y: 100, label: '    0.59' },
        { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 175, label: '   0.37' },
        { x: 75, y: 175, label: '   0.22' },
        { x: 50, y: 250, label: 'A(0.15)' },
        { x: 150, y: 250, label: 'C(0.07)' },
        { x: 300, y: 250, label: 'B(0.16)' },
        { x: 400, y: 250, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    <span style="color: red">以上就是对应的完整的哈夫曼树了</span>

    (2)计算WPL（看带字母的节点，然后看这个节点到顶点经过了几条边，经过几条就数值*几就行）
    例如A，从顶点到A经过了4条边(幼儿园的都知道怎么数🤣🤣🤣)
    也就是0.15*4，总之把所有字母的边*数加起来就是WPL
    ∴WPL=1*0.41+3*0.15+3*0.07+3*0.06+3*0.21//*是乘号✖，我靠这样看起来很头疼吗？？这不就是程序员必备的？
    ∴WPL=1✖0.41+3✖0.15+3✖0.07+3✖0.06+3✖0.21//满足你

    (3)求哈夫曼编码（将哈夫曼树的左边画0，右边画1，你就知道了）

<canvas id="myCanvas13" width="800" height="300"></canvas>

<script>
    var canvas = document.getElementById('myCanvas13');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label: '      1' },
        { x: 150, y: 100, label: '    0.59' },
        { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 175, label: '   0.37' },
        { x: 75, y: 175, label: '   0.22' },
        { x: 50, y: 250, label: 'A(0.15)' },
        { x: 150, y: 250, label: 'C(0.07)' },
        { x: 275, y: 250, label: 'B(0.16)' },
        { x: 400, y: 250, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] ,weight:0},
        { start: vertices[0], end: vertices[2] ,weight:1},
        { start: vertices[1], end: vertices[3] ,weight:1},
        { start: vertices[1], end: vertices[4] ,weight:0},
        { start: vertices[4], end: vertices[5] ,weight:0},
        { start: vertices[4], end: vertices[6] ,weight:1},
        { start: vertices[3], end: vertices[7] ,weight:0},
        { start: vertices[3], end: vertices[8] ,weight:1},
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    然后就是从顶点开始往字母走，假如我们选D，D的编码就是011(简单吧🫵)
    答案就是：
    A:000
    B:010
    C:001
    D:011
    E:1
    别觉得哈夫曼编码就是固定长度(🤣🫵)
        </pre>
</body>
</html>