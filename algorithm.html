<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Showcase</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
        }
        #algorithm-container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin: 20px auto;
            padding: 20px;
            max-width: 800px;
        }
        #algorithm-title {
            font-size: 24px;
            margin-top: 0;
        }
        #algorithm-description {
            font-size: 16px;
            color: #666;
        }
        #algorithm-code {
            background-color: #f9f9f9;
            border-radius: 4px;
            padding: 10px;
            overflow-x: auto;
        }
        #button-container {
            overflow: hidden;
            width: 300px; /* 设置按钮区域的宽度 */
            border: 1px solid #ccc;
            border-radius: 4px;
            margin: 20px auto;
        }
        #buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            transition: transform 0.3s ease;
            padding-bottom: 40px; /* 留出滚动条的空间 */
        }
        .button {
            flex: 0 0 auto;
            width: 100px; /* 设置每个按钮的宽度 */
            height: 40px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 4px;
            margin: 10px;
            cursor: pointer;
        }
        #slider {
            width: 100%;
            margin-top: 10px;
        }
        #solution-container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin: 20px auto;
            padding: 20px;
            max-width: 800px;
        }
        #solution-title {
            font-size: 20px;
            margin-top: 0;
        }
        #solution-content {
            font-size: 16px;
            color: #666;
        }
    </style>
</head>
<body>
<div id="algorithm-container">
    <h1 id="algorithm-title">算法合集(C语言编写，C++文件实现)</h1>
    <p id="algorithm-description">这是一个示例代码，跳转点击按钮</p>
    <pre id="algorithm-code" class="language-javascript">
      <code id="code-block">
        // 示例代码
        int main(){
          printf("我的一生是这样的吗？");
          }
      </code>
    </pre>
</div>
<div id="solution-container">
    <h2 id="solution-title">解决思路和难点</h2>
    <div id="solution-content">这里是描述解决思路的</div>
</div>
<div id="button-container">
    <div id="buttons">
        <button class="button" onclick="showAlgorithm(1)">两数之和</button>
        <button class="button" onclick="showAlgorithm(2)">两数相加</button>
        <button class="button" onclick="showAlgorithm(3)">无重复字符的最长子串</button>
        <button class="button" onclick="showAlgorithm(2)">Algorithm 4</button>
        <button class="button" onclick="showAlgorithm(2)">Algorithm 5</button>
        <button class="button" onclick="showAlgorithm(2)">Algorithm 6</button>
        <button class="button" onclick="showAlgorithm(2)">Algorithm 7</button>
        <button class="button" onclick="showAlgorithm(2)">Algorithm 8</button>
        <button class="button" onclick="showAlgorithm(2)">Algorithm 9</button>
        <button class="button" onclick="showAlgorithm(2)">Algorithm 10</button>
    </div>
    <!-- Add more buttons for additional algorithms -->
    <input type="range" id="slider" min="0" max="100" value="0">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
<script>
    const buttonContainer = document.getElementById('buttons');
    const slider = document.getElementById('slider');
    slider.addEventListener('input', () => {
        const value = slider.value;
        const translateX = -value * (buttonContainer.offsetWidth - document.getElementById('button-container').offsetWidth) / 0.1;
        buttonContainer.style.transform = `translateX(${translateX}px)`;

    });

    function showAlgorithm(algorithmNumber) {
        // 根据算法编号加载对应的数据
        let title, description, code,solutioncontent,src;
        if (algorithmNumber === 1) {
            title = "两数之和";
            solutioncontent = "没有难度";
            description = "给定目标整数数组nums和目标值target,找出和为目标值的两个整数，并返回数组下标";
            src='math/img/hero/2.jpg';
            code = `
#include< stdio.h >
#include< iostream >
using namespace std;
//给定目标整数数组nums和目标值target,找出和为目标值的两个整数，并返回数组下标
int* twoSum(int* nums, int numsSize, int target, int* returnSize)
{
\t
\tfor (int i = 0; i < numsSize; i++)
\t{
\t\tfor (int j = i + 1; j < numsSize; j++)
\t\t{
\t\t\tif (nums[i] + nums[j] == target)
\t\t\t{
\t\t\t\tint* temp = (int*)malloc(sizeof(int) * 2);
\t\t\t\t*returnSize = 2;
\t\t\t\tif (temp != NULL)
\t\t\t\t{
\t\t\t\t\ttemp[0] = i;
\t\t\t\t\ttemp[1] = j;
\t\t\t\t}
\t\t\t\treturn temp;
\t\t\t}
\t\t}
\t}
\t*returnSize = 0;
\treturn NULL;
}
int main()
{
\tint a = 0;
\tint c = 0;
\tint* d = 0;
\tint* e = (int*)malloc(sizeof(int) * 2);
\tprintf("请输入你想要建立的数组大小\\n");
\tscanf_s("%d", &a);
\tint* b = (int*)malloc(sizeof(int) * a);
\tprintf("\\n接下来输入你的数组的值\\n");
\tfor (int i = 0; i < a; i++)
\t{
\t\tprintf("请输入第%d个元素值\\n",i+1);
\t\tscanf_s("%d", b+i);
\t}
\tprintf("恭喜数组创建完成！\\n");
\tprintf("请输入一个数，我将返回数组中两个数和为此数的数值以及其数组的下标\\n");
\tscanf_s("%d",&c);
\te = twoSum(b,a,c,d);
\tif (e != NULL)
\t{
\t\tfor (int i = 0; i < 2; i++)
\t\t{
\t\t\tprintf(" 第%d个数为%d", i + 1, b[e[i]]);
\t\t}
\t\tfor (int i = 0; i < 2; i++)
\t\t{
\t\t\tprintf(" 第%d个数下标为%d", i + 1, e[i]);
\t\t}
\t}
\telse {
\t\tprintf("数组中没有两个数和为%d的", c);
\t}
\treturn 0;
}
        `;
        } else if (algorithmNumber === 2) {
            title = "两数相加";
            description = "给定两个非空链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储，并且每个节点只能存储一位数字，将两个数相加，以相同形式返回一个表示和结果的链表";
            solutioncontent = "这道题给我难点在于，我创建两个存储输入整数数字的链表的时候，\n第一个问题就是怎么样把当前指针指向下一个的同时，让下一个的前驱指针指向当前指针，\n这并不是一件很好笑的事情man，我思考了很久，我总觉得有点驳论，\n因为我一种感觉就是，你让你的儿子生出你来一样。\n我是真的蠢啊，直接先给后继指针p->next 分配空间，\np->next 就是后继指针，然后让后继指针的前驱指向p，也就是p->next->prev = p，\n然后再把当前指针指向后继p = p->next。就这么简单\n第二个问题就是给链表的每一个节点赋值的时候，\n你会发现就是，总会最后一个指针多分配，也就是当你存完了所有数\n然后它最后还会再开辟一个内存，最后一个存有数字的节点的下一个是有内存的，\n不是NULL，但是其中是没有存数字的\n会造成你打印的时候总会打印出未初始化的东西\n然后我的解决办法就是，在给链表赋值完成以后\np->prev->next = NULL;\n懂我意思吧？就是最后一个节点不是多余了嘛，我让最后一个的前一个节点的指向变为NULL，\n让最后一个节点不被指向，但是记得释放内存，我这里没有free(指针)";
            code = `
#include< stdio.h >
#include< iostream >
using namespace std;
struct ListNode
{
\tint a=0;
\tListNode* next = nullptr;
\tListNode* prev = nullptr;
};
//给定两个非空链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储，并且每个节点只能存储一位数字
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2)
{
\tint a = 0;
\tint b = 0;
\tint c = 0;
\tint d = 0;
\tint e = 0;
\tint temp = 1;
\tint temp1 = 1;
\twhile (l1!=NULL)
\t{
\t\twhile(c)
\t\t{
\t\t\ttemp *= 10;
\t\t\tc--;
\t\t}
\t\tif(l1->a!=NULL)
\t\ta += l1->a * temp;
\t\tl1 = l1->next;
\t\tc++;
\t}
\twhile (l2!=NULL)
\t{
\t\twhile (d)
\t\t{
\t\t\ttemp1 *= 10;
\t\t\td--;
\t\t}
\t\tif (l2->a != NULL)
\t\tb += l2->a * temp1;
\t\tl2 = l2->next;
\t\td++;
\t}
\te = a + b;
\tListNode* p = (ListNode*)malloc(sizeof(ListNode));
\tListNode* q = p;
\twhile (e)
\t{
\t\tp->a = e % 10;
\t\tp->next = (ListNode*)malloc(sizeof(ListNode));
\t\tp->next->prev = p;
\t\tp = p->next;
\t\te = e / 10;
\t}
\tp->prev->next = NULL;
\treturn q;
}
int main()
{
\tint a = 0;
\tint b = 0;
\tListNode* l1;
\tListNode* l2;
\tl1 = (ListNode*)malloc(sizeof(ListNode));
\tprintf("请输入你的第一个整数数字(只允许输入正整数)\\n");
\tscanf_s("%d",&a);
\tListNode* p = l1;
\twhile (a)
\t{
\t\tl1->a = a % 10;
\t\t\tl1->next = (ListNode*)malloc(sizeof(ListNode));
\t\t\tl1->next->prev = l1;
\t\t\tl1 = l1->next; // 更新当前节点指针
\t\ta = a / 10;
\t}
\tl1->prev->next = NULL;
\t//l1 = nullptr;
\t//while (p!= nullptr)
\t//{
\t//\t
\t//\t\tprintf("%d", p->a);
\t//\t\tp = p->next;
\t//\t
\t//\t
\t//}
\tprintf("请输入你的第二个整数数字(只允许输入正整数)\\n");
\tscanf_s("%d", &b);
\tl2 = (ListNode*)malloc(sizeof(ListNode));
\tListNode* q = l2;
\twhile (b)
\t{
\t\tl2->a = b % 10;
\t\t\tl2->next = (ListNode*)malloc(sizeof(ListNode));
\t\t\tl2->next->prev = l2;
\t\t\tl2 = l2->next; // 更新当前节点指针
\t\tb = b / 10;
\t\t
\t}
\tl2->prev->next = NULL;
\tListNode* answer = addTwoNumbers(p,q);
\twhile (answer)
\t{
\t\tprintf("%d",answer->a);
\t\tanswer = answer->next;
\t}
\treturn 0;
}

        `;

        }else if(algorithmNumber ===3){
            title = "无重复字符的最长子串";
            description="给定一个字符串，找出其中不含重复字符的最长子串的长度";
            solutioncontent = "这道题的难点在于你怎么样判断子串不重复，以及重复了怎么办。我没写出来\n我看到了网上的一种办法，确实挺牛的\n运用ASCII码只有128数字位，来判断有无重复，0判等没有就赋值为1\n有的话也就是判等为1的时候，将左指针右移\n我一开始会想这是不是会造成有些最大串的丢失\n但是仔细一看不会，因为求的是字串，重复就丢掉前一个\n不重复就加入，不断记录最长的子串长度" +
                "\n挺牛的";
            code =
                '#include< stdio.h >\n' +
                '#include< iostream >\n' +
                'using namespace std;\n' +
                '//给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。\n' +
                'int lengthOfLongestSubstring(char* s) {\n' +
                '    int sLen = strlen(s); //获取字符串长度\n' +
                '    int left = 0, right = 0; //左右指针\n' +
                '    int res = 0, cnt = 0; //结果和计数\n' +
                '    int tmp[128] = { 0 }; //以128位数组记录子串中的字符是否已经出现\n' +
                '\n' +
                '    while (right < sLen) {           //循环条件为右指针小于字符串长度\n' +
                '        if (0 == tmp[s[right]]) {  //当右指针指向的字符没出现在子串中时\n' +
                '            tmp[s[right]] = 1;       //使用tmp数组记录右指针指向的字符在ascii码中对应的位置（这一点太牛逼了，大佬牛逼）\n' +
                '            right++;                     //右指针右移\n' +
                '            cnt++;                       //计数加1\n' +
                '            res = res > cnt ? res : cnt;   //记录结果\n' +
                '        }\n' +
                '        else {                            //当右指针指向的字符出现在子串中时\n' +
                '            tmp[s[left]] = 0;     //左指针指向字符的ascii码不再出现在tmp数组中\n' +
                '            left++;                    //左指针右移\n' +
                '            cnt--;                      //计数减1\n' +
                '        }\n' +
                '    }\n' +
                '    return res;          //返回最终无重复字串长度\n' +
                '}\n' +
                'int main() {\n' +
                '\tprintf("请输入你的一个字符串：\\n");\n' +
                '\tchar* s = (char*)malloc(sizeof(char) * 5 * 10 * 10 * 10 * 10);//分配大小题目规定\n' +
                '\tscanf_s("%s", s, strlen(s));//必须加上判读的变量\n' +
                '\tint a = lengthOfLongestSubstring(s);\n' +
                '\tprintf("不含有重复字符的 最长 子串的长度为%d",a);\n' +
                '\treturn 0;\n' +
                '}';

        }else if(algorithmNumber ===4){
            title = "";
            description = "";
            solutioncontent = "";
            code = '';
        }
        // 更新页面内容和代码高亮
        document.getElementById("algorithm-title").innerText = title;
        document.getElementById("algorithm-description").innerText = description;
        document.getElementById("code-block").innerHTML = `<code>${code}</code>`;
        Prism.highlightAll();
        document.getElementById("solution-content").innerText = solutioncontent;
        const textContainer = document.getElementById("solution-content");
        // 插入图片
        const img = document.createElement('img');
        img.src = src; // 图片的 URL
        img.alt = ''; // 图片的替代文本
        img.style.maxWidth = '100%'; // 设置图片的最大宽度为100%
        img.style.height = 'auto'; // 让图片的高度自适应
        textContainer.appendChild(img); // 添加图片到文本容器的末尾


    }
</script>
</body>
</html>
