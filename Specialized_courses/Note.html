<!DOCTYPE html>
<html lang="en">
<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"3IgcPbFXfKH6JIH0",ck:"3IgcPbFXfKH6JIH0",autoTrack:true,hashMode:true,screenRecord:true})</script>
<script src="../LA.js"></script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Notes</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/default.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .block {
            background-color: #fff;
            border: 1px solid #ddd;
            margin-bottom: 20px;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .block h2 {
            margin-top: 0;
            font-size: 20px;
            margin-bottom: 10px;
            color: #333;
        }
        .block p {
            margin-bottom: 10px;
        }
        .block pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #f9f9f9;
            padding: 10px;
            border: 1px solid #ddd;
            overflow-x: auto;
            border-radius: 5px;
            margin-top: 0;
        }
        .console {
            background-color: #000;
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            overflow-x: auto;
            font-family: Consolas, monospace;
        }
        .console pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            padding: 0;
            color: #fff;
        }
        .console pre code::before {
            content: "$ ";
            color: green;
        }
        .btn {
            padding: 10px 20px;
            background-color: #007bff;
            color: #fff;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            text-decoration: none;
            display: inline-block;
            margin-bottom: 10px;
        }
        .btn:hover {
            background-color: #0056b3;
        }
        .search-container {
            margin-bottom: 20px;
        }
        .search-box {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }
        h3{
            color: #00aa44;
        }
        h2{
            color: #20ecac;
        }
        p{
            color: red;
            font-size: 25px;
        }
    </style>
</head>
<body>
<header>
    <h1>数据结构笔记</h1>
    <div class="search-container">
        <input type="text" class="search-box" id="searchBox" placeholder="输入关键词进行搜索...">
    </div>
</header>
<div class="container">
    <!--   ------------------------------------------------------------------------------------------------------          -->
    <div class="audio-container">
        <audio controls ontimeupdate="showLyrics()">
            <source src="../music/n.mp3" type="audio/mpeg">
            孩子-西楼
        </audio>
    </div>
    <div class="block">

        <p>数据结构的三要素</p>
        <h2>逻辑结构</h2>
        <pre>
            <code class="c">
集合：元素之间没有特定关系
线性结构：一对一    栈
树形结构：一对多    树
图形结构：多对多    图
            </code>
        </pre>
        <h2>存储结构</h2>
        <pre>
顺序存储：数据元素按顺序存储在连续的存储空间中，例如数组，队列。
链式存储：数据元素通过指针链接，例如链表。
索引存储：为数据元素建立附加的索引表，例如数据库的索引。
散列存储：通过散列函数将数据映射到散列表，例如哈希表。
        </pre>
        <h2>数据的操作</h2>
        <pre>
数据的操作包括对数据的增、删、改、查等基本操作。这些操作基于数据的逻辑结构和存储结构实现。
        </pre>
        <h2>总结</h2>
        <pre>
这部分的内容来说，就题目判断一个东西是否为逻辑结构和存储结构
很大一部分不好判断，并且你写的莫名其妙的，答案也是莫名其妙的，总感觉无论选什么，答案总是能够圆谎一样
没办法，只能积累，目前<span style="color: red">栈 树 图</span>是地地道道的逻辑结构
中间有个万金油，就是<span style="color: red">链表</span> 它既可以是两种中的任意一种
剩下的几乎全是存储，反正你只要不在最后一场考试选错，其他的一切都是积累
        </pre>
    </div>
    <!--   ------------------------------------------------------------------------------------------------------          -->
    <div class="block">
        <p>算法和算法的度量</p>
        <h2>算法的基本概念</h2>
        <pre>
            <code class="c">
算法是对特定问题求解步骤的一种描述
五个特性：
1.有穷性
2.确定性
3.可行性
4.输入
5.输出
            </code>
        </pre>
        <h2>时间复杂度</h2>
        <pre>
            <code class="c">
n：问题规模
T(n)：时间开销
O(n)：时间复杂度
推导大O阶：
    1.用常数1取代运行时间中所有的加法常数
    2.在修改后的运行次数函数中只保留最高阶项
    3.将最高阶项系数变为1
必须牢记的：
⬯(1)<⬯(log₂n)<⬯(n)<⬯(nlog₂n)<⬯(n²)<⬯(n³)<⬯(2^n)<⬯(n!)<⬯(n^n)
常       对       线      线对      方      立    指      全排   牛牛
            </code>
        </pre>
        <h2>空间复杂度</h2>
        <pre>
            <code class="c">
空间复杂度只需要观察与n有关变量即可
递归调用空间复杂度就是递归的深度
有一些是每一层都少去一点是就是n²
也是大O表示法
空间复杂度其实算的就是除去你输入的，以及程序本身的内存以外
当你执行程序的时候，使用的变量会占有内存，这些内存就是空间复杂度的组成
            </code>
        </pre>
        <h2>总结</h2>
        <pre>
空间复杂度不会怎么考
时间复杂度考的多，这一类题目，纯粹就是数学题
这里给出两个用的巨多的公式（等比数列求和，等差数列求和）
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>等差：</mo><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>×</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>等比数列：</mo><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd></mtd><mtd><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mi>n</mi><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mo stretchy="false">(</mo><mi>q</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd></mtd><mtd><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>q</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>−</mo><mi>q</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>−</mo><msub><mi>a</mi><mi>n</mi></msub><mi>q</mi></mrow><mrow><mn>1</mn><mo>−</mo><mi>q</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>a</mi><mi>n</mi></msub><mi>q</mi><mo>−</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><mrow><mi>q</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>,</mo><mo stretchy="false">(</mo><mi>q</mi><mo>≠</mo><mn>1</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math>
        </pre>
        <pre>
例题一：n为正整数，程序的最坏情况下的时间复杂度
            <code class="c">
for (i = n - 1; i > 1; i--)
{
	for (j = 1; j < i; j++)
	{
		if (...)
			.....
	}
}
            </code>
答案：<span style="color: red">O(n²)</span>
解析：我之前由于学过一点数据结构，但是囫囵吞枣，我一看到这种双层循环，就意识到
循环次数，那不就是外层循环×内层循环嘛，于是我算

<span style="color: red">外层循环</span>：从n-1到1，但是不包括1,也就是执行了n-2次循环   为什么？不是哥们
说实话我有时候也坎坷 似乎这是凭感觉得出这个次数的好像
那我们代数看看，假如n-1=10，从10 到 1 你掰手指头看看有几次？
别忘了，一定是包括10的，这没问题吧？😨
但是是不包括1的，因为到1的时候循环是不执行的，也就是最后一次循环是2
10 9 8 7 6 5 4 3 2
1  2 3 4 5 6 7 8 9 次
那不就是比初始值少一次嘛，那外层循环是n-1-1=n-2就说得通了

再看<span style="color: red">内层循环</span>
当i=n-1的时候，j从1开始，直到j < i  也就是j < n-1
1到n-2 有几次？不知道？可去你的吧，n-2次啊😥
同理，当i=n-2的时候，执行 n-3次
i一直会到2，也就是内层最后一次是
j<2，j从1开始，也就是执行1次
好，我们捋一下
n-2
n-3
...
1
是不是等差数列？
所以我们算一下：
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>3</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mn>2</mn></mfrac></math>

好了，内外层我们都算完了，以我的想法就是将内层次数X外层次数
当然是错的，为什么？为什么？我当时最大的问号就是为什么？我明明接触过的训练就是相乘
其实我忽略了一个细节，那就是<span style="color: red">内层循环的次数不直接是n有关，是和外层有关</span>
这就导致，其实这两个for循环，其实就是一个整体，语句的次数其实就是整体执行的次数
不知道你能不能理解，反正我稍微有点感觉了
所以我们的整体循环次数就是内层循环的次数
也就是
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>3</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mn>2</mn></mfrac></math>
当然加上大O
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>O</mi><mo stretchy="false">(</mo><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>3</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></math>
别问我，怎么突然间只剩下n方了，回上面看大O阶的推导，你啊你😡😡😡😡
        </pre>
        <pre>
例题二：m++语句的执行次数
            <code class="c">
int m = 0, i, j;
for (i = 1; i <= n; i++)
{
	for (j = 1; j <= 2 * i; j++)
	{
		m++;
	}
}
            </code>
答案：<span style="color: red">n(n+1)</span>
分析：
外层：i从1到n，也就是n次
内层：
第一次：1到2，包括2，也就是2次
第二次：1到4，4次
第三次：6
8
10
12
...
第n次：2n
等差数列是吧？
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mi>n</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>n</mi></math>
结束了，又不是问时间复杂度，单纯问次数，如果是时间复杂度那就是O(n^2)
        </pre>
        <pre>
例题三：n为描述问题规模的非负整数，求时间复杂度
            <code class="c">
x = 2;
while (x < n / 2)
	x = 2 * x;
            </code>
答案：<span style="color: red">n(n+1)</span>
分析：这类问题怎么办？懵了？先别哭
有套路！
别高兴，骗你的
一般设循环次数为t，解出t=多少，不就ok了？
来，我们试一试
设次数为t
注意看循环停止的条件x < n/2
每次的迭代量为*2，而x是从2开始
也就是说2的某某次方为n/2的时候停止
是这意思吧？但是注意从2开也就是一开始就是2的1次方
所以
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mrow><mi>t</mi></mrow></msup><mo>=</mo><mi>n</mi></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow></mrow><msup><mn>2</mn><mrow><mi>t</mi></mrow></msup><mo>=</mo><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow></mrow><mi>n</mi></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>t</mi><mo>=</mo><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow></mrow><mi>n</mi></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>那么时间复杂度：</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow></mrow><mi>n</mi><mo stretchy="false">)</mo></math>
        </pre>
        <pre>
难点：递归函数的时间复杂度
            <code class="c">
int fact(int n)
{
	if (n <= 1)
		return 1;
	return n * fact(n - 1);
}
            </code>
答案：<span style="color: red">O(n)</span>
分析：
递归函数的时间复杂度可以说和前面不是一个量级的
理解上就很难迈过去
最好理解的一种方法就是公式递推法：
	if (n <= 1)
        return 1;   O(1)
	return n * fact(n - 1); O(1)
我们使用T(n)来表示时间的程度
我们观察，当n<=1的时候只会执行return 1，也就是程序的时间复杂度就是O(1)
当n>1的时候
T(n) = O(1)+T(n-1)   这个O(1)是return n * fact(n - 1);的复杂度，因为乘法只会执行一次
T(n-1)是指，进入下一个函数的时间的程度
那么总的时间程度就是
不断的累加
T(n) = O(1) + T(n-1)
T(n-1) = O(1) + T(n-2)
...
总的时间复杂度就是
(1) + T(n-1)第一次
2xO(1) + T (n-2)到第二个函数时
3xO(1) + T (n-3)到第三个函数时
...
有没有发现规律
yes
O(1)的系数，就是后面T(n-系数)
程序什么3时候停止？就是当T(1)的时候
我们要让T(n-1)、T(n-2)、、、、变为T(1)
那不就是T(n-(n-1))      n-1就是系数
于是
(n-1)O(1) + T(n-(n-1))
(n-1)O(1) + T(1)
就是
O(n-1)
O(n)
于是答案就出来了
这个方法，对于简单的递归来说还行，但是复杂的递归需要很大的毅力，分析能力
但是总之，这个方法稍微掌握一下还是挺不错的
        </pre>
    </div>
    <!--   ------------------------------------------------------------------------------------------------------          -->
    <div class="block">
        <p>线性表</p>
        <h2>线性表基本概念</h2>
        <pre>
线性表是具有<span style="color: red">相同</span>数据类型的n个数据元素的<span style="color: red">有限序列</span>，n=0时为空表

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>线性表</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd></mtd><mtd><mo>顺序存储</mo><mo>—</mo><mo>—</mo><mo>顺序表</mo></mtd></mtr><mtr><mtd></mtd><mtd><mo>链式存储</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mo>单链表</mo></mtd></mtr><mtr><mtd><mo>双链表</mo></mtd></mtr><mtr><mtd><mo>循环链表</mo></mtd></mtr><mtr><mtd><mo>静态链表</mo><mo stretchy="false">(</mo><mo>数组实现</mo><mo stretchy="false">)</mo></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></math>
不要急好哥们，有时候就是大道至简，这个图我放这不是用来凑字数的
线性表是一种假想的东西，它是一个逻辑上的东西
而线性表的实现也就是分为两种顺序和链式，这是两个存储结构
别一眼带过，这是很重要的构思。
顺序存储对应的就是顺序表，所以顺序表是一种存储结构
链式存储对应的单链表，双链表，循环链表，静态链表都是一种存储结构
        </pre>
        <h2>顺序表</h2>
        <pre>
用顺序存储的方式实现线性表
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>顺序表</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mo>静态分配（数组）</mo></mtd></mtr><mtr><mtd><mo>动态分配（指针分配内存）</mo></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></math>
这里我讲解一下，动态分配，你是不是又没有思考？
一定要有敏锐的察觉，动态分配，分为两种，就是，每存入一个数就分配一个数的地址将前面和后面链接起来
这似乎是链表的思想
那顺序表的动态是指在程序执行的时候才知道数组要存多少个
这个时候我们动态分配一个数组
存入，当过了一段时间，哦豁，又来新活了，怎么办？
再分配一个新数组，注意是整体，是一个比原来大的数组，足以容纳新的数
然后怎么办？整体搬迁，类似扶贫，整个危房村的人，统一搬迁到政府新建的集体房子
<span style="color: red">顺序表的增删平均</span>
1. 新增元素： O(N) （尾插是O(1),不考虑扩容的情况）
2. 查找元素： O(N)
3. 根据下标获取/修改元素：O(1)
4. 删除元素：O(N)
5. 清除所有元素：O(1)
<span style="color: red">存取方式</span>
读写的方式，顺序表是支持随机存取的存储结构，也就是可以访问任意一个元素
        </pre>
        <h2></h2>
        <h2>单链表</h2>
<pre>
讲单链表之前我们先来说两个东西<span style="color: red">头指针</span>和<span style="color: red">头结点</span>
头指针是指向链表第一个节点的指针
头结点是放在第一个元素之前的一个特殊结点，不存储任何数据
是的，当头结点存在，头指针就是指向头结点的
很好
接下来我们看看怎么建立链表，我们初步建立了一个思想，就是每当需要增加一个元素，采用分配的方法，指针指向的链接形成一个不连续内存的存储结构
单链表有两种实现方法
<span style="color: red">1.头插法</span>
听着很熟悉吧，我们来看，如果这个链表带有头结点，那么每次新增的元素
放到头节点之后，也就是说，每次新增的元素的下一指向先被赋为头结点的下一指向
然后再将头结点的下一指向赋为这个元素
L->next=NULL;
p->next=L->next;
L->next=p;
那没有头结点的呢？
L=NULL;
p->next=L;
L=p;
咦，啊啊啊啊啊脑子要爆炸啦
这里讲一个很混乱的东西，头结点和没有头结点怎么都是L啊
头结点在哪呢？
其实头结点就是实例化的一个头指针，我这么说可能有点歧义
我们看下面两段代码
    <code>
Lnode *head,*p;
head=(Lnode*)malloc(sizeof(Lnode));
head->next=NULL;
--------------------------------------------
Lnode *head,*p;
head=NULL;
    </code>
第一段代码，我们看到head是头指针，头指针被分配了指向
    这不是给head分配空间，是让head指向了一个地方，分配空间Lnode *head这句已经自动分配了
    好，头指针现在已经指向了一个地方，head->next是说头指针指向的这个地方的指针域指向下一个的地方赋为空
    |头指针|->|头结点|->|NULL|
第二段代码，我们看到head头指针直接被定义以后赋为NULL说明没有任何指向，也就是没有头指针。
-------------------------
然后我们讲讲头插法
    <code>
        带头结点
p=(Lnode*)malloc(sizeof(Lnode));
p->data=i;
p->next=head->next;
head->next=p;
-----------------------------------------------
        不带头结点
p=(Lnode*)malloc(sizeof(Lnode));
p->data=i;
p->next=head;
head=p;
    </code>
我们看<span style="color: green">第一段代码</span>，p是要新增的一个节点，p=(Lnode*)malloc(sizeof(Lnode));分配空间
p->data=i;给数据域赋值
p->next=head->next;这是带头结点的，所以head指向的地方是头结点而head->next是头结点指向的下一节点
这句话就是将头结点指向的下一节点赋为新节点的下一节点
head->next=p;将头指针指向的头结点的指针域指向p
总体一套连招下来，打的你是晕头转向啊
    没事我会魔法，看🪄
    |head|->|头结点|->|NULL|
    |p|->|NULL|
    |head|->|头结点|->|p|->|NULL|
    这样看不够清晰我们现在要是再增加一个节点M
    |head|->|头结点|->|p|->|NULL|
    |M|->|P|
    |head|->|头结点|->|M|->|P|->|NULL|
我们看<span style="color: green">第二段代码</span>
    p->next=head;直接将p的下一个赋值为head指向的NULL
    head=p;再将head头指针指向新增的p
    慢慢体会吧
<span style="color: red">2.尾插法</span>
    尾插法就是每此新增的元素是增加到结尾
    所以我们要增加一个尾指针，辅助我们在末尾增加新元素
    头指针是不动的，尾指针每次结束是指向最后一个元素，再将最后一个元素的指针域赋为NULL
    <code>
    LinkList TailInster(LinkList &L,int n){
	int x=1;
	L= (LinkList)malloc(sizeof(LNode));
	LNode *s,*r=L;
	while(x!=n){
   		s=(LNode*) malloc(sizeof(LNode));
   		s->data=x;
  	 	r->next=s;
   		r=s;
   		x++;
	}
	r->next=NULL;
	return L;
}
    </code>
因为有了尾指针，所以头插法和尾插法创建单链表的时间复杂度一样都是O(n)
</pre>
<h2>单链表的时间复杂度总结</h2>
        <pre>
头插法-尾插法:都是O(n)
按值按序查:O(n)
增:O(n)，给定节点:O(1)
删:O(n)
求表长:O(n)
时间主要花在查找上
        </pre>
<h2>双链表</h2>
        <pre>
双链表有前驱和后继，两个指针域，单链表只有一个指针域，只能指向后继节点
双链表的增删时间复杂度都是O(1)
        </pre>
<h2>循环单链表</h2>
        <pre>
比起单链表来讲，循环单链表最后一个元素节点的指针域，也就是指向下一个的指针，指向的不是NULL
而是改为指向头结点，如果没有头结点就是头一个元素也就是头指针
这里我要提个醒，链表不是数组，循环单链表的最后一个元素指向的是链表第一个元素
是完整的，不存在任何一个节点的指针域是NULL，所以判断循环单链表的条件不是判空
是判断头结点是不是等于头指针，这样一样来就是说没有元素存在，因为
|head|->|头结点|->|head|
我们也知道，单链表是存在头指针和尾指针
循环链表的话，可以只存在其中一个
如果只存在头指针，那么尾插法需要O(n)
如果只存在尾指针,那么尾插，头插都是O(1)
头指针因为要遍历到最后一个
而尾指针尾插O(1)不需要解释
头插为什么也是？因为头指针可以通过尾指针+1得到
因为是循环链表嘛
        </pre>
<h2>循环双链表</h2>
        <pre>
循环双链表就不多说了，一样的思想，头结点两个指针域的指前指针是要指向链表末尾的节点
判断的话，头结点是两个指针域都等于头指针
        </pre>
<h2>静态链表</h2>
        <pre>
静态链表采用数组的方式
不同于其他，这是个结构体数组，就是说数组的每一个元素都是结构体
结构体包含一个数据和一个整形表示位置
这个整形的数字表示的就是这个元素的下一个元素指向的位置是数组中的第几个元素
给代码自己看
<code>
 typedef struct
    {
        ElemType data;
        int next;
    }SLinkList[MaxSize];
</code>
        </pre>
    </div>
    <div class="block">
        <p>栈、队列和数组</p>
        <h2>栈</h2>
        <pre>
栈是一种线性表，只不过它的操作受到限制
只能是一端进行增加和删除
既然是线性表那么就有两种存储方式，也就是顺序栈和链栈
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>卡特兰数：</mo><mi>n</mi><mo>个不同元素入栈，出栈元素不同排列的个数为</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi></mrow></msubsup></math>
</pre>
<h2>顺序栈</h2>
        <pre>
顺序栈的实现
<code>
typedef struct{
    ElemType data[MaxSize];
    int top;
}SqStack;
</code>
栈空条件top=-1
栈的实现其实就是一个数组以及记录栈顶(数组下标)的东西
            你不能纯粹把数组形象化为一个栈，因为栈顶不是数组的开头而是指针向后移动
            也就是说，下标越大的就是栈顶
            |1|-|2|-|3|-|4|-|5|-|6|-|7|-|空|
            7是栈顶，top指向的就是这个，top的值是6，因为数组是从0开始计数
        </pre>
<h2>共享栈</h2>
        <pre>
就是一个数组被两个栈共同占用，挺那啥的是吧，但是节省空间啊
只会发生上溢
我们来考虑一下，共享栈，也就是农村包围城市，两头包围
|1|-|2|-|3|-|空|-|空|-|空|-|空|-|空|-|2|-|1|
看到没有前一个栈是存了三个，栈顶元素是3，top是2是递加的
后面一个栈是存了二个，栈顶元素是2，top是n-2=8是递减的
溢满的情况是怎么样的？
 |1|-|2|-|3|-|4|-|5|-|5|-|4|-|3|-|2|-|1|
A->                                   <-B
现在已经存满了
如果A或者B此时再执行存入一个数，那么势必是造成A或B的一个数被覆盖
造成数据混乱，叫上溢
很多人不理解，为什么叫上溢不叫下溢？
这里的<span style="color: red">上溢</span>是指
栈的增长方向通常被视为“向上”增长。因此，当栈满时，进一步的增长操作导致数据“溢出”预设的界限，这就是“上溢”。
如果栈已经没有元素了，即栈顶指针已经指向栈底或更下的位置，继续执行弹出操作就会导致<span style="color: red">下溢</span>错误。
        </pre>
<h2>链栈</h2>
        <pre>
链栈的实现
<code>
typedef struct LinkNode{
    ElemType data;
    int top;
}*LiStack;
</code>
栈空条件top=MaxSize
        </pre>
<h2>队列</h2>
        <pre>
队列简称队，与栈一样是一种受到限制的线性表，只不过只能在一端插入，一端删除。
队列的顺序存储，很简单与线性表顺序村粗无异，我们给定两个指针
            <code>
 #define MaxSize 50;
 typedef struct{
     ElemType data[MaxSize];
     int front,rear;
 }SqQueue;
            </code>
front 是指向对头，rear是指向队尾。
一开始front和rear都是指向第一个元素，也就是空队
当不断增加元素以后，rear不断后移。
当是当我们有元素出队列的时候，front要后移
这个时候问题就是出来了，就是说数组的前几个是空的
而rear回不到前面，也就是说，一个冰箱上下都装满了物品
当上面的物品被清空的时候，你还要放物品，你只知道去下面放
下面是满的，你就说你要重新买个冰箱，因为现有的冰箱不能放了
这是不实在的
        </pre>
<h2>顺序循环队列</h2>
        <pre>
所以我们就有<span style="color: red" >循环队列</span>
<span style="color: red" >初始</span>：Q.front = Q.rear =0;
<span style="color: red" >队首指针进1</span>:Q.front = (Q.front + 1) % MaxSize;
<span style="color: red" >队尾指针进1</span>:Q.rear = (Q.rear + 1) % MaxSize;
<span style="color: red" >队列长度</span>:(Q.rear - Q.front + MaxSize) % MaxSize;
<span style="color: red" >队满条件</span>:(Q.rear +1) % MaxSize ==Q.front;//这里是约定空出一个不存储，也就是队尾+1就是队头的时候就是满,<span style="color: red">注意队尾指向的不是最后一个元素而是最后一个元素的下一个空位置</span>
<span style="color: red" >队空条件</span>:Q.front == Q.rear;
当然了，你也可以这样想，我们额外定义一个Size来记录列表存储个数，当Size=0并且头尾指针相等就是空
如果Size=MixSize并且头尾指针相等就是队满
同样，你也可以这样，出队的时候才会导致队空
入队才会导致队满，定义一个参数tag，=0是删除操作，此时头尾相等是队空，=1是增加，头尾相等是队满
MaxSize是指存储的个数，不是下标，其次A[21]，MaxSize是21，A[0...n]，MaxSize是n+1,因为有n+1个元素
双端队列:允许两端都可以进行入队和出队操作的队列
输入受限的双端队列:允许一端进行输入和删除，另一端只能删除
输出受限的双端队列:允许一端进行输入和删除，另一端只能输入
双端列表是数组形式的，也就是说先全部进入，再依次输出。
即便是双端可进可出，那也是队列，是队列你就给我先进先出
也就是全部进入以后再谈输出
        </pre>
<h2>队列的链式存储</h2>
        <pre>
链队列,尾指针是指向最后一个元素，这一点和顺序存储不同
            <code>
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct{
    LinkNode *front ,*rear;
}*LinkQueue;
            </code>
当Q.front==NULL并且Q.rear==NULL表示队列为空;//认真记住链表和数组的不同的判断方法，不然你会栽跟头的
        </pre>
<h2>栈和队列的应用</h2>
        <pre>
<span style="font-size: 50px" id="9"><span style="color: red">后缀表达式</span>的<span style="color: #00aa00">求值与转换</span>(栈)</span>
    <span style="color: #00daff">四则运算表达式转化为后缀表达式的规则：</span>
    <span style="color: #e600ff">
        1.数字直接写
        2.运算符号如果级别高于栈顶的，直接入栈写上，如果等于或者低于栈顶的让栈顶先出，自己再进去
        3.左括号不管入，遇到右括号，将左括号上面的所有出栈
    </span>
    我们来举个例子：9+（3-1）×3+10
    数字直接写：<span style="color: red">9</span>
    然后就是+号，符号入栈
	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    然后就是（入
    	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >(</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是3，直接写
    <span style="color: red">93</span>
    然后就是-入
     	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >(</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >-</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是1，数字直接写
    <span style="color: red"> 931</span>
    然后就是）右括号，你瞧，直接打包出来，其实也没有就一个-号，收获不大啊，竹篮打水一场空
    <span style="color: red"> 931-</span>
       	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    然后就是x，和此时的栈顶+比较，谁牛逼，显然x牛点，所以入栈
           	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >x</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是3，数字直接写
    <span style="color: red">931-3</span>
    然后就是+，比较栈顶的x，哦豁，没有它厉害，乖乖让x出来
    就是
    <span style="color: red">931-3x</span>
    此时栈：
          	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    还没有完，还要继续比较现在的栈顶，是+和即将入的+是相等的，让栈顶出来
    <span style="color: red">931-3x+</span>
           	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        </g>
    </svg>
    这个时候，我们的+再入栈
      <span style="color: red">931-3x+</span>
           	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
                 <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是10，数字直接写
    <span style="color: red">931-3x+10</span>
    然后没了，栈里面的给我滚出来吧
    <span style="color: red">931-3x+10+</span>
    <hr>
    以上就是中转后缀表达式，下面讲讲如何模拟计算机一样，直接计算后缀表达式
    <span style="color: #e600ff">
    1.当是数字的时候直接入栈

    2.当是运算符号的时候

    3.就将栈的最上面两个数拿出进行运算 后 再将结果进栈 记住（栈顶元素永远在运算符号的右边）
    </span>
    看9 3 1 - 3 * + 10 2 / +
    9 3 1依次入栈，没有异议

    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >3</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >1</text>
        </g>
    </svg>
    接下来是-，取出栈顶的两个元素，分别是1 3，1是栈顶，放-号的右边
    就是3-1=2
    将2入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >2</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是 3 入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >2</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >3</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是*，取出来运算
    2*3=6，即便是*这种不在意次序的，你也务必养成习惯将栈顶放右边
    6入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >6</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是+，取出运算
    9+6=15，15入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是10，数字入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >10</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是
    2入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >10</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >2</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是/，取出两个运算
    10/2=5入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >5</text>
        </g>
    </svg>
9 3 1 - 3 * + 10 2 / +接下来是+，取出来运算
15 + 5 = 20
好了，这就是最后结果了，不信你自己算嘛，给你9+（3-1）x 3+10/2
<span style="font-size: 50px">栈在递归中的应用</span>
对同一个问题递归比非递归好看，但是非递归的效率比递归高
<span style="font-size: 50px">队列在层次遍历中应用</span>
信息的逐层处理
<span style="font-size: 50px">队列在计算机系统中的应用</span>
第一方面解决主机与外部设备之间速度不匹配的问题
第二方面解决由多个用户引起的资源竞争问题
<span style="font-size: 50px">数组和特殊矩阵</span>
两种映射方法：行优先/列优先，行优先：先行后列，存储在一维数组中
<span style="color:red;">压缩存储</span>多个相同的值只分配一个存储空间，节省空间
<span style="color: red">特殊矩阵</span>线性代数中的对称，上/下三角，对角阵，稀疏矩阵
        </pre>
        </div>
    <div class="block">
<h1>串</h1>
        <pre>
串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串
长度为0的才是空串，空格是空格串不是空串
串中字符位置是从1开始数
串也算一种特殊的线性表
        </pre>
<h2>串的顺序存储</h2>
        <pre>
没什么好说的，就是用数组来存
        </pre>
<h2>串的链式存储</h2>
        <pre>
也没什么好说的，块链存储的意思就是，每一个节点呐不单单是存一个字符，而是一串字符，如果存不满，用#填充
        </pre>
<h2>串的模式匹配</h2>
        <pre>
子串的定位操作就是串的模式匹配
Next数组求解
            <code type="c">
首先我们需要知道KMP是干嘛的，通俗易懂的来讲是查找相同字符串的一种捷径
我们人的本能的趋简避繁，例如aababcbdaabacbbbd这样的字符串，我们需要在其中找到子串aabacb我们怎么操作？
为什么会将子串第一个字符依次对比字符串的每一个字符来判断：
=----------1---------=
aababcbdaabacbbbd
aabacb
=----------2---------=
aababcbdaabacbbbd
 aabacb
=----------3---------=
aababcbdaabacbbbd
  aabacb
=----------4---------=
aababcbdaabacbbbd
   abacb
=----------5---------=
aababcbdaabacbbbd
    abacb
=----------6---------=
aababcbdaabacbbbd
     abacb
=----------7---------=
aababcbdaabacbbbd
      abacb
=----------8---------=
aababcbdaabacbbbd
       abacb
=----------9---------=
aababcbdaabacbbbd
        abacb
=----------10---------=
aababcbdaabacbbbd
         abacb
=----------end完结撒花---------=
怎么样是不是很麻烦吧？//麻烦个嘚，我就喜欢
不是，既然计算机大拿说了麻烦咱就认行吗？
于是开头字母分别为KMP的三个人设计了一个算法叫KMP算法（具体思路自己百度，以下只解释最重要也是最难理解的Next数组该怎么求）
Next数组说白了就是求子串中每一个最长相等前后缀（听不懂没关系，往下看）
这里声明一个规则：
前缀：不包含未元素的串
后缀：不包含首元素的串
我们来举个例子这是子串|a|a|b|a|a|f|
（1）|a|
前缀以及后缀都为0  导致最长相等前后缀为0
（2）|a|a|
前缀为|a|
后缀为|a|相等
最长相等前后缀为1
（3）|a|a|b|
前缀为|a|a|
后缀为|a|b|不相等
在这有两个元素的前后缀的基础上再下一次比较
前缀|a|
后缀|b|依然不相等//注意这里的|a|和|b|不是后缀中的|a|b|拆分的，是前缀|a|a|的第一个|a|以及后缀|a|b|最后的那个|b|
最长相等前后缀为0
（4）|a|a|b|a|
前缀为|a|a|b|
后缀为|a|b|a|当然不相等
在这有三个元素的两个前后缀的基础上再下一次比较
前缀|a|a|
后缀|b|a|依然不相等
同理再比较
前缀|a|
后缀|a|相等
所以最长相等前后缀为1
（5）|a|a|b|a|a|
前缀|a|a|b|a|
后缀|a|b|a|a|不等
再前缀|a|a|b|
后缀|b|a|a|不等
再|a|a|
后缀|a|a|相等长度为2
最长相等前后缀为2
（6）|a|a|b|a|a|f|
前缀|a|a|b|a|a|
后缀|a|b|a|a|f|不等
前缀|a|a|b|a|
后缀|b|a|a|f|不等
前缀|a|a|b|
后缀|a|a|f|不等
前缀|a|a|
后缀|a|f|不等
前缀|a|
后缀|f|不等
所以最长相等前后缀为0
所以前缀表的值就是，这6个算出来的数值
即|0|1|0|1|2|0|
<span style="color: red">重点</span>这还不是Next数组
我们需要将-1发放到最前面，然后去掉最后一个数，整体右移
|-1|0|1|0|1|2|
以上为理论部分（聪明的人会看到这里的）

以下是代码实现部分（C++）
#include < stdio.h >
#include < iostream >//c++的头文件
#include< string >
using namespace std;//c++的命名空间，如果没有这句话，很多地方会这样写std::cout等等
class solution {//定义类，c++语法
public://公共方法（好像java才说方法）以及属性
    void getnext(int* next, const string& s) {//传入next数组以及字串
        int j = 0;//j初始化为0
        next[0] = 0;//首元素设置为0
        for (int i = 1; i < s.size(); i++) {//我们假设i指向后缀的末尾，j指向前缀的末尾
            while (j > 0 && s[i] != s[j]) {//while是用来处理前后缀不相同的情况
                j = next[j - 1];//这句代码的意思是回退，回退到前一个数组元素的值为数组下标处
            }
            if (s[i] == s[j]) {//if用来处理前后缀相同的情况
                j++;//如果想相同，则会将j++，让j来表示最长相等前后缀的情况
            }
            next[i] = j;//让此处的最长相等前后缀为j的值
        }
    }
};
int main()
{
    int next[8];
    string s = "abcabcab";
    solution*a = new solution();
    a->getnext(next,s);
    for(int i=0;i<8;i++)
    printf("%d",next[i]);
}
        //放心，代码你十有八九看不懂，不过没关系，毕竟你要是自己研究出来了
        //你就是KMP的发明者了，今天看几遍，过几天再来，慢慢的就理解了
            </code>
<span style="color: red">我就知道你肯定不会认真的看，所以我必须拿出点手段来</span>
<span style="font-size: 20px" >Next数组求解</span>
前缀：不包含未元素的串
后缀：不包含首元素的串
我们来举个例子这是子串|a|a|b|a|a|f|
（1）|a|
前缀以及后缀都为0  导致最长相等前后缀为0
（2）|a|a|
前缀为|a|
后缀为|a|相等
最长相等前后缀为1
（3）|a|a|b|
前缀为|a|a|
后缀为|a|b|不相等
在这有两个元素的前后缀的基础上再下一次比较
前缀|a|
后缀|b|依然不相等//注意这里的|a|和|b|不是后缀中的|a|b|拆分的，是前缀|a|a|的第一个|a|以及后缀|a|b|最后的那个|b|
最长相等前后缀为0
（4）|a|a|b|a|
前缀为|a|a|b|
后缀为|a|b|a|当然不相等
在这有三个元素的两个前后缀的基础上再下一次比较
前缀|a|a|
后缀|b|a|依然不相等
同理再比较
前缀|a|
后缀|a|相等
所以最长相等前后缀为1
（5）|a|a|b|a|a|
前缀|a|a|b|a|
后缀|a|b|a|a|不等
再前缀|a|a|b|
后缀|b|a|a|不等
再|a|a|
后缀|a|a|相等长度为2
最长相等前后缀为2
（6）|a|a|b|a|a|f|
前缀|a|a|b|a|a|
后缀|a|b|a|a|f|不等
前缀|a|a|b|a|
后缀|b|a|a|f|不等
前缀|a|a|b|
后缀|a|a|f|不等
前缀|a|a|
后缀|a|f|不等
前缀|a|
后缀|f|不等
所以最长相等前后缀为0
所以前缀表的值就是，这6个算出来的数值
即|0|1|0|1|2|0|
<span style="color: red">重点</span>这还不是Next数组
我们需要将-1发放到最前面，然后去掉最后一个数，整体右移
|-1|0|1|0|1|2|
上面这个是下标<span style="font-size: 20px;color: red">从0开始</span>的Next数组，如果是从1开始的就是整体+1
|0|1|2|1|2|3|
什么是从0从1开始？我真的要敲爆你的脑子🧠
abcde中c是第三个就是从1开始
abcde中c是第二个就是从0开始
好啦，Next数组求法已经完结，但是有些人真的太聪明了，搞出了一个NextVal数组(我真他妈的🤬)
也简单看下面
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|2|1|2|3|
因为下标从1开始，所以我们写的Next就是整体+1了
我们的NextVal数组第一个统一是0
<span style="color: green">|0|_|_|_|_|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|<span style="color: red">1</span>|2|1|2|3|
这个Next是1，对应的下标1所对应的字符是第一个a和此时的字符是一样的，其次第一个字符a对应的Next是0
一样的字符的话就引用前面的Next值就是0
<span style="color: green">|0|0|_|_|_|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|<span style="color: red">2</span>|1|2|3|
2对应的是a，与b不同，我们直接把b的下标拿下来
<span style="color: green">|0|0|2|_|_|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|2|<span style="color: red">1</span>|2|3|
1对应的是a，与a相同，使用第一个next
<span style="color: green">|0|0|2|0|_|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|2|1|<span style="color: red">2</span>|3|
2对应的是a，与a相同，使用第一个next
<span style="color: green">|0|0|2|0|0|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|2|1|2|<span style="color: red">3</span>|
3对应的是b，与f不同，则使用自己的
<span style="color: green">|0|0|2|0|0|3|</span>
给你一个例题：串“ababaaababaa”的next数组和nextval数组分别是什么？
答案：
-1,0,0,1,2,3,1,1,2,3,4,5
0,1,0,1,0,4,2,1,0,1,0,4
<span style="color: green">设有字符串S='aabaabaabaac',P='aabaac'</span>
<span style="color: green">1.求出P的next数组。
2.若S作主串，P作模式串，给出KMP算法的匹配过程。</span>
            <span style="color: #4603f5">
            第一个答案好说|0|1|2|1|2|3|
            第二个
            第一趟匹配
            S；|a|a|b|a|a|b|a|a|b|a|a|c|
            P：|a|a|b|a|a|c|
            在S[6]与P[6]的时候失效
            注意到失效的P串的第六个字符的next数值是3，也就是下次比较的时候，直接跳到P串的第3个字符开始比较
            P的第三个对应S的第六个
            也就是第二趟
            S；|a|a|b|a|a|<span style="color: red">b</span>|a|a|b|a|a|c|
            P：      |a|a|<span style="color: red">b</span>|a|a|c|
            失效的时候就是S[9]，P[6]，P的第六个对应的next是3
            也就是下一次从S[9],P[3]开始
            也就是第三趟
            S；|a|a|b|a|a|b|a|a|<span style="color: red">b</span>|a|a|c|
            P：            |a|a|<span style="color: red">b</span>|a|a|c|
            匹配成功。
                </span>
一个主串长度是n，子串长度是m,简单的匹配算法时间复杂度是O(nm),KMP是O(n+m)
        </pre>
    </div>
    <div class="block">
<p>树和二叉树</p>
<h2>树的基本概念</h2>
        <pre>
            <canvas id="myCanvas14" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas14');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' },
        { x: 500, y: 50, label:'第一层' },
        { x: 500, y: 100,label:'第二层' },
        { x: 500, y: 175, label:'第三层' },
        { x: 500, y: 250,label:'第四层' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
祖先:比它高的唯一路径上的都是
子孙：比它低的唯一路径上的都是
双亲：它的前驱节点
孩子：它的后继节点
兄弟：有共同的双亲
堂兄弟：双亲不同，但是双亲有共同的双亲
------------------------------
结点的度
树的度
分支结点
叶子结点
树的高度：从下往上，就是最大层数
树的深度：从上往下，也是最大层数
路径：从A到B经过了《哪些》结点
路径长度：从A到B经过了《几》条边
<span style="color: red">树的路径长度：根结点到各个结点的路径长度总和</span>
森林：互不相交的树
m叉数：所有结点的度小于等于m
------------------------------
<span style="color: red">树的性质</span>
结点数=所有结点度数+1
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>度为</mo><mi>m</mi><mo>的树中第</mo><mi>i</mi><mo>层至多有</mo><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>个结点</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>高度为</mo><mi>h</mi><mo>的</mo><mi>m</mi><mo>叉树至多有</mo><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>个结点</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>具有</mo><mi>n</mi><mo>个结点的</mo><mi>m</mi><mo>叉树的最小高度</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>高度为</mo><mi>h</mi><mo>，度为</mo><mi>m</mi><mo>的树至少有</mo><mi>h</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>个结点</mo></math>
            <span style="color: green">
我来解释一下，
第一个你随便画一个二叉树满的，是不是2的比层数低一次方的数
第二个它说了至多，也就是每个结点的度是m，每次都是上一次的m倍，也就是等比求和公式
<span style="color: red">第三个</span>因为至少，所以我们把每一个结点满填m，因为是m叉树嘛，然后我们设高度为h
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>n</mi><mo>=</mo><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>m</mi><mi>h</mi></msup><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>h</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></math>
            </span>
这些公式包你恶心的哥哥姐姐，并且你就算记住了也做不了题
you know what
这些公式其实是自己做题做到很多以后，自己靠着不主动的记忆，记忆主动去回忆一丝丝的的东西
然后发现记忆好像就只有零星一点，就算了，然后自己分析题目，自己推，长此以往，竟然觉得所有题好像就这么回事
公式反正不顶用，我记个屁，还不如现场推，反正题目也不会套公式
        </pre>
<h2>二叉树</h2>
        <pre>
二叉树，刚学就忘了？之前说的m叉树，当m=2的时候不就是二叉树
二叉树是指所有结点的度小于等于2
二叉树的左右子树是有序的
几个特殊的二叉树
<span style="color: red">满二叉树</span>除了叶子结点每一个结点度都是2
<span style="color: red">完全二叉树</span>与满二叉树是编号必须一一对应
<span style="color: red">二叉排序树</span>左子树上所有结点的关键字都小于<span style="color: red">其</span>根，右子树的所有结点关键字都大于其根
<span style="color: red">平衡二叉树</span>左子树和右子树的深度之差不超过一
想让我画图给你看是吧，不给🤣🤣🤣🤣
            ------------------------------------------
<span style="color: red">二叉树的性质</span>
1.非空二叉树的叶节点数量是度为2的结点数+1
            <span style="color: green">因为你看结点总数=度为1+度为2+度为0，换另一种思路总数=度为1×1+度为2×2+1(根),所以等式结合就是度为0的数=度为2的数+1</span>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>2.</mn><mo>非空二叉树第</mo><mi>k</mi><mo>层上至多有</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>个结点</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>3.</mn><mo>高度为</mo><mi>h</mi><mo>的二叉树至多有</mo><msup><mn>2</mn><mrow><mi>h</mi></mrow></msup><mo>−</mo><mn>1</mn><mo>个结点</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>4.</mn><mo>对于完全二叉树：结点</mo><mi>i</mi><mo>的双亲编号是</mo><mo stretchy="false">[</mo><mfrac><mi>i</mi><mn>2</mn></mfrac><mo stretchy="false">]</mo><mo>（向下取整），结点</mo><mi>i</mi><mo>所在层次是</mo><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mn>2</mn></mrow></msub><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>5.</mn><mo>具有</mo><mi>n</mi><mo>个结点的完全二叉树的高度为</mo><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>或</mo><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mn>2</mn></mrow></msub><mi>n</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></math>
不知道你怎么想，反正我快红温了😁😀🙂🤨😐😑😶😥😫🤑😩😰😱🥵😡🤬🐒
还是那句话，我不想背，数学已经让我头疼了
什么？我不想背的，有的是人背，我做不到的总是有人做得到？
我去不了的学校他们就替我去了？
我可去你的吧
        </pre>
<h2>二叉树的存储结构</h2>
        <pre>
<span style="color: red">1.顺序存储</span>
只适合存储完全二叉树和满二叉树
用人话就是数组，下标就是数的关键字，什么叫关键字？
我日，看上面我摆出的那个树的图像，每一个圆圈就是结点，圆圈里面的A，B这些就是关键字
你问，ABC....怎么用下标对应？
你啊你，别那么死板啊，把ABC...换成123...不就行了。🫢
<span style="color: red">2.链式存储</span>
左右指针域以及数据域
我知道，你肯定会问双亲怎么找？
从头开始，如果频繁的找的话，你就多设置一个双亲指针域嘛，有什么大不了的
<span style="color: #00c6e7">在含有n个结点的二叉链表中，含有n+1个空链域</span>
是不是很无厘头，我老是这样摆出一个公式，然后解释，但是唯独没有解释为什么要学习这个公式
考试要考？只能说虚伪
没办法，想要站在巨人的肩膀上，只能这样
解释一下，n个结点空链域，也就是说,想想看，一个结点如果是叶子结点是不是它就有两个空链域
如果一个结点只有左右其中一个结点是不是就有一个空链域
然后，空链域是不是=总链域-使用的链域
总链域就是结点×2
使用的链域是不是就是n,是你个大头鬼，根结点是被谁使用的链域形成的，你说说看？
所以使用的链域就是n-1
所以空链域=2n-(n-1)=n+1
        </pre>
<h2>二叉树的遍历和线索二叉树</h2>
        <pre>
树学了这么久，你就没有想过，代码是如何实现，在每一个结点之间横跳的吗？
             <canvas id="myCanvas15" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas15');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
如同以上这棵树，我们如果以先序遍历来遍历这棵树该怎么办？
以我们的理论来说，先序就是根左右，也就是ABEFGDHIC
没问题吧，这都是很简单的(不明白的去看《数据结构部分》)
好，二叉树的实现是利用链表，也就是它有两个指针域
指向左孩子和右孩子，我们从A开始
A可以找到B和C，我们怎样实现先把B以及B的子孙都访问完再访问C？
没错，递归
看下面代码
            <code>
void preOrder(BiTree T)
{
    if(T!=NULL)
        {
            visit(T);
            PreOrder(T->lchild);
            PreOrder(T->rchild);
        }
}
            </code>
中序和后序怎么办？就是Visit放的位置不一样罢了
<code>中
void preOrder(BiTree T)
{
    if(T!=NULL)
        {
            PreOrder(T->lchild);
            visit(T);
            PreOrder(T->rchild);
        }
}
            </code>
<code>后
void preOrder(BiTree T)
{
    if(T!=NULL)
        {
            PreOrder(T->lchild);
            PreOrder(T->rchild);
            visit(T);
        }
}
            </code>
<span style="color: red">三种算法的时间、空间复杂度都是O(n)</span>
<span style="color: red;font-size: 20px">层序遍历</span>
要实现层序遍历，我们要借助一个队列
具体实现如图
<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
        </g>
    </svg>
<canvas id="myCanvas16" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas16');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
这是我们的树，我们要层序遍历就是ABCEDFGHI
我们先让根结点进栈A
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
        <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="55" y="75" font-size="12" text-anchor="middle">A</text>
        </g>
    </svg>
如果此时的A结点有左孩子就入队，再如果有右孩子再把右孩子入队也就是BC依次入
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="55" y="75" font-size="12" text-anchor="middle">A</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">B</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">C</text>
        </g>
    </svg>
这个时候A的左右都入了，于是把A出栈
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">B</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">C</text>
        </g>
    </svg>
轮到B了，看B的左右子树依次入栈也就是ED
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">B</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">C</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">E</text>
            <text x="85" y="75" font-size="12" text-anchor="middle">D</text>
        </g>
    </svg>
好，B的左右孩子都入了，B可以放心滚蛋了
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">C</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">E</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">D</text>
        </g>
    </svg>
轮到C了，因为C是单身，无牵无挂，直接拜拜
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
             <text x="120" y="120" font-size="12" text-anchor="middle">C</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">E</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">D</text>
        </g>
    </svg>
再到E，E是有FG两个左右孩子的，所以入栈
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
             <text x="120" y="120" font-size="12" text-anchor="middle">C</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">E</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">D</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">F</text>
            <text x="85" y="75" font-size="12" text-anchor="middle">G</text>
        </g>
    </svg>
E滚蛋，如果就是D，D也有左右孩子，也就E滚，D左右孩子入，D滚
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
             <text x="120" y="120" font-size="12" text-anchor="middle">C</text>
           <text x="130" y="120" font-size="12" text-anchor="middle">E</text>
            <text x="140" y="120" font-size="12" text-anchor="middle">D</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">F</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">G</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">H</text>
            <text x="85" y="75" font-size="12" text-anchor="middle">I</text>
        </g>
    </svg>
接下来4个都是叶子，没有孩子，所以依次出栈
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
             <text x="120" y="120" font-size="12" text-anchor="middle">C</text>
           <text x="130" y="120" font-size="12" text-anchor="middle">E</text>
            <text x="140" y="120" font-size="12" text-anchor="middle">D</text>
            <text x="150" y="120" font-size="12" text-anchor="middle">F</text>
            <text x="160" y="120" font-size="12" text-anchor="middle">G</text>
            <text x="170" y="120" font-size="12" text-anchor="middle">H</text>
            <text x="180" y="120" font-size="12" text-anchor="middle">I</text>
        </g>
    </svg>
完结，撒花❀，等等，还没有说代码，算了，反正你也不看
<code type="c">
    void  LevelOrder(BiTree T) {
	InitQueue(Q);
	BiTree p;
	EnQueue(Q, T);//将根结点入队
	while (!IsEmpty(Q)) {
		DeQueue(Q, p);//出队
		visit(p);//访问树
		if(p->lchild!=NULL)
			EnQueue(Q, T);//将左结点入队
		if(p->rchild!=NULL)
			EnQueue(Q, T);//将右结点入队
	}

}
</code>
<span style="color: red;font-size: 20px">线索二叉树</span>
            好，everybody 全体目光向我看齐
<svg width="300" height="50" xmlns="http://www.w3.org/2000/svg">
  <!-- 第一个矩形 -->
  <rect x="0" y="0" width="20" height="20" fill="lightblue" />
  <rect x="21" y="0" width="20" height="20" fill="lightcoral" />
  <rect x="42" y="0" width="20" height="20" fill="lightgreen" />
</svg>
<svg width="400" height="200" xmlns="http://www.w3.org/2000/svg">
  <!-- 画一个圆 -->
  <circle cx="200" cy="20" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="100" cy="100" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="300" cy="100" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="50" cy="180" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="150" cy="180" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="350" cy="180" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <line x1="200" y1="20" x2="100" y2="100" stroke="black" stroke-width="2"/>
    <line x1="200" y1="20" x2="300" y2="100" stroke="black" stroke-width="2"/>
    <line x1="100" y1="100" x2="50" y2="180" stroke="black" stroke-width="2"/>
    <line x1="100" y1="100" x2="150" y2="180" stroke="black" stroke-width="2"/>
    <line x1="300" y1="100" x2="350" y2="180" stroke="black" stroke-width="2"/>
</svg>
这是一个二叉树，我们把它转化一下
<svg width="400" height="220" xmlns="http://www.w3.org/2000/svg">
  <!-- 画一个圆 -->
  <rect x="200" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
      <rect x="180" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
      <rect x="220" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="100" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="80" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="120" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="300" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
    <rect x="320" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
    <rect x="280" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="50" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
    <rect x="30" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
    <rect x="70" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="150" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="170" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="130" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="350" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="370" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="330" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <line x1="195" y1="25" x2="115" y2="100" stroke="black" stroke-width="2"/>
    <line x1="225" y1="25" x2="315" y2="100" stroke="black" stroke-width="2"/>
    <line x1="95" y1="105" x2="60" y2="180" stroke="black" stroke-width="2"/>
    <line x1="125" y1="109" x2="160" y2="180" stroke="black" stroke-width="2"/>
    <line x1="325" y1="105" x2="359" y2="180" stroke="black" stroke-width="2"/>
</svg>
看我们的图，是不是最后的叶子结点的左右子树也就是指针域都是空的
这样是不是很浪费？传统来讲
我们树是没有前驱结点的，也就是说如果你正在某个结点
你想要知道这个结点的前面一个结点，你做不到
怎么办？你只能重新遍历
记录当前结点，并设置一个pre，p两个指针
当p移动，pre总是落后一个，当遍历P=你记录的结点
pre就是你想找的
好啦，说了这么多废话，线索二叉树是什么
就是说把空链域指向它的前驱后继，保证利益最大化
也就是说左孩子空的话就指向它的前面一个结点
右孩子空的话就指向它的后一个结点
都涉及前后了，那肯定是前后后序肯定是不一样的
<span style="color: red">我们就拿这幅图的前序来讲</span>
<svg width="400" height="220" xmlns="http://www.w3.org/2000/svg">
  <!-- 定义箭头标记 -->
  <defs>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L10,5 L0,10 z" fill="red" />
    </marker>
  </defs>

    <!-- 画节点 -->
  <rect x="200" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="180" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="220" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="100" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="80" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="120" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="300" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="320" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="280" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="50" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="30" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="70" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="150" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="170" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="130" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="350" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="370" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="330" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <!-- 添加线索 -->
    <!-- 节点8到节点4 -->
  <path d="M35,180 C40,150 70,120 100,110" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
  <path d="M80,180 C90,150 70,120 150,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
 <path d="M80,180 C90,150 70,120 150,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />


    <!-- 原始的二叉树链接 -->
    <line x1="195" y1="25" x2="115" y2="100" stroke="black" stroke-width="2"/>
    <line x1="225" y1="25" x2="315" y2="100" stroke="black" stroke-width="2"/>
    <line x1="95" y1="105" x2="60" y2="180" stroke="black" stroke-width="2"/>
    <line x1="125" y1="109" x2="160" y2="180" stroke="black" stroke-width="2"/>
    <line x1="325" y1="105" x2="359" y2="180" stroke="black" stroke-width="2"/>
</svg>
先序就是根左右嘛，拿这副图来讲，它的前一个就是它的双亲
它的后一个就是它的双亲的右结点，也就是它的兄弟结点
然后我们继续
<svg width="400" height="220" xmlns="http://www.w3.org/2000/svg">
  <!-- 定义箭头标记 -->
  <defs>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L10,5 L0,10 z" fill="red" />
    </marker>
  </defs>

    <!-- 画节点 -->
  <rect x="200" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="180" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="220" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="100" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="80" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="120" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="300" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="320" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="280" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="50" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="30" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="70" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="150" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="170" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="130" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="350" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="370" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="330" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <!-- 添加线索 -->
    <!-- 节点8到节点4 -->
  <path d="M35,180 C40,150 70,120 100,110" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
  <path d="M80,180 C90,150 70,120 150,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
 <path d="M80,180 C90,150 70,120 150,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
 <path d="M140,200 C90,220 70,210 65,200" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
<path d="M180,200 C200,220 280,200 310,120" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
<path d="M290,110 C250,150 200,100 160,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
    <!-- 原始的二叉树链接 -->
    <line x1="195" y1="25" x2="115" y2="100" stroke="black" stroke-width="2"/>
    <line x1="225" y1="25" x2="315" y2="100" stroke="black" stroke-width="2"/>
    <line x1="95" y1="105" x2="60" y2="180" stroke="black" stroke-width="2"/>
    <line x1="125" y1="109" x2="160" y2="180" stroke="black" stroke-width="2"/>
    <line x1="325" y1="105" x2="359" y2="180" stroke="black" stroke-width="2"/>
</svg>
有人就说了，怎么最后一个叶子结点不画了，是不是懒啊
不是，是因为它的前驱是左结点，而左节点是空，所以它的左空链域是指向空
右空链域原本指向后继，但是后继没了，所以也是指向空
所以，不是你写了不过50个字用了这么多所以？
🫰🏿🫰🏿🫰🏿🫰🏿
        </pre>
<h2>已知前/后和中序遍历构造二叉树</h2>
        <pre>
<span style="color: #7c00ff"> （1）给定前序ABDGHCEFI与中序GDHBAECIF，写出后序遍历。</span>
    你肯定有点思路，但我知道并不多，我们来用一种流氓的思路来解决他
    画以下的类似二维坐标系的图
<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

    <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

    <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">F</text>
    </g>
<g>
        <text x="80" y="115" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="100" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="130" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="85" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="160" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="145" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="190" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="175" font-size="12" text-anchor="middle">F</text>
</g>
    <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">I</text>
        <text x="30" y="175" font-size="12" text-anchor="end">F</text>
        <text x="30" y="160" font-size="12" text-anchor="end">E</text>
        <text x="30" y="145" font-size="12" text-anchor="end">C</text>
        <text x="30" y="130" font-size="12" text-anchor="end">H</text>
        <text x="30" y="115" font-size="12" text-anchor="end">G</text>
        <text x="30" y="100" font-size="12" text-anchor="end">D</text>
        <text x="30" y="85" font-size="12" text-anchor="end">B</text>
        <text x="30" y="70" font-size="12" text-anchor="end">A</text>
    </g>
</svg>
怎么样，画出上面的图，我们肯定知道A是根节点，别问为什么，因为前序遍历第一个肯定是总树的根节点啊😡😡😡😡
接下来我们画线
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

        <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

        <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">F</text>
    </g>
<g>
        <text x="80" y="115" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="100" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="130" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="85" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="160" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="145" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="190" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="175" font-size="12" text-anchor="middle">F</text>
    <!-- 画线 左 -->
    <line x1="160" y1="70" x2="140" y2="85" stroke="black" stroke-width="1"/>
    <line x1="140" y1="85" x2="100" y2="100" stroke="black" stroke-width="1"/>
    <line x1="100" y1="100" x2="80" y2="115" stroke="black" stroke-width="1"/>
    <line x1="100" y1="100" x2="120" y2="130" stroke="black" stroke-width="1"/>
    <!-- 画线 右 -->
    <line x1="160" y1="70" x2="200" y2="145" stroke="black" stroke-width="1"/>
    <line x1="200" y1="145" x2="180" y2="160" stroke="black" stroke-width="1"/>
    <line x1="200" y1="145" x2="240" y2="175" stroke="black" stroke-width="1"/>
    <line x1="240" y1="175" x2="220" y2="190" stroke="black" stroke-width="1"/>

</g>
        <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">I</text>
        <text x="30" y="175" font-size="12" text-anchor="end">F</text>
        <text x="30" y="160" font-size="12" text-anchor="end">E</text>
        <text x="30" y="145" font-size="12" text-anchor="end">C</text>
        <text x="30" y="130" font-size="12" text-anchor="end">H</text>
        <text x="30" y="115" font-size="12" text-anchor="end">G</text>
        <text x="30" y="100" font-size="12" text-anchor="end">D</text>
        <text x="30" y="85" font-size="12" text-anchor="end">B</text>
        <text x="30" y="70" font-size="12" text-anchor="end">A</text>
    </g>
</svg>
画这些点和线真的累死我啦🤨😥😭
看起来是不是很简单，但是如果你现在直接把我题目抄在草稿纸上，自己去画，绝对会有地方卡住
这就是为什么你有时候学习，以为学的很好了，看起来很简单，但是自己一动手就废了
<span style="color: red">注意看我画的图，你怎么知道A必须连接B？为什么不左连接D，右连B？等等问题</span>
在这里我们遵循几个原则
1.这是二叉树，最多只有两个子树，也就是最多只能有两个孩子
2.左孩子的x不会大于根的x
3.根一定在孩子上方
4.与最近的结合
行了，以上是我瞎总结的，这些就是经验，教科书又臭又长，但是学懂了，根本不需要记住那么多东西
就是自然而然的。
然后就是喜闻乐见的，答题环节
<span style="color: red" >后序遍历：GHDBEIFCA</span> <span style="color: #00aa44">//你可能还是困惑为什么E在C前面，I在F前面，真的想一巴掌拍晕你，左右根，A的右树开始是C，但是C是A右子树的根啊，所以开始E，然后C的右，右F也是一棵子树，F也是根所以先I再F啊，你得牢记，计算机是靠递归，而不是忍者神龟</span>
 <span style="color: #7c00ff"> （2）给定后序ACDBGIHFE与中序ABCDEFGHI求前序遍历</span>
在解答这道题前别着急写，别以为学了点东西就以为天下无敌了，乱拳打不死老师傅
仔细想想中序遍历不管他，我们前一题给的是前序遍历，在y轴上当然A最在最上面，因为A是全部的根
但是后序呢？最后一个字母E才是根，如果还按之前的y轴排，E在最下面，那成啥了？
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

        <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

        <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">I</text>
    </g>
<g>
        <text x="80" y="190" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="145" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="175" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="160" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="85" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="130" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="100" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="115" font-size="12" text-anchor="middle">I</text>

</g>
        <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">A</text>
        <text x="30" y="175" font-size="12" text-anchor="end">C</text>
        <text x="30" y="160" font-size="12" text-anchor="end">D</text>
        <text x="30" y="145" font-size="12" text-anchor="end">B</text>
        <text x="30" y="130" font-size="12" text-anchor="end">G</text>
        <text x="30" y="115" font-size="12" text-anchor="end">I</text>
        <text x="30" y="100" font-size="12" text-anchor="end">H</text>
        <text x="30" y="85" font-size="12" text-anchor="end">F</text>
        <text x="30" y="70" font-size="12" text-anchor="end">E</text>
    </g>
</svg>
    按照同样的思路连线，你可以自己尝试一下，再来看我画的
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

        <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

        <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">I</text>
    </g>
<g>
        <text x="80" y="190" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="145" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="175" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="160" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="85" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="130" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="100" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="115" font-size="12" text-anchor="middle">I</text>
    <!-- 画线 左 -->
    <line x1="160" y1="70" x2="100" y2="145" stroke="black" stroke-width="1"/>
    <line x1="100" y1="145" x2="140" y2="160" stroke="black" stroke-width="1"/>
    <line x1="140" y1="160" x2="120" y2="175" stroke="black" stroke-width="1"/>
    <line x1="100" y1="145" x2="80" y2="190" stroke="black" stroke-width="1"/>
    <!-- 画线 右 -->
    <line x1="160" y1="70" x2="180" y2="85" stroke="black" stroke-width="1"/>
    <line x1="180" y1="85" x2="220" y2="100" stroke="black" stroke-width="1"/>
    <line x1="220" y1="100" x2="200" y2="130" stroke="black" stroke-width="1"/>
    <line x1="220" y1="100" x2="240" y2="115" stroke="black" stroke-width="1"/>

</g>
        <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">A</text>
        <text x="30" y="175" font-size="12" text-anchor="end">C</text>
        <text x="30" y="160" font-size="12" text-anchor="end">D</text>
        <text x="30" y="145" font-size="12" text-anchor="end">B</text>
        <text x="30" y="130" font-size="12" text-anchor="end">G</text>
        <text x="30" y="115" font-size="12" text-anchor="end">I</text>
        <text x="30" y="100" font-size="12" text-anchor="end">H</text>
        <text x="30" y="85" font-size="12" text-anchor="end">F</text>
        <text x="30" y="70" font-size="12" text-anchor="end">E</text>
    </g>
</svg>
我知道你如果自己试了的话，有可能在C为什么不连A，而是B连A，这个问题在于，B作为一个根，你将其从上到下看成一个金箍棒
如果C连的左子树为A，那么A大概率在B这根金箍棒的右边而不是左边
下面是题目的答案
<span style="color: red"> 前序遍历：EBADCFHGI</span>
<span style="color: #00ebff"> 一开始学习的时候我问过一个问题：
    第三中，给定前后序，怎么求中序啊？（不知道你会不会有这种想法）
还记得我们一开始说的吗？只有前中以及后中才能确定一棵树，而前后并不能确定唯一的一棵树</span>
        </pre>
<h2>树、森林</h2>
        <pre>
<span style="color: red;font-size: 20px">树的存储方式</span>
1.双亲表示法
<canvas id="myCanvasTree" width="800" height="400"></canvas>
<script>
    var canvas = document.getElementById('myCanvasTree');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 320, y: 50, label: 'A' },   // A
        { x: 120, y: 150, label: 'B' },   // B
        { x: 320, y: 150, label: 'C' },   // C
        { x: 520, y: 150, label: 'D' },   // D
        { x: 70, y: 250, label: 'E' },   // E
        { x: 170, y: 250, label: 'F' },   // F
        { x: 320, y: 250, label: 'G' },   // G
        { x: 420, y: 250, label: 'H' },   // H
        { x: 520, y: 250, label: 'I' },   // I
        { x: 620, y: 250, label: 'J' },   // J
        { x: 20, y: 350, label: 'K' },   // K
        { x: 120, y: 350, label: 'L' },   // L
        { x: 420, y: 350, label: 'M' }    // M
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },  // A-B
        { start: vertices[0], end: vertices[2] },  // A-C
        { start: vertices[0], end: vertices[3] },  // A-D
        { start: vertices[1], end: vertices[4] },  // B-E
        { start: vertices[1], end: vertices[5] },  // B-F
        { start: vertices[2], end: vertices[6] },  // C-G
        { start: vertices[3], end: vertices[7] },  // D-H
        { start: vertices[3], end: vertices[8] },  // D-I
        { start: vertices[3], end: vertices[9] },  // D-J
        { start: vertices[4], end: vertices[10] }, // E-K
        { start: vertices[4], end: vertices[11] }, // E-L
        { start: vertices[7], end: vertices[12] }  // H-M
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();
    });

</script>
  <table style="width: 200px; border-collapse: collapse; margin: 20px 0;">
        <tr>
            <th> </th>
            <th style="border: 1px solid #ccc; padding: 8px; text-align: center; background-color: #5C87B2; color: white;">data</th>
            <th style="border: 1px solid #ccc; padding: 8px; text-align: center; background-color: #5C87B2; color: white;">parent</th>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>0</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">A</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">-1</td>
        </tr>
        <tr>
             <th>1</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">B</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">0</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>2</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">C</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">0</td>
        </tr>
        <tr>
             <th>3</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">D</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">0</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>4</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">E</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">1</td>
        </tr>
        <tr>
             <th>5</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">F</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">1</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>6</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">G</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">2</td>
        </tr>
        <tr>
             <th>7</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">H</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">3</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>8</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">I</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">3</td>
        </tr>
        <tr>
             <th>9</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">J</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">3</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>10</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">K</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">4</td>
        </tr>
              <tr style="background-color: #f2f2f2;">
                   <th>11</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">L</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">4</td>
        </tr>
              <tr style="background-color: #f2f2f2;">
                   <th>12</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">M</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">7</td>
        </tr>
    </table>
不难看出，就是用数组存储它的双亲的下标
2.孩子表示法
孩子表示法就是每个结点与其孩子是链表关系，链表存储的数据域是孩子结点在数组中的下标
<code>//树的孩子表示法结点结构定义
#define MAX_TREE_SIZE 100
typedef int TElemType;   //树结点的数据类型，目前暂定整形
typedef struct CTNode{      //孩子结点
	int child;
	struct CTNode * next;
}*ChildPtr;
typedef struct{              //表头结构
	TElemType data;
	ChildPtr firstchild;
}CTBox;
typedef struct{              //树结构
	CTBox nodes[MAX_TREE_SIZE];    //结点数组
	int  r,n;                     //根节点的位置和结点数
}</code>
3.孩子兄弟表示法
二叉树表示法，就是两个左右指针域，记住四个字《左孩右兄》
        </pre>
        <h2>树、森林与二叉树的转换</h2>
        <pre>
<span style="color: red">树和二叉树</span>的转换就是《左孩右兄》
<span style="color: red">森林和二叉树</span>的转换也是《左孩右兄》，但是森林到树的时候
每一棵树化为二叉树，第一棵树为根，其次其他树的根是它的兄弟
二叉树到森林就是不断拆分它的右子树，每次只拆一个，右子树的左子树保留下来就是它的每一棵树
-----------------------------------------
树的遍历和森林的遍历
树
先根和后根
树的先根=对应二叉树的先序
树的后根=对应二叉树的中序
森林
森林的先序=依次对各个树进行先根
森林的中序=依次对各个树进行后根
森林的中序也可以称为后序
        </pre>
<h2>定长编码，哈夫曼，并查集</h2>
<pre>
定长编码就是固定长度来表示字符，在同一棵树中，使用定长编码的符合一定在同一层
<span style="font-size: 20px" id="3">哈夫曼树</span>
<p>已知
<table>
        <tbody>
            <tr>
                <td>A</td>
                <td>B</td>
                <td>C</td>
                <td>D</td>
                <td>E</td>
            </tr>
            <tr>
                <td>0.15</td>
                <td>0.16</td>
                <td>0.07</td>
                <td>0.21</td>
                <td>0.41</td>
            </tr>
        </tbody>
    </table>
    (1)画出相对应的哈夫曼(Huffman)树
    (2)计算带权路径长度WPL
    (3)求A、B、C、D、E的哈夫曼(Huffman)编码</p>
    （1）取最小的两者不断重构(结合以后的生成的数再放到整个比较)
    以下是详细步骤
<span style="color: #ff00c5">1>ABCDE中A与C的数值最小于是乎先画出A C</span>
    <canvas id="myCanvas10" width="800" height="200"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas10');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [

        { x: 75, y: 25, label: '   0.22' },
        { x: 50, y: 100, label: 'A(0.15)' },
        { x: 150, y: 100, label: 'C(0.07)' },


    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    <span style="color: #ff00c5">2>把A和C的合并数值0.22当成AC再去和剩下的B、D、E比较大小，选出最小两个(也就是B和D)，这个时候刚才画的就别动，在旁边重新画一棵树</span>
        <canvas id="myCanvas11" width="800" height="200"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas11');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        // { x: 250, y: 50, label: '       |  ' },
        // { x: 150, y: 100, label: '0.59' },
        // { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 25, label: '   0.37' },
        { x: 75, y: 25, label: '   0.22' },
        { x: 50, y: 100, label: 'A(0.15)' },
        { x: 150, y: 100, label: 'C(0.07)' },
        { x: 300, y: 100, label: 'B(0.16)' },
        { x: 400, y: 100, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[4] },
        { start: vertices[0], end: vertices[5] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
<span style="color: #ff00c5">3>思想同上(别告诉我你现在还没有看明白😒😒😒)</span>
            <canvas id="myCanvas12" width="800" height="300"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas12');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label: '      1' },
        { x: 150, y: 100, label: '    0.59' },
        { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 175, label: '   0.37' },
        { x: 75, y: 175, label: '   0.22' },
        { x: 50, y: 250, label: 'A(0.15)' },
        { x: 150, y: 250, label: 'C(0.07)' },
        { x: 300, y: 250, label: 'B(0.16)' },
        { x: 400, y: 250, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    <span style="color: red">以上就是对应的完整的哈夫曼树了</span>

    (2)计算WPL（看带字母的节点，然后看这个节点到顶点经过了几条边，经过几条就数值*几就行）
    例如A，从顶点到A经过了4条边(幼儿园的都知道怎么数🤣🤣🤣)
    也就是0.15*4，总之把所有字母的边*数加起来就是WPL
    ∴WPL=1*0.41+3*0.15+3*0.07+3*0.06+3*0.21//*是乘号✖，我靠这样看起来很头疼吗？？这不就是程序员必备的？
    ∴WPL=1✖0.41+3✖0.15+3✖0.07+3✖0.06+3✖0.21//满足你

    (3)求哈夫曼编码（将哈夫曼树的左边画0，右边画1，你就知道了）

<canvas id="myCanvas13" width="800" height="300"></canvas>

<script>
    var canvas = document.getElementById('myCanvas13');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label: '      1' },
        { x: 150, y: 100, label: '    0.59' },
        { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 175, label: '   0.37' },
        { x: 75, y: 175, label: '   0.22' },
        { x: 50, y: 250, label: 'A(0.15)' },
        { x: 150, y: 250, label: 'C(0.07)' },
        { x: 275, y: 250, label: 'B(0.16)' },
        { x: 400, y: 250, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] ,weight:0},
        { start: vertices[0], end: vertices[2] ,weight:1},
        { start: vertices[1], end: vertices[3] ,weight:1},
        { start: vertices[1], end: vertices[4] ,weight:0},
        { start: vertices[4], end: vertices[5] ,weight:0},
        { start: vertices[4], end: vertices[6] ,weight:1},
        { start: vertices[3], end: vertices[7] ,weight:0},
        { start: vertices[3], end: vertices[8] ,weight:1},
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    然后就是从顶点开始往字母走，假如我们选D，D的编码就是011(简单吧🫵)
    答案就是：
    A:000
    B:010
    C:001
    D:011
    E:1
    别觉得哈夫曼编码就是固定长度(🤣🫵)
其次呢，构造过程中产生了n-1个点，那么总数就是n+n-1=2n-1个点
---------------------------------------------
<span style="color: red;font-size: 20px">并查集</span>
并查集说白了就是两个操作
1.查：查找是否属于同一集合
2.并：如果不属于同一集合就合并，后来放到前面根的孩子里面
例如
长度为10的并查集，1-2，3-4，5-6，7-8，8-9，1-8，0-5，1-9的顺序进行查找和合并操作最终有几个集合？
1-2.1和2是不同的集合所以2合并到1中{1，2}
3-4，3和4是不同的集合所以4合并到3中{3，4}
5-6，同理{5，6}
7-8，{7，8}
8-9，9和并到8所属集合{7，8}中{7，8，9}
1-8，将8所属集合合并到1所属集合中{1，2，7，8，9}
0-5，将5所属集合合并到0中{0，5，6}
1-9，将9所属集合合并到1所属集合中{1，2，7，8，9}
所以总结下来就是
{3，4}
{5，6}
{1，2，7，8，9}
</pre>
    </div>
    <div class="block">
        <p>图</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <div class="block">
        <p>查找</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <div class="block">
        <p>排序</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <div class="block">
        <p>算法</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <div class="block">
        <p>递归和分治</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <div class="block">
        <p>动态规划</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <div class="block">
        <p>贪心算法</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <div class="block">
        <p>回溯法和其他算法</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <div class="block">
        <p>数据结构经典题</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <div class="block">
        <p>算法经典题</p>
        <h2>代码示例</h2>
        <pre>
            <code class="c">
#include &lt;stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
            </code>
        </pre>
        <h3>控制台输出</h3>
        <div class="console">
            <pre>
                <code>
$ ./a.out
Hello, world!
                </code>
            </pre>
        </div>
    </div>
    <!-- 添加更多的块 -->
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>
<script>
    hljs.highlightAll();

    document.getElementById('searchBox').addEventListener('input', function() {
        const searchKeyword = this.value.trim().toLowerCase();
        const blocks = document.querySelectorAll('.block');
        blocks.forEach(block => {
            const content = block.textContent.toLowerCase();
            if (content.includes(searchKeyword)) {
                block.style.display = 'block';
                // 自动滚动到匹配内容位置
                block.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                block.style.display = 'none';
            }
        });
    });
</script>
</body>
</html>
