<!DOCTYPE html>
<html lang="en">
<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"3IgcPbFXfKH6JIH0",ck:"3IgcPbFXfKH6JIH0",autoTrack:true,hashMode:true,screenRecord:true})</script>
<script src="../LA.js"></script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Notes</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/default.min.css">
    <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css">
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #28fae6;
            --background-color: #f0f0f0;
            --text-color: #333;
            --border-color: #ddd;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);

        }
        header {
            background-color: #333;
            color: #fff;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 0 15px;
        }
        .block {
            background-color: #fff;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .block h2 {
            margin-top: 0;
            font-size: 20px;
            margin-bottom: 10px;
            color: var(--text-color);
        }
        .block p {
            margin-bottom: 10px;
            font-size: 16px;
        }
        .block pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #f9f9f9;
            padding: 10px;
            border: 1px solid var(--border-color);
            overflow-x: auto;
            border-radius: 5px;
            margin-top: 0;
        }
        .console {
            background-color: #000;
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            overflow-x: auto;
            font-family: Consolas, monospace;
        }
        .console pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            padding: 0;
        }
        .btn {
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: #fff;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            text-decoration: none;
            display: inline-block;
            margin-bottom: 10px;
        }
        .btn:hover {
            background-color: #0056b3;
        }
        .search-container {
            margin-bottom: 20px;
        }
        .search-box {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            box-sizing: border-box;
        }
        h3 {
            color: #00aa44;
            margin-bottom: 10px;
        }
        h2 {
            color: var(--secondary-color);
            margin-bottom: 10px;
        }
        p {
            color: var(--text-color);
            font-size: 16px;
        }
        .adjacency-list {
            margin: 20px;
        }
        .adjacency-list h3 {
            margin: 10px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        td:first-child {
            font-weight: bold;
        }
        #sidebar-h1, #sidebar-h2 {
            position: fixed;
            top: 0;
            width: 250px;
            height: 100%;
            background-color: #2c3e50;
            color: white;
            transition: left 0.3s;
            overflow-y: auto;
            padding: 20px;
            z-index: 1000;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2);
        }
        #sidebar-h1 {
            left: -500px;
        }
        #sidebar-h2 {
            left: -500px;
        }
        #sidebar-h1.active, #sidebar-h2.active {
            left: 0;
        }
        #toggle-btn-h1{
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(52, 73, 94, 0.55);
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            outline: none;
            z-index: 1001;
            transition: background-color 0.3s;
        }
        #toggle-btn-h2 {
            position: fixed;
            top: 20px;
            background-color: #34495e;
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            outline: none;
            z-index: 1001;
            transition: background-color 0.3s;
            right: 20px;
        }
        #toggle-btn-h1:hover, #toggle-btn-h2:hover {
            background-color: #1abc9c;
        }
        #content {
            margin-left: 270px;
            margin-right: 20px;
            padding: 20px;
            background: #fff;
            border-left: 5px solid #34495e;
            min-height: 100vh;
        }
        ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        ul li a {
            color: white;
            text-decoration: none;
            display: block;
            padding: 10px;
            border-bottom: 1px solid #34495e;
            transition: background-color 0.3s;
        }
        ul li a:hover {
            background-color: #1abc9c;
        }
        @media (max-width: 768px) {
            #sidebar-h1, #sidebar-h2 {
                width: 100%;
                left: -200%;
            }
            #toggle-btn-h1{
                left: 10px;
            }
            #toggle-btn-h2 {
                right: 10px;
            }
            #toggle-btn-h2 {
                top: 50px;
            }
            #content {
                margin-left: 20px;
            }
        }
        #editor-container {
            height: 300px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            padding: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        /* 按钮样式 */
        .submit-comment-button {
            padding: 10px 20px; /* 按钮内边距 */
            font-size: 16px; /* 字体大小 */
            color: #fff; /* 字体颜色 */
            background-color: #007bff; /* 背景颜色 */
            border: none; /* 无边框 */
            border-radius: 5px; /* 圆角边框 */
            cursor: pointer; /* 鼠标悬停时显示指针 */
            transition: background-color 0.3s; /* 背景颜色渐变 */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* 添加阴影 */
            right: 20px;
        }

        /* 按钮悬停时的样式 */
        .submit-comment-button:hover {
            background-color: #0056b3; /* 悬停时的背景颜色 */
        }
        #comments {
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .comment {
            border-left: 4px solid #007bff;
            background-color: #f8f9fa;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .comment small {
            display: block;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        #algorithm-container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin: 20px auto;
            padding: 20px;
            max-width: 800px;
        }
        #algorithm-title {
            font-size: 24px;
            margin-top: 0;
        }
        iframe {
            border: none; /* 移除边框 */
            width: 100%; /* 设置宽度为100% */
            height: 1000px; /* 设置高度为500像素 */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.css">
    <script src="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplemde/dist/simplemde.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/simplemde/dist/simplemde.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
    <!-- 在 HTML 文件的<head>部分或<body>结束标签之前引入showdown库 -->
    <script src="https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js"></script>
</head>
<body>
<header>
    <h1>专业课(数据结构，C，C++，算法)笔记</h1>
    <div class="search-container">
        <input type="text" class="search-box" id="searchBox" placeholder="输入关键词进行搜索...(没用，这个搜索算法太难，我不会，就是个输入框，我也不是故意的啊，不这样你又不高兴🤨)">
    </div>

</header>
<div id="editor-container"></div>

<button class="submit-comment-button" onclick="submitComment()">提交评论</button>

<div id="comments"></div>
<button id="toggle-btn-h1">☰ 主</button>
<button id="toggle-btn-h2">☰ 副</button>
<div id="sidebar-h1">
    <ul id="sidebar-h1-content">
        <!-- Dynamic content for H1 will be inserted here -->
    </ul>
</div>
<div id="sidebar-h2">
    <ul id="sidebar-h2-content">
        <!-- Dynamic content for H2 will be inserted here -->
    </ul>
</div>

<!--88923a1f75811f5928e2df6ea0af4978-->

<script>
    var repoOwner = 'wrq6'; // 替换为你的用户名
    var repoName = 'wrq6'; // 替换为你的仓库名
    var issueNumber = 'IAXCHK'; // 替换为你要用于保存留言的Issue编号
    var accessToken = 'bd05e71d5885839b05bff7c0fdc8d8d8'; // 替换为你的 Gitee 访问令牌

    var editor = new toastui.Editor({
        el: document.querySelector('#editor-container'),
        height: '300px',
        initialEditType: 'markdown',
        previewStyle: 'vertical'
    });

    function submitComment() {
        var content = editor.getMarkdown();

        createComment(content)
            .then(function() {
                editor.setMarkdown(''); // 清空评论内容
                fetchComments(); // 重新加载评论
            })
            .catch(function(error) {
                console.error('提交评论时出错:', error);
            });
    }

    function createComment(content) {
        var formData = new FormData();
        formData.append('access_token', accessToken);
        formData.append('body', content);

        return fetch(`https://gitee.com/api/v5/repos/${repoOwner}/${repoName}/issues/${issueNumber}/comments`,  {
            method: 'POST',
            body: formData
        })
            .then(function(response) {
                return response.json();
            })
            .then(function(data) {
                console.log('Comment created:', data);
            });
    }

    function fetchComments() {
        fetch(`https://gitee.com/api/v5/repos/${repoOwner}/${repoName}/issues/${issueNumber}/comments`)
            .then(function(response) {
                return response.json();
            })
            .then(function(comments) {
                var commentsElement = document.getElementById('comments');
                commentsElement.innerHTML = ''; // 清空现有评论

                comments.forEach(function(comment) {
                    var converter = new showdown.Converter();
                    var commentElement = document.createElement('div');
                    commentElement.className = 'comment';
                    commentElement.innerHTML = converter.makeHtml(comment.body);
                    commentElement.innerHTML += `<br><small>提交时间：${new Date(comment.created_at).toLocaleString()}</small>`;
                    commentsElement.appendChild(commentElement);
                });
            })
            .catch(function(error) {
                console.error('获取评论时出错:', error);
            });
    }

    // 初始化时加载评论
    fetchComments();
</script>
<script>
    window.onload = function() {
        var sidebarH1Content = document.getElementById('sidebar-h1-content');
        var sidebarH2Content = document.getElementById('sidebar-h2-content');
        var headingsH1 = document.querySelectorAll(' h1');
        var headingsH2 = document.querySelectorAll(' h2');
        var toggleBtnH1 = document.getElementById('toggle-btn-h1');
        var toggleBtnH2 = document.getElementById('toggle-btn-h2');
        var sidebarH1 = document.getElementById('sidebar-h1');
        var sidebarH2 = document.getElementById('sidebar-h2');
        var autoId = 1;

        function generateSidebar(headingElements, sidebarElement, sidebarButton) {
            var sidebarContent = document.getElementById(sidebarElement);
            sidebarContent.innerHTML = ''; // Clear previous content
            headingElements.forEach(function(heading) {
                var text = heading.textContent.trim();
                var id = 'auto-gen-id-' + autoId++;
                heading.id = id;
                var li = document.createElement('li');
                var a = document.createElement('a');
                a.href = '#' + id;
                a.textContent = text;
                li.appendChild(a);
                sidebarContent.appendChild(li);
            });
        }

        generateSidebar(headingsH1, 'sidebar-h1-content', toggleBtnH1);
        generateSidebar(headingsH2, 'sidebar-h2-content', toggleBtnH2);

        function toggleSidebar(sidebar, button) {
            sidebar.classList.toggle('active');
            if (sidebar.classList.contains('active')) {
                button.textContent = '✖ Close';
            } else {
                button.textContent = '☰';
            }
        }

        toggleBtnH1.onclick = function() {
            toggleSidebar(sidebarH1, toggleBtnH1);
        };
        toggleBtnH2.onclick = function() {
            toggleSidebar(sidebarH2, toggleBtnH2);
        };
    };
</script>
<div class="container">

    <!--   ------------------------------------------------------------------------------------------------------          -->
    <div class="audio-container">
        <audio controls ontimeupdate="showLyrics()">
            <source src="../music/All_That_We_Are.mp3" type="audio/mpeg">
            All That We Are - Audiomachine
        </audio>
    </div>
    <div class="block">
上面这首曲子是“All That We Are”
        <h1>数据结构的三要素</h1>
        <h2>逻辑结构</h2>
        <pre>
            <code class="c">
集合：元素之间没有特定关系
线性结构：一对一    栈
树形结构：一对多    树
图形结构：多对多    图
            </code>
        </pre>
        <h2>存储结构</h2>
        <pre>
顺序存储：数据元素按顺序存储在连续的存储空间中，例如数组，队列。
链式存储：数据元素通过指针链接，例如链表。
索引存储：为数据元素建立附加的索引表，例如数据库的索引。
散列存储：通过散列函数将数据映射到散列表，例如哈希表。
---------------------------------------------
很多人有个误区在这里
索引存储是顺序存储+索引
散列存储是顺序存储+散列
        </pre>
        <h2>数据的操作</h2>
        <pre>
数据的操作包括对数据的增、删、改、查等基本操作。这些操作基于数据的逻辑结构和存储结构实现。
        </pre>
        <h2>总结</h2>
        <pre>
这部分的内容来说，就题目判断一个东西是否为逻辑结构和存储结构
很大一部分不好判断，并且你写的莫名其妙的，答案也是莫名其妙的，总感觉无论选什么，答案总是能够圆谎一样
没办法，只能积累，目前<span style="color: red">栈 树 图</span>是地地道道的逻辑结构
中间有个万金油，就是<span style="color: red">链表</span> 它既可以是两种中的任意一种
剩下的几乎全是存储，反正你只要不在最后一场考试选错，其他的一切都是积累
        </pre>
    </div>
    <!--   ------------------------------------------------------------------------------------------------------          -->
    <div class="block">
        <h1>算法和算法的度量</h1>
        <h2>算法的基本概念</h2>
        <pre>
            <code class="c">
算法是对特定问题求解步骤的一种描述
五个特性：
1.有穷性
2.确定性
3.可行性
4.输入
5.输出
            </code>
        </pre>
        <h2>时间复杂度</h2>
        <pre>
            <code class="c">
n：问题规模
T(n)：时间开销
O(n)：时间复杂度
<span style="color: red">推导大O阶：</span>
    1.用常数1取代运行时间中所有的加法常数
    2.在修改后的运行次数函数中只保留最高阶项
    3.将最高阶项系数变为1
必须牢记的：
⬯(1)<⬯(log₂n)<⬯(n)<⬯(nlog₂n)<⬯(n²)<⬯(n³)<⬯(2^n)<⬯(n!)<⬯(n^n)
常       对       线      线对      方      立    指      全排   牛牛
            </code>
        </pre>
        <h2>空间复杂度</h2>
        <pre>
            <code class="c">
空间复杂度只需要观察与n有关变量即可
递归调用空间复杂度就是递归的深度
有一些是每一层都少去一点是就是n²
也是大O表示法
空间复杂度其实算的就是除去你输入的，以及程序本身的内存以外
当你执行程序的时候，使用的变量会占有内存，这些内存就是空间复杂度的组成
            </code>
        </pre>
        <h2>总结</h2>
        <pre>
空间复杂度不会怎么考
时间复杂度考的多，这一类题目，纯粹就是数学题
这里给出两个用的巨多的公式（等比数列求和，等差数列求和）
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>等差：</mo><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>×</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>等比数列：</mo><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd></mtd><mtd><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mi>n</mi><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mo stretchy="false">(</mo><mi>q</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd></mtd><mtd><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>q</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>−</mo><mi>q</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>−</mo><msub><mi>a</mi><mi>n</mi></msub><mi>q</mi></mrow><mrow><mn>1</mn><mo>−</mo><mi>q</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>a</mi><mi>n</mi></msub><mi>q</mi><mo>−</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><mrow><mi>q</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>,</mo><mo stretchy="false">(</mo><mi>q</mi><mo>≠</mo><mn>1</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math>
        </pre>
        <pre>
例题一：n为正整数，程序的最坏情况下的时间复杂度
            <code class="c">
for (i = n - 1; i > 1; i--)
{
	for (j = 1; j < i; j++)
	{
		if (...)
			.....
	}
}
            </code>
答案：<span style="color: red">O(n²)</span>
解析：我之前由于学过一点数据结构，但是囫囵吞枣，我一看到这种双层循环，就意识到
循环次数，那不就是外层循环×内层循环嘛，于是我算

<span style="color: red">外层循环</span>：从n-1到1，但是不包括1,也就是执行了n-2次循环   为什么？不是哥们
说实话我有时候也坎坷 似乎这是凭感觉得出这个次数的好像
那我们代数看看，假如n-1=10，从10 到 1 你掰手指头看看有几次？
别忘了，一定是包括10的，这没问题吧？😨
但是是不包括1的，因为到1的时候循环是不执行的，也就是最后一次循环是2
10 9 8 7 6 5 4 3 2
1  2 3 4 5 6 7 8 9 次
那不就是比初始值少一次嘛，那外层循环是n-1-1=n-2就说得通了

再看<span style="color: red">内层循环</span>
当i=n-1的时候，j从1开始，直到j < i  也就是j < n-1
1到n-2 有几次？不知道？可去你的吧，n-2次啊😥
同理，当i=n-3的时候，执行 n-3次
i一直会到2，也就是内层最后一次是
j<2，j从1开始，也就是执行1次
好，我们捋一下
n-2
n-3
...
1
是不是等差数列？
所以我们算一下：
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>3</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mn>2</mn></mfrac></math>

好了，内外层我们都算完了，以我的想法就是将内层次数X外层次数
当然是错的，为什么？为什么？我当时最大的问号就是为什么？我明明接触过的训练就是相乘
其实我忽略了一个细节，那就是<span style="color: red">内层循环的次数不直接是n有关，是和外层有关</span>
这就导致，其实这两个for循环，其实就是一个整体，语句的次数其实就是整体执行的次数
不知道你能不能理解，反正我稍微有点感觉了
所以我们的整体循环次数就是内层循环的次数
也就是
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>3</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mn>2</mn></mfrac></math>
当然加上大O
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>O</mi><mo stretchy="false">(</mo><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>3</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></math>
别问我，怎么突然间只剩下n方了，回上面看大O阶的推导，你啊你😡😡😡😡
        </pre>
        <pre>
例题二：m++语句的执行次数
            <code class="c">
int m = 0, i, j;
for (i = 1; i <= n; i++)
{
	for (j = 1; j <= 2 * i; j++)
	{
		m++;
	}
}
            </code>
答案：<span style="color: red">n(n+1)</span>
分析：
外层：i从1到n，也就是n次
内层：
第一次：1到2，包括2，也就是2次
第二次：1到4，4次
第三次：6
8
10
12
...
第n次：2n
等差数列是吧？
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mi>n</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>n</mi></math>
结束了，又不是问时间复杂度，单纯问次数，如果是时间复杂度那就是O(n^2)
        </pre>
        <pre>
例题三：n为描述问题规模的非负整数，求时间复杂度
            <code class="c">
x = 2;
while (x < n / 2)
	x = 2 * x;
            </code>
答案：<span style="color: red">n(n+1)</span>
分析：这类问题怎么办？懵了？先别哭
有套路！
别高兴，骗你的
一般设循环次数为t，解出t=多少，不就ok了？
来，我们试一试
设次数为t
注意看循环停止的条件x < n/2
每次的迭代量为*2，而x是从2开始
也就是说2的某某次方为n/2的时候停止
是这意思吧？但是注意从2开也就是一开始就是2的1次方
所以
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mrow><mi>t</mi></mrow></msup><mo>=</mo><mi>n</mi></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow></mrow><msup><mn>2</mn><mrow><mi>t</mi></mrow></msup><mo>=</mo><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow></mrow><mi>n</mi></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>t</mi><mo>=</mo><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow></mrow><mi>n</mi></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>那么时间复杂度：</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow></mrow><mi>n</mi><mo stretchy="false">)</mo></math>
        </pre>
        <pre>
难点：递归函数的时间复杂度
            <code class="c">
int fact(int n)
{
	if (n <= 1)
		return 1;
	return n * fact(n - 1);
}
            </code>
答案：<span style="color: red">O(n)</span>
分析：
递归函数的时间复杂度可以说和前面不是一个量级的
理解上就很难迈过去
最好理解的一种方法就是公式递推法：
	if (n <= 1)
        return 1;   O(1)
	return n * fact(n - 1); O(1)
我们使用T(n)来表示时间的程度
我们观察，当n<=1的时候只会执行return 1，也就是程序的时间复杂度就是O(1)
当n>1的时候
T(n) = O(1)+T(n-1)   这个O(1)是return n * fact(n - 1);的复杂度，因为乘法只会执行一次
T(n-1)是指，进入下一个函数的时间的程度
那么总的时间程度就是
不断的累加
T(n) = O(1) + T(n-1)
T(n-1) = O(1) + T(n-2)
...
总的时间复杂度就是
(1) + T(n-1)第一次
2xO(1) + T (n-2)到第二个函数时
3xO(1) + T (n-3)到第三个函数时
...
有没有发现规律
yes
O(1)的系数，就是后面T(n-系数)
程序什么3时候停止？就是当T(1)的时候
我们要让T(n-1)、T(n-2)、、、、变为T(1)
那不就是T(n-(n-1))      n-1就是系数
于是
(n-1)O(1) + T(n-(n-1))
(n-1)O(1) + T(1)
就是
O(n-1)
O(n)
于是答案就出来了
这个方法，对于简单的递归来说还行，但是复杂的递归需要很大的毅力，分析能力
但是总之，这个方法稍微掌握一下还是挺不错的
        </pre>
    </div>
    <!--   ------------------------------------------------------------------------------------------------------          -->
    <div class="block">
        <h1>线性表</h1>
        <h2>线性表基本概念</h2>
        <pre>
线性表是具有<span style="color: red">相同</span>数据类型的n个数据元素的<span style="color: red">有限序列</span>，n=0时为空表

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>线性表</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd></mtd><mtd><mo>顺序存储</mo><mo>—</mo><mo>—</mo><mo>顺序表</mo></mtd></mtr><mtr><mtd></mtd><mtd><mo>链式存储</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mo>单链表</mo></mtd></mtr><mtr><mtd><mo>双链表</mo></mtd></mtr><mtr><mtd><mo>循环链表</mo></mtd></mtr><mtr><mtd><mo>静态链表</mo><mo stretchy="false">(</mo><mo>数组实现</mo><mo stretchy="false">)</mo></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></math>
不要急好哥们，有时候就是大道至简，这个图我放这不是用来凑字数的
线性表是一种假想的东西，它是一个逻辑上的东西
而线性表的实现也就是分为两种顺序和链式，这是两个存储结构
别一眼带过，这是很重要的构思。
顺序存储对应的就是顺序表，所以顺序表是一种存储结构
链式存储对应的单链表，双链表，循环链表，静态链表都是一种存储结构
        </pre>
        <h2>顺序表</h2>
        <pre>
用顺序存储的方式实现线性表
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>顺序表</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mo>静态分配（数组）</mo></mtd></mtr><mtr><mtd><mo>动态分配（指针分配内存）</mo></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></math>
这里我讲解一下，动态分配，你是不是又没有思考？
一定要有敏锐的察觉，动态分配，分为两种，就是，每存入一个数就分配一个数的地址将前面和后面链接起来
这似乎是链表的思想
那顺序表的动态是指在程序执行的时候才知道数组要存多少个
这个时候我们动态分配一个数组
存入，当过了一段时间，哦豁，又来新活了，怎么办？
再分配一个新数组，注意是整体，是一个比原来大的数组，足以容纳新的数
然后怎么办？整体搬迁，类似扶贫，整个危房村的人，统一搬迁到政府新建的集体房子
<span style="color: red">顺序表的增删平均</span>
1. 新增元素： O(N) （尾插是O(1),不考虑扩容的情况）
2. 查找元素： O(N)
3. 根据下标获取/修改元素：O(1)
4. 删除元素：O(N)
5. 清除所有元素：O(1)
<span style="color: red">存取方式</span>
读写的方式，顺序表是支持随机存取的存储结构，也就是可以访问任意一个元素
        </pre>
        <h2></h2>
        <h2>单链表</h2>
<pre>
讲单链表之前我们先来说两个东西<span style="color: red">头指针</span>和<span style="color: red">头结点</span>
头指针是指向链表第一个节点的指针
头结点是放在第一个元素之前的一个特殊结点，不存储任何数据
是的，当头结点存在，头指针就是指向头结点的
很好
接下来我们看看怎么建立链表，我们初步建立了一个思想，就是每当需要增加一个元素，采用分配的方法，指针指向的链接形成一个不连续内存的存储结构
单链表有两种实现方法
<span style="color: red">1.头插法</span>
听着很熟悉吧，我们来看，如果这个链表带有头结点，那么每次新增的元素
放到头节点之后，也就是说，每次新增的元素的下一指向先被赋为头结点的下一指向
然后再将头结点的下一指向赋为这个元素
等等，是不是把你搞晕了哈哈哈🤣🤣🤣🫵🏿，你傻吗？头结点->1，现在加入2
你肯定让2->1,然后再让头结点->2啊
L->next=NULL;
p->next=L->next;
L->next=p;
那没有头结点的呢？
L=NULL;
p->next=L;
L=p;
咦，啊啊啊啊啊脑子要爆炸啦
这里讲一个很混乱的东西，头结点和没有头结点怎么都是L啊
头结点在哪呢？
其实头结点就是实例化的一个头指针，我这么说可能有点歧义
我们看下面两段代码
    <code>
Lnode *head,*p;
head=(Lnode*)malloc(sizeof(Lnode));
head->next=NULL;
--------------------------------------------
Lnode *head,*p;
head=NULL;
    </code>
第一段代码，我们看到head是头指针，头指针被分配了指向
    这不是给head分配空间，是让head指向了一个地方，分配空间Lnode *head这句已经自动分配了
    好，头指针现在已经指向了一个地方，head->next是说头指针指向的这个地方的指针域指向下一个的地方赋为空
    |头指针|->|头结点|->|NULL|//通过这个你应该明白了，头结点是分配的地址
第二段代码，我们看到head头指针直接被定义以后赋为NULL说明没有任何指向，也就是没有头结点。
-------------------------
然后我们讲讲头插法
    <code>
        带头结点
p=(Lnode*)malloc(sizeof(Lnode));
p->data=i;
p->next=head->next;
head->next=p;
-----------------------------------------------
        不带头结点
p=(Lnode*)malloc(sizeof(Lnode));
p->data=i;
p->next=head;
head=p;
    </code>
我们看<span style="color: green">第一段代码</span>，p是要新增的一个节点，p=(Lnode*)malloc(sizeof(Lnode));分配空间
p->data=i;给数据域赋值
p->next=head->next;这是带头结点的，所以head指向的地方是头结点而head->next是头结点指向的下一节点
这句话就是将头结点指向的下一节点赋为新节点的下一节点
head->next=p;将头指针指向的头结点的指针域指向p
总体一套连招下来，打的你是晕头转向啊
    没事我会魔法，看🪄
    |head|->|头结点|->|NULL|
    |p|->|NULL|
    |head|->|头结点|->|p|->|NULL|
    这样看不够清晰我们现在要是再增加一个节点M
    |head|->|头结点|->|p|->|NULL|
    |M|->|P|
    |head|->|头结点|->|M|->|P|->|NULL|
我们看<span style="color: green">第二段代码</span>
    p->next=head;直接将p的下一个赋值为head指向的NULL
    head=p;再将head头指针指向新增的p
    慢慢体会吧
<span style="color: red">2.尾插法</span>
    尾插法就是每此新增的元素是增加到结尾
    所以我们要增加一个尾指针，辅助我们在末尾增加新元素
    头指针是不动的，尾指针每次结束是指向最后一个元素，再将最后一个元素的指针域赋为NULL
    <code>
    LinkList TailInster(LinkList &L,int n){
	int x=1;
	L= (LinkList)malloc(sizeof(LNode));
	LNode *s,*r=L;
	while(x!=n){
   		s=(LNode*) malloc(sizeof(LNode));
   		s->data=x;
  	 	r->next=s;
   		r=s;
   		x++;
	}
	r->next=NULL;
	return L;
}
    </code>
因为有了尾指针，所以头插法和尾插法创建单链表的时间复杂度一样都是O(n)
</pre>
<h2>单链表的时间复杂度总结</h2>
        <pre>
头插法-尾插法:都是O(n)
按值按序查:O(n)
增:O(n)，给定节点:O(1)
删:O(n)
求表长:O(n)
时间主要花在查找上
        </pre>
<h2>双链表</h2>
        <pre>
双链表有前驱和后继，两个指针域，单链表只有一个指针域，只能指向后继节点
双链表的增删时间复杂度都是O(1)
        </pre>
<h2>循环单链表</h2>
        <pre>
比起单链表来讲，循环单链表最后一个元素节点的指针域，也就是指向下一个的指针，指向的不是NULL
而是改为指向头结点，如果没有头结点就是头一个元素也就是头指针
这里我要提个醒，链表不是数组，循环单链表的最后一个元素指向的是链表第一个元素
是完整的，不存在任何一个节点的指针域是NULL，所以判断循环单链表的条件不是判空
是判断头结点是不是等于头指针，这样一样来就是说没有元素存在，因为
|head|->|头结点|->|head|
我们也知道，单链表是存在头指针和尾指针
循环链表的话，可以只存在其中一个
如果只存在头指针，那么尾插法需要O(n)
如果只存在尾指针,那么尾插，头插都是O(1)
头指针因为要遍历到最后一个
而尾指针尾插O(1)不需要解释
头插为什么也是？因为头指针可以通过尾指针+1得到
因为是循环链表嘛
        </pre>
<h2>循环双链表</h2>
        <pre>
循环双链表就不多说了，一样的思想，头结点两个指针域的指前指针是要指向链表末尾的节点
判断的话，头结点是两个指针域都等于头指针
        </pre>
<h2>静态链表</h2>
        <pre>
静态链表采用数组的方式
不同于其他，这是个结构体数组，就是说数组的每一个元素都是结构体
结构体包含一个数据和一个整形表示位置
这个整形的数字表示的就是这个元素的下一个元素指向的位置是数组中的第几个元素
给代码自己看
<code>
 typedef struct
    {
        ElemType data;
        int next;
    }SLinkList[MaxSize];
</code>
        </pre>
    </div>
    <div class="block">
        <h1>栈、队列和数组</h1>
        <h2>栈</h2>
        <pre>
栈是一种线性表，只不过它的操作受到限制
只能是一端进行增加和删除
既然是线性表那么就有两种存储方式，也就是顺序栈和链栈
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>卡特兰数：</mo><mi>n</mi><mo>个不同元素入栈，出栈元素不同排列的个数为</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi></mrow></msubsup></math>
</pre>
<h2>顺序栈</h2>
        <pre>
顺序栈的实现
<code>
typedef struct{
    ElemType data[MaxSize];
    int top;
}SqStack;
</code>
栈空条件top=-1
栈的实现其实就是一个数组以及记录栈顶(数组下标)的东西
            你不能纯粹把数组形象化为一个栈，因为栈顶不是数组的开头而是指针向后移动
            也就是说，下标越大的就是栈顶
            |1|-|2|-|3|-|4|-|5|-|6|-|7|-|空|
            7是栈顶，top指向的就是这个，top的值是6，因为数组是从0开始计数
        </pre>
<h2>共享栈</h2>
        <pre>
就是一个数组被两个栈共同占用，挺那啥的是吧，但是节省空间啊
只会发生上溢
我们来考虑一下，共享栈，也就是农村包围城市，两头包围
|1|-|2|-|3|-|空|-|空|-|空|-|空|-|空|-|2|-|1|
看到没有前一个栈是存了三个，栈顶元素是3，top是2是递加的
后面一个栈是存了二个，栈顶元素是2，top是n-2=8是递减的
溢满的情况是怎么样的？
 |1|-|2|-|3|-|4|-|5|-|5|-|4|-|3|-|2|-|1|
A->                                   <-B
现在已经存满了
如果A或者B此时再执行存入一个数，那么势必是造成A或B的一个数被覆盖
造成数据混乱，叫上溢
很多人不理解，为什么叫上溢不叫下溢？
这里的<span style="color: red">上溢</span>是指
栈的增长方向通常被视为“向上”增长。因此，当栈满时，进一步的增长操作导致数据“溢出”预设的界限，这就是“上溢”。
如果栈已经没有元素了，即栈顶指针已经指向栈底或更下的位置，继续执行弹出操作就会导致<span style="color: red">下溢</span>错误。
        </pre>
<h2>链栈</h2>
        <pre>
链栈的实现
<code>
typedef struct LinkNode{
    ElemType data;
    int top;
}*LiStack;
</code>
栈空条件top=MaxSize
        </pre>
<h2>队列</h2>
        <pre>
队列简称队，与栈一样是一种受到限制的线性表，只不过只能在一端插入，一端删除。
队列的顺序存储，很简单与线性表顺序村粗无异，我们给定两个指针
            <code>
 #define MaxSize 50;
 typedef struct{
     ElemType data[MaxSize];
     int front,rear;
 }SqQueue;
            </code>
front 是指向对头，rear是指向队尾。
一开始front和rear都是指向第一个元素，也就是空队
当不断增加元素以后，rear不断后移。
当我们有元素出队列的时候，front要后移
这个时候问题就是出来了，就是说数组的前几个是空的
而rear回不到前面，也就是说，一个冰箱上下都装满了物品
当上面的物品被清空的时候，你还要放物品，你只知道去下面放
下面是满的，你就说你要重新买个冰箱，因为现有的冰箱不能放了
这不是蠢吗，不是，有钱我也这么干，买两杯咖啡，一个倒一个扔，反正不爱喝
        </pre>
<h2>顺序循环队列</h2>
        <pre>
所以我们就有<span style="color: red" >循环队列</span>
<span style="color: red" >初始</span>：Q.front = Q.rear =0;
<span style="color: red" >队首指针进1</span>:Q.front = (Q.front + 1) % MaxSize;
<span style="color: red" >队尾指针进1</span>:Q.rear = (Q.rear + 1) % MaxSize;
<span style="color: red" >队列长度</span>:(Q.rear - Q.front + MaxSize) % MaxSize;
<span style="color: red" >队满条件</span>:(Q.rear +1) % MaxSize ==Q.front;//这里是约定空出一个不存储，也就是队尾+1就是队头的时候就是满,<span style="color: red">注意队尾指向的不是最后一个元素而是最后一个元素的下一个空位置</span>
<span style="color: red" >队空条件</span>:Q.front == Q.rear;
当然了，你也可以这样想，我们额外定义一个Size来记录列表存储个数，当Size=0并且头尾指针相等就是空
如果Size=MixSize并且头尾指针相等就是队满
同样，你也可以这样，出队的时候才会导致队空
入队才会导致队满，定义一个参数tag，=0是删除操作，此时头尾相等是队空，=1是增加，头尾相等是队满
MaxSize是指存储的个数，不是下标，其次A[21]，MaxSize是21，A[0...n]，MaxSize是n+1,因为有n+1个元素
双端队列:允许两端都可以进行入队和出队操作的队列
输入受限的双端队列:允许一端进行输入和删除，另一端只能删除
输出受限的双端队列:允许一端进行输入和删除，另一端只能输入
双端列表是数组形式的，也就是说先全部进入，再依次输出。
即便是双端可进可出，那也是队列，是队列你就给我先进先出
也就是全部进入以后再谈输出
        </pre>
<h2>队列的链式存储</h2>
        <pre>
链队列,尾指针是指向最后一个元素，这一点和顺序存储不同
            <code>
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct{
    LinkNode *front ,*rear;
}*LinkQueue;
            </code>
当Q.front==NULL并且Q.rear==NULL表示队列为空;//认真记住链表和数组的不同的判断方法，不然你会栽跟头的
        </pre>
<h2>栈和队列的应用</h2>
        <pre>
<span style="font-size: 50px" id="9"><span style="color: red">后缀表达式</span>的<span style="color: #00aa00">求值与转换</span>(栈)</span>
    <span style="color: #00daff">四则运算表达式转化为后缀表达式的规则：</span>
    <span style="color: #e600ff">
        1.数字直接写
        2.运算符号如果级别高于栈顶的，直接入栈写上，如果等于或者低于栈顶的让栈顶先出，自己再进去
        3.左括号不管入，遇到右括号，将左括号上面的所有出栈
    </span>
    我们来举个例子：9+（3-1）×3+10
    数字直接写：<span style="color: red">9</span>
    然后就是+号，符号入栈
	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    然后就是（入
    	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >(</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是3，直接写
    <span style="color: red">93</span>
    然后就是-入
     	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >(</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >-</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是1，数字直接写
    <span style="color: red"> 931</span>
    然后就是）右括号，你瞧，直接打包出来，其实也没有就一个-号，收获不大啊，竹篮打水一场空
    <span style="color: red"> 931-</span>
       	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    然后就是x，和此时的栈顶+比较，谁牛逼，显然x牛点，所以入栈
           	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >x</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是3，数字直接写
    <span style="color: red">931-3</span>
    然后就是+，比较栈顶的x，哦豁，没有它厉害，乖乖让x出来
    就是
    <span style="color: red">931-3x</span>
    此时栈：
          	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    还没有完，还要继续比较现在的栈顶，是+和即将入的+是相等的，让栈顶出来
    <span style="color: red">931-3x+</span>
           	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
        </g>
    </svg>
    这个时候，我们的+再入栈
      <span style="color: red">931-3x+</span>
           	<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
                 <text x="60" y="190" font-size="10" text-anchor="middle"  >+</text>
        </g>
    </svg>
    9+（3-1）×3+10，然后就是10，数字直接写
    <span style="color: red">931-3x+10</span>
    然后没了，栈里面的给我滚出来吧
    <span style="color: red">931-3x+10+</span>
    <hr>
    以上就是中转后缀表达式，下面讲讲如何模拟计算机一样，直接计算后缀表达式
    <span style="color: #e600ff">
    1.当是数字的时候直接入栈

    2.当是运算符号的时候

    3.就将栈的最上面两个数拿出进行运算 后 再将结果进栈 记住（栈顶元素永远在运算符号的右边）
    </span>
    看9 3 1 - 3 * + 10 2 / +
    9 3 1依次入栈，没有异议

    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >3</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >1</text>
        </g>
    </svg>
    接下来是-，取出栈顶的两个元素，分别是1 3，1是栈顶，放-号的右边
    就是3-1=2
    将2入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >2</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是 3 入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >2</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >3</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是*，取出来运算
    2*3=6，即便是*这种不在意次序的，你也务必养成习惯将栈顶放右边
    6入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >9</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >6</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是+，取出运算
    9+6=15，15入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是10，数字入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >10</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是
    2入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >10</text>
            <text x="60" y="170" font-size="10" text-anchor="middle"  >2</text>
        </g>
    </svg>
    9 3 1 - 3 * + 10 2 / +接下来是/，取出两个运算
    10/2=5入栈
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
   <line x1="50" y1="200" x2="75" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">这</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">是</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">栈</text>
        </g>
        <g id="loading-txt">
            <text x="60" y="190" font-size="10" text-anchor="middle"  >15</text>
            <text x="60" y="180" font-size="10" text-anchor="middle"  >5</text>
        </g>
    </svg>
9 3 1 - 3 * + 10 2 / +接下来是+，取出来运算
15 + 5 = 20
好了，这就是最后结果了，不信你自己算嘛，给你9+（3-1）x 3+10/2
<span style="font-size: 50px">栈在递归中的应用</span>
对同一个问题递归比非递归好看，但是非递归的效率比递归高
<span style="font-size: 50px">队列在层次遍历中应用</span>
信息的逐层处理
<span style="font-size: 50px">队列在计算机系统中的应用</span>
第一方面解决主机与外部设备之间速度不匹配的问题
第二方面解决由多个用户引起的资源竞争问题
<span style="font-size: 50px">数组和特殊矩阵</span>
两种映射方法：行优先/列优先，行优先：先行后列，存储在一维数组中
<span style="color:red;">压缩存储</span>多个相同的值只分配一个存储空间，节省空间
<span style="color: red">特殊矩阵</span>线性代数中的对称，上/下三角，对角阵，稀疏矩阵
        </pre>
        </div>
    <div class="block">
<h1>串</h1>
        <pre>
串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串
长度为0的才是空串，空格是空格串不是空串
串中字符位置是从1开始数
串也算一种特殊的线性表
        </pre>
<h2>串的顺序存储</h2>
        <pre>
没什么好说的，就是用数组来存
        </pre>
<h2>串的链式存储</h2>
        <pre>
也没什么好说的，块链存储的意思就是，每一个节点呐不单单是存一个字符，而是一串字符，如果存不满，用#填充
        </pre>
<h2>串的模式匹配</h2>
        <pre>
子串的定位操作就是串的模式匹配
Next数组求解
            <code type="c">
首先我们需要知道KMP是干嘛的，通俗易懂的来讲是查找相同字符串的一种捷径
我们人的本能的趋简避繁，例如aababcbdaabacbbbd这样的字符串，我们需要在其中找到子串aabacb我们怎么操作？
为什么会将子串第一个字符依次对比字符串的每一个字符来判断：
=----------1---------=
aababcbdaabacbbbd
aabacb
=----------2---------=
aababcbdaabacbbbd
 aabacb
=----------3---------=
aababcbdaabacbbbd
  aabacb
=----------4---------=
aababcbdaabacbbbd
   abacb
=----------5---------=
aababcbdaabacbbbd
    abacb
=----------6---------=
aababcbdaabacbbbd
     abacb
=----------7---------=
aababcbdaabacbbbd
      abacb
=----------8---------=
aababcbdaabacbbbd
       abacb
=----------9---------=
aababcbdaabacbbbd
        abacb
=----------10---------=
aababcbdaabacbbbd
         abacb
=----------end完结撒花---------=
怎么样是不是很麻烦吧？//麻烦个嘚，我就喜欢
不是，既然计算机大拿说了麻烦咱就认行吗？
于是开头字母分别为KMP的三个人设计了一个算法叫KMP算法（具体思路自己百度，以下只解释最重要也是最难理解的Next数组该怎么求）
Next数组说白了就是求子串中每一个最长相等前后缀（听不懂没关系，往下看）
这里声明一个规则：
前缀：不包含未元素的串
后缀：不包含首元素的串
我们来举个例子这是子串|a|a|b|a|a|f|
（1）|a|
前缀以及后缀都为0  导致最长相等前后缀为0
（2）|a|a|
前缀为|a|
后缀为|a|相等
最长相等前后缀为1
（3）|a|a|b|
前缀为|a|a|
后缀为|a|b|不相等
在这有两个元素的前后缀的基础上再下一次比较
前缀|a|
后缀|b|依然不相等//注意这里的|a|和|b|不是后缀中的|a|b|拆分的，是前缀|a|a|的第一个|a|以及后缀|a|b|最后的那个|b|
最长相等前后缀为0
（4）|a|a|b|a|
前缀为|a|a|b|
后缀为|a|b|a|当然不相等
在这有三个元素的两个前后缀的基础上再下一次比较
前缀|a|a|
后缀|b|a|依然不相等
同理再比较
前缀|a|
后缀|a|相等
所以最长相等前后缀为1
（5）|a|a|b|a|a|
前缀|a|a|b|a|
后缀|a|b|a|a|不等
再前缀|a|a|b|
后缀|b|a|a|不等
再|a|a|
后缀|a|a|相等长度为2
最长相等前后缀为2
（6）|a|a|b|a|a|f|
前缀|a|a|b|a|a|
后缀|a|b|a|a|f|不等
前缀|a|a|b|a|
后缀|b|a|a|f|不等
前缀|a|a|b|
后缀|a|a|f|不等
前缀|a|a|
后缀|a|f|不等
前缀|a|
后缀|f|不等
所以最长相等前后缀为0
所以前缀表的值就是，这6个算出来的数值
即|0|1|0|1|2|0|
<span style="color: red">重点</span>这还不是Next数组
我们需要将-1发放到最前面，然后去掉最后一个数，整体右移
|-1|0|1|0|1|2|
以上为理论部分（聪明的人会看到这里的）

以下是代码实现部分（C++）
#include < stdio.h >
#include < iostream >//c++的头文件
#include< string >
using namespace std;//c++的命名空间，如果没有这句话，很多地方会这样写std::cout等等
class solution {//定义类，c++语法
public://公共方法（好像java才说方法）以及属性
    void getnext(int* next, const string& s) {//传入next数组以及字串
        int j = 0;//j初始化为0
        next[0] = 0;//首元素设置为0
        for (int i = 1; i < s.size(); i++) {//我们假设i指向后缀的末尾，j指向前缀的末尾
            while (j > 0 && s[i] != s[j]) {//while是用来处理前后缀不相同的情况
                j = next[j - 1];//这句代码的意思是回退，回退到前一个数组元素的值为数组下标处
            }
            if (s[i] == s[j]) {//if用来处理前后缀相同的情况
                j++;//如果想相同，则会将j++，让j来表示最长相等前后缀的情况
            }
            next[i] = j;//让此处的最长相等前后缀为j的值
        }
    }
};
int main()
{
    int next[8];
    string s = "abcabcab";
    solution*a = new solution();
    a->getnext(next,s);
    for(int i=0;i<8;i++)
    printf("%d",next[i]);
}
        //放心，代码你十有八九看不懂，不过没关系，毕竟你要是自己研究出来了
        //你就是KMP的发明者了，今天看几遍，过几天再来，慢慢的就理解了
            </code>
<span style="color: red">我就知道你肯定不会认真的看，所以我必须拿出点手段来</span>
<span style="font-size: 20px" >Next数组求解</span>
前缀：不包含未元素的串
后缀：不包含首元素的串
我们来举个例子这是子串|a|a|b|a|a|f|
（1）|a|
前缀以及后缀都为0  导致最长相等前后缀为0
（2）|a|a|
前缀为|a|
后缀为|a|相等
最长相等前后缀为1
（3）|a|a|b|
前缀为|a|a|
后缀为|a|b|不相等
在这有两个元素的前后缀的基础上再下一次比较
前缀|a|
后缀|b|依然不相等//注意这里的|a|和|b|不是后缀中的|a|b|拆分的，是前缀|a|a|的第一个|a|以及后缀|a|b|最后的那个|b|
最长相等前后缀为0
（4）|a|a|b|a|
前缀为|a|a|b|
后缀为|a|b|a|当然不相等
在这有三个元素的两个前后缀的基础上再下一次比较
前缀|a|a|
后缀|b|a|依然不相等
同理再比较
前缀|a|
后缀|a|相等
所以最长相等前后缀为1
（5）|a|a|b|a|a|
前缀|a|a|b|a|
后缀|a|b|a|a|不等
再前缀|a|a|b|
后缀|b|a|a|不等
再|a|a|
后缀|a|a|相等长度为2
最长相等前后缀为2
（6）|a|a|b|a|a|f|
前缀|a|a|b|a|a|
后缀|a|b|a|a|f|不等
前缀|a|a|b|a|
后缀|b|a|a|f|不等
前缀|a|a|b|
后缀|a|a|f|不等
前缀|a|a|
后缀|a|f|不等
前缀|a|
后缀|f|不等
所以最长相等前后缀为0
所以前缀表的值就是，这6个算出来的数值
即|0|1|0|1|2|0|
<span style="color: red">重点</span>这还不是Next数组
我们需要将-1发放到最前面，然后去掉最后一个数，整体右移
|-1|0|1|0|1|2|
上面这个是下标<span style="font-size: 20px;color: red">从0开始</span>的Next数组，如果是从1开始的就是整体+1
|0|1|2|1|2|3|
什么是从0从1开始？我真的要敲爆你的脑子🧠
abcde中c是第三个就是从1开始
abcde中c是第二个就是从0开始
好啦，Next数组求法已经完结，但是有些人真的太聪明了，搞出了一个NextVal数组(我真他妈的🤬)
也简单看下面
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|2|1|2|3|
因为下标从1开始，所以我们写的Next就是整体+1了
我们的NextVal数组第一个统一是0
<span style="color: green">|0|_|_|_|_|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|<span style="color: red">1</span>|2|1|2|3|
这个Next是1，对应的下标1所对应的字符是第一个a和此时的字符是一样的，其次第一个字符a对应的Next是0
一样的字符的话就引用前面的Next值就是0
<span style="color: green">|0|0|_|_|_|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|<span style="color: red">2</span>|1|2|3|
2对应的是a，与b不同，我们直接把b的下标拿下来
<span style="color: green">|0|0|2|_|_|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|2|<span style="color: red">1</span>|2|3|
1对应的是a，与a相同，使用第一个next
<span style="color: green">|0|0|2|0|_|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|2|1|<span style="color: red">2</span>|3|
2对应的是a，与a相同，使用第一个next
<span style="color: green">|0|0|2|0|0|_|</span>
然后我们看
下标: |1|2|3|4|5|6|
字符: |a|a|b|a|a|f|
Next: |0|1|2|1|2|<span style="color: red">3</span>|
3对应的是b，与f不同，则使用自己的
<span style="color: green">|0|0|2|0|0|3|</span>
给你一个例题：串“ababaaababaa”的next数组和nextval数组分别是什么？
答案：
-1,0,0,1,2,3,1,1,2,3,4,5
0,1,0,1,0,4,2,1,0,1,0,4
<span style="color: green">设有字符串S='aabaabaabaac',P='aabaac'</span>
<span style="color: green">1.求出P的next数组。
2.若S作主串，P作模式串，给出KMP算法的匹配过程。</span>
            <span style="color: #4603f5">
            第一个答案好说|0|1|2|1|2|3|
            第二个
            第一趟匹配
            S；|a|a|b|a|a|b|a|a|b|a|a|c|
            P：|a|a|b|a|a|c|
            在S[6]与P[6]的时候失效
            注意到失效的P串的第六个字符的next数值是3，也就是下次比较的时候，直接跳到P串的第3个字符开始比较
            P的第三个对应S的第六个
            也就是第二趟
            S；|a|a|b|a|a|<span style="color: red">b</span>|a|a|b|a|a|c|
            P：      |a|a|<span style="color: red">b</span>|a|a|c|
            失效的时候就是S[9]，P[6]，P的第六个对应的next是3
            也就是下一次从S[9],P[3]开始
            也就是第三趟
            S；|a|a|b|a|a|b|a|a|<span style="color: red">b</span>|a|a|c|
            P：            |a|a|<span style="color: red">b</span>|a|a|c|
            匹配成功。
                </span>
一个主串长度是n，子串长度是m,简单的匹配算法时间复杂度是O(nm),KMP是O(n+m)
        </pre>
    </div>
    <div class="block">
<h1>树和二叉树</h1>
<h2>树的基本概念</h2>
        <pre>
            <canvas id="myCanvas14" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas14');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' },
        { x: 500, y: 50, label:'第一层' },
        { x: 500, y: 100,label:'第二层' },
        { x: 500, y: 175, label:'第三层' },
        { x: 500, y: 250,label:'第四层' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
祖先:比它高的唯一路径上的都是
子孙：比它低的唯一路径上的都是
双亲：它的前驱节点
孩子：它的后继节点
兄弟：有共同的双亲
堂兄弟：双亲不同，但是双亲有共同的双亲
------------------------------
结点的度
树的度
分支结点
叶子结点
树的高度：从下往上，就是最大层数
树的深度：从上往下，也是最大层数
路径：从A到B经过了《哪些》结点
路径长度：从A到B经过了《几》条边
<span style="color: red">树的路径长度：根结点到各个结点的路径长度总和</span>
森林：互不相交的树
m叉数：所有结点的度小于等于m
------------------------------
<span style="color: red">树的性质</span>
结点数=所有结点度数+1
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>度为</mo><mi>m</mi><mo>的树中第</mo><mi>i</mi><mo>层至多有</mo><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>个结点</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>高度为</mo><mi>h</mi><mo>的</mo><mi>m</mi><mo>叉树至多有</mo><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>个结点</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>具有</mo><mi>n</mi><mo>个结点的</mo><mi>m</mi><mo>叉树的最小高度</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>高度为</mo><mi>h</mi><mo>，度为</mo><mi>m</mi><mo>的树至少有</mo><mi>h</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>个结点</mo></math>
            <span style="color: green">
我来解释一下，
第一个你随便画一个二叉树满的，是不是2的比层数低一次方的数（等比数列第n项公式）
第二个它说了至多，也就是每个结点的度是m，每次都是上一次的m倍，也就是等比求和公式
<span style="color: red">第三个</span>因为至少，所以我们把每一个结点满填m，因为是m叉树嘛，然后我们设高度为h
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>n</mi><mo>=</mo><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>m</mi><mi>h</mi></msup><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>h</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></math>
            </span>
这些公式包你恶心的哥哥姐姐，并且你就算记住了也做不了题
you know what
这些公式其实是自己做题做到很多以后，自己靠着不主动的记忆，记忆主动去回忆一丝丝的的东西
然后发现记忆好像就只有零星一点，就算了，然后自己分析题目，自己推，长此以往，竟然觉得所有题好像就这么回事
公式反正不顶用，我记个屁，还不如现场推，反正题目也不会套公式
        </pre>
<h2>二叉树</h2>
        <pre>
二叉树，刚学就忘了？之前说的m叉树，当m=2的时候不就是二叉树
二叉树是指所有结点的度小于等于2
二叉树的左右子树是有序的
几个特殊的二叉树
<span style="color: red">满二叉树</span>除了叶子结点每一个结点度都是2
<span style="color: red">完全二叉树</span>与满二叉树是编号必须一一对应
<span style="color: red">二叉排序树</span>左子树上所有结点的关键字都小于<span style="color: red">其</span>根，右子树的所有结点关键字都大于其根
<span style="color: red">平衡二叉树</span>左子树和右子树的深度之差不超过一
想让我画图给你看是吧，不给🤣🤣🤣🤣
            ------------------------------------------
<span style="color: red">二叉树的性质</span>
1.非空二叉树的叶节点数量是度为2的结点数+1
            <span style="color: green">因为你看结点总数=度为1+度为2+度为0，换另一种思路总数=度为1×1+度为2×2+1(根),所以等式结合就是度为0的数=度为2的数+1</span>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>2.</mn><mo>非空二叉树第</mo><mi>k</mi><mo>层上至多有</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>个结点</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>3.</mn><mo>高度为</mo><mi>h</mi><mo>的二叉树至多有</mo><msup><mn>2</mn><mrow><mi>h</mi></mrow></msup><mo>−</mo><mn>1</mn><mo>个结点</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>4.</mn><mo>对于完全二叉树：结点</mo><mi>i</mi><mo>的双亲编号是</mo><mo stretchy="false">[</mo><mfrac><mi>i</mi><mn>2</mn></mfrac><mo stretchy="false">]</mo><mo>（向下取整），结点</mo><mi>i</mi><mo>所在层次是</mo><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mn>2</mn></mrow></msub><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>5.</mn><mo>具有</mo><mi>n</mi><mo>个结点的完全二叉树的高度为</mo><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>或</mo><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mn>2</mn></mrow></msub><mi>n</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></math>
不知道你怎么想，反正我快红温了😁😀🙂🤨😐😑😶😥😫🤑😩😰😱🥵😡🤬🐒
还是那句话，我不想背，数学已经让我头疼了
什么？我不想背的，有的是人背，我做不到的总是有人做得到？
我去不了的学校他们就替我去了？
我可去你的吧
        </pre>
<h2>二叉树的存储结构</h2>
        <pre>
<span style="color: red">1.顺序存储</span>
只适合存储完全二叉树和满二叉树
用人话就是数组，下标就是数的关键字，什么叫关键字？
我日，看上面我摆出的那个树的图像，每一个圆圈就是结点，圆圈里面的A，B这些就是关键字
你问，ABC....怎么用下标对应？
你啊你，别那么死板啊，把ABC...换成123...不就行了。🫢
<span style="color: red">2.链式存储</span>
左右指针域以及数据域
我知道，你肯定会问双亲怎么找？
从头开始，如果频繁的找的话，你就多设置一个双亲指针域嘛，有什么大不了的
<span style="color: #00c6e7">在含有n个结点的二叉链表中，含有n+1个空链域</span>
是不是很无厘头，我老是这样摆出一个公式，然后解释，但是唯独没有解释为什么要学习这个公式
考试要考？只能说虚伪
没办法，想要站在巨人的肩膀上，只能这样
解释一下，n个结点空链域，也就是说,想想看，一个结点如果是叶子结点是不是它就有两个空链域
如果一个结点只有左右其中一个结点是不是就有一个空链域
然后，空链域是不是=总链域-使用的链域
总链域就是结点×2
使用的链域是不是就是n,是你个大头鬼，根结点是被谁使用的链域形成的，你说说看？
所以使用的链域就是n-1
所以空链域=2n-(n-1)=n+1
        </pre>
<h2>二叉树的遍历和线索二叉树</h2>
        <pre>
树学了这么久，你就没有想过，代码是如何实现，在每一个结点之间横跳的吗？
             <canvas id="myCanvas15" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas15');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
如同以上这棵树，我们如果以先序遍历来遍历这棵树该怎么办？
以我们的理论来说，先序就是根左右，也就是ABEFGDHIC
没问题吧，这都是很简单的(不明白的去看《数据结构部分》)
好，二叉树的实现是利用链表，也就是它有两个指针域
指向左孩子和右孩子，我们从A开始
A可以找到B和C，我们怎样实现先把B以及B的子孙都访问完再访问C？
没错，递归
看下面代码
            <code>
void preOrder(BiTree T)
{
    if(T!=NULL)
        {
            visit(T);
            PreOrder(T->lchild);
            PreOrder(T->rchild);
        }
}
            </code>
中序和后序怎么办？就是Visit放的位置不一样罢了
<code>中
void preOrder(BiTree T)
{
    if(T!=NULL)
        {
            PreOrder(T->lchild);
            visit(T);
            PreOrder(T->rchild);
        }
}
            </code>
<code>后
void preOrder(BiTree T)
{
    if(T!=NULL)
        {
            PreOrder(T->lchild);
            PreOrder(T->rchild);
            visit(T);
        }
}
            </code>
<span style="color: red">三种算法的时间、空间复杂度都是O(n)</span>
<span style="color: red;font-size: 20px">层序遍历</span>
要实现层序遍历，我们要借助一个队列
具体实现如图
<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
        </g>
    </svg>
<canvas id="myCanvas16" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas16');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
这是我们的树，我们要层序遍历就是ABCEDFGHI
我们先让根结点进栈A
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
        <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="55" y="75" font-size="12" text-anchor="middle">A</text>
        </g>
    </svg>
如果此时的A结点有左孩子就入队，再如果有右孩子再把右孩子入队也就是BC依次入
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="55" y="75" font-size="12" text-anchor="middle">A</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">B</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">C</text>
        </g>
    </svg>
这个时候A的左右都入了，于是把A出栈
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">B</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">C</text>
        </g>
    </svg>
轮到B了，看B的左右子树依次入栈也就是ED
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">B</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">C</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">E</text>
            <text x="85" y="75" font-size="12" text-anchor="middle">D</text>
        </g>
    </svg>
好，B的左右孩子都入了，B可以放心滚蛋了
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">C</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">E</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">D</text>
        </g>
    </svg>
轮到C了，因为C是单身，无牵无挂，直接拜拜
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
             <text x="120" y="120" font-size="12" text-anchor="middle">C</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">E</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">D</text>
        </g>
    </svg>
再到E，E是有FG两个左右孩子的，所以入栈
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
             <text x="120" y="120" font-size="12" text-anchor="middle">C</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">E</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">D</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">F</text>
            <text x="85" y="75" font-size="12" text-anchor="middle">G</text>
        </g>
    </svg>
E滚蛋，如果就是D，D也有左右孩子，也就E滚，D左右孩子入，D滚
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
             <text x="120" y="120" font-size="12" text-anchor="middle">C</text>
           <text x="130" y="120" font-size="12" text-anchor="middle">E</text>
            <text x="140" y="120" font-size="12" text-anchor="middle">D</text>
            <text x="55" y="75" font-size="12" text-anchor="middle">F</text>
            <text x="65" y="75" font-size="12" text-anchor="middle">G</text>
            <text x="75" y="75" font-size="12" text-anchor="middle">H</text>
            <text x="85" y="75" font-size="12" text-anchor="middle">I</text>
        </g>
    </svg>
接下来4个都是叶子，没有孩子，所以依次出栈
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="200" y2="50" stroke="black" stroke-width="2"/>
    <line x1="50" y1="100" x2="200" y2="100" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="30" font-size="12" text-anchor="middle">这</text>
        <text x="40" y="30" font-size="12" text-anchor="middle">是</text>
        <text x="50" y="30" font-size="12" text-anchor="middle">个</text>
        <text x="60" y="30" font-size="12" text-anchor="middle">栈</text>
            <text x="60" y="120" font-size="12" text-anchor="middle">出栈：</text>
        <text x="100" y="120" font-size="12"  text-anchor="middle">A</text>
            <text x="110" y="120" font-size="12" text-anchor="middle">B</text>
             <text x="120" y="120" font-size="12" text-anchor="middle">C</text>
           <text x="130" y="120" font-size="12" text-anchor="middle">E</text>
            <text x="140" y="120" font-size="12" text-anchor="middle">D</text>
            <text x="150" y="120" font-size="12" text-anchor="middle">F</text>
            <text x="160" y="120" font-size="12" text-anchor="middle">G</text>
            <text x="170" y="120" font-size="12" text-anchor="middle">H</text>
            <text x="180" y="120" font-size="12" text-anchor="middle">I</text>
        </g>
    </svg>
完结，撒花❀，等等，还没有说代码，算了，反正你也不看，哦对了，那不是个栈，笑死我了哈哈哈哈哈
其实是队列啦☝🏻☝🏿🫰🏿
<code type="c">
    void  LevelOrder(BiTree T) {
	InitQueue(Q);
	BiTree p;
	EnQueue(Q, T);//将根结点入队
	while (!IsEmpty(Q)) {
		DeQueue(Q, p);//出队
		visit(p);//访问树
		if(p->lchild!=NULL)
			EnQueue(Q, T);//将左结点入队
		if(p->rchild!=NULL)
			EnQueue(Q, T);//将右结点入队
	}

}
</code>
<span style="color: red;font-size: 20px">线索二叉树</span>
            好，everybody 全体目光向我看齐
<svg width="300" height="50" xmlns="http://www.w3.org/2000/svg">
  <!-- 第一个矩形 -->
  <rect x="0" y="0" width="20" height="20" fill="lightblue" />
  <rect x="21" y="0" width="20" height="20" fill="lightcoral" />
  <rect x="42" y="0" width="20" height="20" fill="lightgreen" />
</svg>
<svg width="400" height="200" xmlns="http://www.w3.org/2000/svg">
  <!-- 画一个圆 -->
  <circle cx="200" cy="20" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="100" cy="100" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="300" cy="100" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="50" cy="180" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="150" cy="180" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <circle cx="350" cy="180" r="15" fill="lightblue" stroke="black" stroke-width="2" />
    <line x1="200" y1="20" x2="100" y2="100" stroke="black" stroke-width="2"/>
    <line x1="200" y1="20" x2="300" y2="100" stroke="black" stroke-width="2"/>
    <line x1="100" y1="100" x2="50" y2="180" stroke="black" stroke-width="2"/>
    <line x1="100" y1="100" x2="150" y2="180" stroke="black" stroke-width="2"/>
    <line x1="300" y1="100" x2="350" y2="180" stroke="black" stroke-width="2"/>
</svg>
这是一个二叉树，我们把它转化一下
<svg width="400" height="220" xmlns="http://www.w3.org/2000/svg">
  <!-- 画一个圆 -->
  <rect x="200" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
      <rect x="180" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
      <rect x="220" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="100" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="80" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="120" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="300" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
    <rect x="320" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
    <rect x="280" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="50" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
    <rect x="30" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
    <rect x="70" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="150" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="170" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="130" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <rect x="350" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="370" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
        <rect x="330" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <line x1="195" y1="25" x2="115" y2="100" stroke="black" stroke-width="2"/>
    <line x1="225" y1="25" x2="315" y2="100" stroke="black" stroke-width="2"/>
    <line x1="95" y1="105" x2="60" y2="180" stroke="black" stroke-width="2"/>
    <line x1="125" y1="109" x2="160" y2="180" stroke="black" stroke-width="2"/>
    <line x1="325" y1="105" x2="359" y2="180" stroke="black" stroke-width="2"/>
</svg>
看我们的图，是不是最后的叶子结点的左右子树也就是指针域都是空的
这样是不是很浪费？传统来讲
我们树是没有前驱结点的，也就是说如果你正在某个结点
你想要知道这个结点的前面一个结点，你做不到
怎么办？你只能重新遍历
记录当前结点，并设置一个pre，p两个指针
当p移动，pre总是落后一个，当遍历P=你记录的结点
pre就是你想找的
好啦，说了这么多废话，线索二叉树是什么
就是说把空链域指向它的前驱后继，保证利益最大化
也就是说左孩子空的话就指向它的前面一个结点
右孩子空的话就指向它的后一个结点
都涉及前后了，那肯定是前中后序肯定是不一样的
<span style="color: red">我们就拿这幅图的前序来讲</span>
<svg width="400" height="220" xmlns="http://www.w3.org/2000/svg">
  <!-- 定义箭头标记 -->
  <defs>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L10,5 L0,10 z" fill="red" />
    </marker>
  </defs>

    <!-- 画节点 -->
  <rect x="200" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="180" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="220" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="100" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="80" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="120" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="300" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="320" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="280" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="50" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="30" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="70" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="150" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="170" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="130" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="350" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="370" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="330" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <!-- 添加线索 -->
    <!-- 节点8到节点4 -->
  <path d="M35,180 C40,150 70,120 100,110" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
  <path d="M80,180 C90,150 70,120 150,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
 <path d="M80,180 C90,150 70,120 150,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />


    <!-- 原始的二叉树链接 -->
    <line x1="195" y1="25" x2="115" y2="100" stroke="black" stroke-width="2"/>
    <line x1="225" y1="25" x2="315" y2="100" stroke="black" stroke-width="2"/>
    <line x1="95" y1="105" x2="60" y2="180" stroke="black" stroke-width="2"/>
    <line x1="125" y1="109" x2="160" y2="180" stroke="black" stroke-width="2"/>
    <line x1="325" y1="105" x2="359" y2="180" stroke="black" stroke-width="2"/>
</svg>
先序就是根左右嘛，拿这副图来讲，它的前一个就是它的双亲
它的后一个就是它的双亲的右结点，也就是它的兄弟结点
然后我们继续
<svg width="400" height="220" xmlns="http://www.w3.org/2000/svg">
  <!-- 定义箭头标记 -->
  <defs>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L10,5 L0,10 z" fill="red" />
    </marker>
  </defs>

    <!-- 画节点 -->
  <rect x="200" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="180" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="220" y="20" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="100" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="80" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="120" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="300" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="320" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="280" y="100" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="50" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="30" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="70" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="150" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="170" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="130" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

  <rect x="350" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="370" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />
  <rect x="330" y="180" width="20" height="20" fill="lightblue" stroke="black" stroke-width="2" />

    <!-- 添加线索 -->
    <!-- 节点8到节点4 -->
  <path d="M35,180 C40,150 70,120 100,110" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
  <path d="M80,180 C90,150 70,120 150,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
 <path d="M80,180 C90,150 70,120 150,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
 <path d="M140,200 C90,220 70,210 65,200" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
<path d="M180,200 C200,220 280,200 310,120" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
<path d="M290,110 C250,150 200,100 160,180" stroke="red" stroke-width="2" fill="none" marker-end="url(#arrow)" />
    <!-- 原始的二叉树链接 -->
    <line x1="195" y1="25" x2="115" y2="100" stroke="black" stroke-width="2"/>
    <line x1="225" y1="25" x2="315" y2="100" stroke="black" stroke-width="2"/>
    <line x1="95" y1="105" x2="60" y2="180" stroke="black" stroke-width="2"/>
    <line x1="125" y1="109" x2="160" y2="180" stroke="black" stroke-width="2"/>
    <line x1="325" y1="105" x2="359" y2="180" stroke="black" stroke-width="2"/>
</svg>
有人就说了，怎么最后一个叶子结点不画了，是不是懒啊
不是，是因为它的前驱是左结点，而左节点是空，所以它的左空链域是指向空
右空链域原本指向后继，但是后继没了，所以也是指向空
所以，不是你写了不过50个字用了这么多所以？
🫰🏿🫰🏿🫰🏿🫰🏿
        </pre>
<h2>已知前/后和中序遍历构造二叉树</h2>
        <pre>
<span style="color: #7c00ff"> （1）给定前序ABDGHCEFI与中序GDHBAECIF，写出后序遍历。</span>
    你肯定有点思路，但我知道并不多，我们来用一种流氓的思路来解决他
    画以下的类似二维坐标系的图
<svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

    <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

    <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">F</text>
    </g>
<g>
        <text x="80" y="115" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="100" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="130" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="85" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="160" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="145" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="190" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="175" font-size="12" text-anchor="middle">F</text>
</g>
    <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">I</text>
        <text x="30" y="175" font-size="12" text-anchor="end">F</text>
        <text x="30" y="160" font-size="12" text-anchor="end">E</text>
        <text x="30" y="145" font-size="12" text-anchor="end">C</text>
        <text x="30" y="130" font-size="12" text-anchor="end">H</text>
        <text x="30" y="115" font-size="12" text-anchor="end">G</text>
        <text x="30" y="100" font-size="12" text-anchor="end">D</text>
        <text x="30" y="85" font-size="12" text-anchor="end">B</text>
        <text x="30" y="70" font-size="12" text-anchor="end">A</text>
    </g>
</svg>
怎么样，画出上面的图，我们肯定知道A是根节点，别问为什么，因为前序遍历第一个肯定是总树的根节点啊😡😡😡😡
接下来我们画线
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

        <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

        <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">F</text>
    </g>
<g>
        <text x="80" y="115" font-size="12" text-anchor="middle">G</text>
        <text x="100" y="100" font-size="12" text-anchor="middle">D</text>
        <text x="120" y="130" font-size="12" text-anchor="middle">H</text>
        <text x="140" y="85" font-size="12" text-anchor="middle">B</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">A</text>
        <text x="180" y="160" font-size="12" text-anchor="middle">E</text>
        <text x="200" y="145" font-size="12" text-anchor="middle">C</text>
        <text x="220" y="190" font-size="12" text-anchor="middle">I</text>
        <text x="240" y="175" font-size="12" text-anchor="middle">F</text>
    <!-- 画线 左 -->
    <line x1="160" y1="70" x2="140" y2="85" stroke="black" stroke-width="1"/>
    <line x1="140" y1="85" x2="100" y2="100" stroke="black" stroke-width="1"/>
    <line x1="100" y1="100" x2="80" y2="115" stroke="black" stroke-width="1"/>
    <line x1="100" y1="100" x2="120" y2="130" stroke="black" stroke-width="1"/>
    <!-- 画线 右 -->
    <line x1="160" y1="70" x2="200" y2="145" stroke="black" stroke-width="1"/>
    <line x1="200" y1="145" x2="180" y2="160" stroke="black" stroke-width="1"/>
    <line x1="200" y1="145" x2="240" y2="175" stroke="black" stroke-width="1"/>
    <line x1="240" y1="175" x2="220" y2="190" stroke="black" stroke-width="1"/>

</g>
        <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">I</text>
        <text x="30" y="175" font-size="12" text-anchor="end">F</text>
        <text x="30" y="160" font-size="12" text-anchor="end">E</text>
        <text x="30" y="145" font-size="12" text-anchor="end">C</text>
        <text x="30" y="130" font-size="12" text-anchor="end">H</text>
        <text x="30" y="115" font-size="12" text-anchor="end">G</text>
        <text x="30" y="100" font-size="12" text-anchor="end">D</text>
        <text x="30" y="85" font-size="12" text-anchor="end">B</text>
        <text x="30" y="70" font-size="12" text-anchor="end">A</text>
    </g>
</svg>
画这些点和线真的累死我啦🤨😥😭
看起来是不是很简单，但是如果你现在直接把我题目抄在草稿纸上，自己去画，绝对会有地方卡住
这就是为什么你有时候学习，以为学的很好了，看起来很简单，但是自己一动手就废了
<span style="color: red">注意看我画的图，你怎么知道A必须连接B？为什么不左连接D，右连B？等等问题</span>
在这里我们遵循几个原则
1.这是二叉树，最多只有两个子树，也就是最多只能有两个孩子
2.左孩子的x不会大于根的x
3.根一定在孩子上方
4.与最近的结合
行了，以上是我瞎总结的，这些就是经验，教科书又臭又长，但是学懂了，根本不需要记住那么多东西
就是自然而然的。
然后就是喜闻乐见的，答题环节
<span style="color: red" >后序遍历：GHDBEIFCA</span> <span style="color: #00aa44">//你可能还是困惑为什么E在C前面，I在F前面，真的想一巴掌拍晕你，左右根，A的右树开始是C，但是C是A右子树的根啊，所以开始E，然后C的右，右F也是一棵子树，F也是根所以先I再F啊，你得牢记，计算机是靠递归，而不是忍者神龟</span>
 <span style="color: #7c00ff"> （2）给定后序ACDBGIHFE与中序ABCDEFGHI求前序遍历</span>
在解答这道题前别着急写，别以为学了点东西就以为天下无敌了，乱拳打不死老师傅
仔细想想中序遍历不管他，我们前一题给的是前序遍历，在y轴上当然A最在最上面，因为A是全部的根
但是后序呢？最后一个字母E才是根，如果还按之前的y轴排，E在最下面，那成啥了？
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

        <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

        <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">I</text>
    </g>
<g>
        <text x="80" y="190" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="145" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="175" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="160" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="85" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="130" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="100" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="115" font-size="12" text-anchor="middle">I</text>

</g>
        <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">A</text>
        <text x="30" y="175" font-size="12" text-anchor="end">C</text>
        <text x="30" y="160" font-size="12" text-anchor="end">D</text>
        <text x="30" y="145" font-size="12" text-anchor="end">B</text>
        <text x="30" y="130" font-size="12" text-anchor="end">G</text>
        <text x="30" y="115" font-size="12" text-anchor="end">I</text>
        <text x="30" y="100" font-size="12" text-anchor="end">H</text>
        <text x="30" y="85" font-size="12" text-anchor="end">F</text>
        <text x="30" y="70" font-size="12" text-anchor="end">E</text>
    </g>
</svg>
    按照同样的思路连线，你可以自己尝试一下，再来看我画的
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- x轴 -->
    <line x1="50" y1="200" x2="350" y2="200" stroke="black" stroke-width="2"/>

        <!-- y轴 -->
    <line x1="50" y1="200" x2="50" y2="50" stroke="black" stroke-width="2"/>

        <!-- x轴刻度 -->
    <g id="x-axis">
        <text x="80" y="220" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="220" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="220" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="220" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="220" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="220" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="220" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="220" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="220" font-size="12" text-anchor="middle">I</text>
    </g>
<g>
        <text x="80" y="190" font-size="12" text-anchor="middle">A</text>
        <text x="100" y="145" font-size="12" text-anchor="middle">B</text>
        <text x="120" y="175" font-size="12" text-anchor="middle">C</text>
        <text x="140" y="160" font-size="12" text-anchor="middle">D</text>
        <text x="160" y="70" font-size="12" text-anchor="middle">E</text>
        <text x="180" y="85" font-size="12" text-anchor="middle">F</text>
        <text x="200" y="130" font-size="12" text-anchor="middle">G</text>
        <text x="220" y="100" font-size="12" text-anchor="middle">H</text>
        <text x="240" y="115" font-size="12" text-anchor="middle">I</text>
    <!-- 画线 左 -->
    <line x1="160" y1="70" x2="100" y2="145" stroke="black" stroke-width="1"/>
    <line x1="100" y1="145" x2="140" y2="160" stroke="black" stroke-width="1"/>
    <line x1="140" y1="160" x2="120" y2="175" stroke="black" stroke-width="1"/>
    <line x1="100" y1="145" x2="80" y2="190" stroke="black" stroke-width="1"/>
    <!-- 画线 右 -->
    <line x1="160" y1="70" x2="180" y2="85" stroke="black" stroke-width="1"/>
    <line x1="180" y1="85" x2="220" y2="100" stroke="black" stroke-width="1"/>
    <line x1="220" y1="100" x2="200" y2="130" stroke="black" stroke-width="1"/>
    <line x1="220" y1="100" x2="240" y2="115" stroke="black" stroke-width="1"/>

</g>
        <!-- y轴刻度 -->
    <g id="y-axis">
        <text x="30" y="190" font-size="12" text-anchor="end">A</text>
        <text x="30" y="175" font-size="12" text-anchor="end">C</text>
        <text x="30" y="160" font-size="12" text-anchor="end">D</text>
        <text x="30" y="145" font-size="12" text-anchor="end">B</text>
        <text x="30" y="130" font-size="12" text-anchor="end">G</text>
        <text x="30" y="115" font-size="12" text-anchor="end">I</text>
        <text x="30" y="100" font-size="12" text-anchor="end">H</text>
        <text x="30" y="85" font-size="12" text-anchor="end">F</text>
        <text x="30" y="70" font-size="12" text-anchor="end">E</text>
    </g>
</svg>
我知道你如果自己试了的话，有可能在C为什么不连A，而是B连A，这个问题在于，B作为一个根，你将其从上到下看成一个金箍棒
如果C连的左子树为A，那么A大概率在B这根金箍棒的右边而不是左边
下面是题目的答案
<span style="color: red"> 前序遍历：EBADCFHGI</span>
<span style="color: #00ebff"> 一开始学习的时候我问过一个问题：
    第三中，给定前后序，怎么求中序啊？（不知道你会不会有这种想法）
还记得我们一开始说的吗？只有前中以及后中才能确定一棵树，而前后并不能确定唯一的一棵树</span>
        </pre>
<h2>树、森林</h2>
        <pre>
<span style="color: red;font-size: 20px">树的存储方式</span>
1.双亲表示法
<canvas id="myCanvasTree" width="800" height="400"></canvas>
<script>
    var canvas = document.getElementById('myCanvasTree');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 320, y: 50, label: 'A' },   // A
        { x: 120, y: 150, label: 'B' },   // B
        { x: 320, y: 150, label: 'C' },   // C
        { x: 520, y: 150, label: 'D' },   // D
        { x: 70, y: 250, label: 'E' },   // E
        { x: 170, y: 250, label: 'F' },   // F
        { x: 320, y: 250, label: 'G' },   // G
        { x: 420, y: 250, label: 'H' },   // H
        { x: 520, y: 250, label: 'I' },   // I
        { x: 620, y: 250, label: 'J' },   // J
        { x: 20, y: 350, label: 'K' },   // K
        { x: 120, y: 350, label: 'L' },   // L
        { x: 420, y: 350, label: 'M' }    // M
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },  // A-B
        { start: vertices[0], end: vertices[2] },  // A-C
        { start: vertices[0], end: vertices[3] },  // A-D
        { start: vertices[1], end: vertices[4] },  // B-E
        { start: vertices[1], end: vertices[5] },  // B-F
        { start: vertices[2], end: vertices[6] },  // C-G
        { start: vertices[3], end: vertices[7] },  // D-H
        { start: vertices[3], end: vertices[8] },  // D-I
        { start: vertices[3], end: vertices[9] },  // D-J
        { start: vertices[4], end: vertices[10] }, // E-K
        { start: vertices[4], end: vertices[11] }, // E-L
        { start: vertices[7], end: vertices[12] }  // H-M
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();
    });

</script>
  <table style="width: 200px; border-collapse: collapse; margin: 20px 0;">
        <tr>
            <th> </th>
            <th style="border: 1px solid #ccc; padding: 8px; text-align: center; background-color: #5C87B2; color: white;">data</th>
            <th style="border: 1px solid #ccc; padding: 8px; text-align: center; background-color: #5C87B2; color: white;">parent</th>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>0</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">A</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">-1</td>
        </tr>
        <tr>
             <th>1</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">B</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">0</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>2</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">C</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">0</td>
        </tr>
        <tr>
             <th>3</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">D</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">0</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>4</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">E</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">1</td>
        </tr>
        <tr>
             <th>5</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">F</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">1</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>6</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">G</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">2</td>
        </tr>
        <tr>
             <th>7</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">H</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">3</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>8</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">I</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">3</td>
        </tr>
        <tr>
             <th>9</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">J</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">3</td>
        </tr>
        <tr style="background-color: #f2f2f2;">
             <th>10</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">K</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">4</td>
        </tr>
              <tr style="background-color: #f2f2f2;">
                   <th>11</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">L</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">4</td>
        </tr>
              <tr style="background-color: #f2f2f2;">
                   <th>12</th>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">M</td>
            <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">7</td>
        </tr>
    </table>
不难看出，就是用数组存储它的双亲的下标
2.孩子表示法
孩子表示法就是每个结点与其孩子是链表关系，链表存储的数据域是孩子结点在数组中的下标
<code>//树的孩子表示法结点结构定义
#define MAX_TREE_SIZE 100
typedef int TElemType;   //树结点的数据类型，目前暂定整形
typedef struct CTNode{      //孩子结点
	int child;
	struct CTNode * next;
}*ChildPtr;
typedef struct{              //表头结构
	TElemType data;
	ChildPtr firstchild;
}CTBox;
typedef struct{              //树结构
	CTBox nodes[MAX_TREE_SIZE];    //结点数组
	int  r,n;                     //根节点的位置和结点数
}</code>
3.孩子兄弟表示法
二叉树表示法，就是两个左右指针域，记住四个字《左孩右兄》
        </pre>
        <h2>树、森林与二叉树的转换</h2>
        <pre>
<span style="color: red">树和二叉树</span>的转换就是《左孩右兄》
<span style="color: red">森林和二叉树</span>的转换也是《左孩右兄》，但是森林到树的时候
每一棵树化为二叉树，第一棵树为根，其次其他树的根是它的兄弟
二叉树到森林就是不断拆分它的右子树，每次只拆一个，右子树的左子树保留下来就是它的每一棵树
-----------------------------------------
树的遍历和森林的遍历
树
先根和后根
树的先根=对应二叉树的先序
树的后根=对应二叉树的中序
森林
森林的先序=依次对各个树进行先根
森林的中序=依次对各个树进行后根
森林的中序也可以称为后序
        </pre>
<h2>定长编码，哈夫曼，并查集</h2>
<pre>
定长编码就是固定长度来表示字符，在同一棵树中，使用定长编码的符合一定在同一层
<span style="font-size: 20px" id="3">哈夫曼树</span>
<p>已知
<table>
        <tbody>
            <tr>
                <td>A</td>
                <td>B</td>
                <td>C</td>
                <td>D</td>
                <td>E</td>
            </tr>
            <tr>
                <td>0.15</td>
                <td>0.16</td>
                <td>0.07</td>
                <td>0.21</td>
                <td>0.41</td>
            </tr>
        </tbody>
    </table>
    (1)画出相对应的哈夫曼(Huffman)树
    (2)计算带权路径长度WPL
    (3)求A、B、C、D、E的哈夫曼(Huffman)编码</p>
    （1）取最小的两者不断重构(结合以后的生成的数再放到整个比较)
    以下是详细步骤
<span style="color: #ff00c5">1>ABCDE中A与C的数值最小于是乎先画出A C</span>
    <canvas id="myCanvas10" width="800" height="200"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas10');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [

        { x: 75, y: 25, label: '   0.22' },
        { x: 50, y: 100, label: 'A(0.15)' },
        { x: 150, y: 100, label: 'C(0.07)' },


    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    <span style="color: #ff00c5">2>把A和C的合并数值0.22当成AC再去和剩下的B、D、E比较大小，选出最小两个(也就是B和D)，这个时候刚才画的就别动，在旁边重新画一棵树</span>
        <canvas id="myCanvas11" width="800" height="200"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas11');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        // { x: 250, y: 50, label: '       |  ' },
        // { x: 150, y: 100, label: '0.59' },
        // { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 25, label: '   0.37' },
        { x: 75, y: 25, label: '   0.22' },
        { x: 50, y: 100, label: 'A(0.15)' },
        { x: 150, y: 100, label: 'C(0.07)' },
        { x: 300, y: 100, label: 'B(0.16)' },
        { x: 400, y: 100, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[4] },
        { start: vertices[0], end: vertices[5] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
<span style="color: #ff00c5">3>思想同上(别告诉我你现在还没有看明白😒😒😒)</span>
            <canvas id="myCanvas12" width="800" height="300"></canvas>

    <script>
    var canvas = document.getElementById('myCanvas12');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label: '      1' },
        { x: 150, y: 100, label: '    0.59' },
        { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 175, label: '   0.37' },
        { x: 75, y: 175, label: '   0.22' },
        { x: 50, y: 250, label: 'A(0.15)' },
        { x: 150, y: 250, label: 'C(0.07)' },
        { x: 300, y: 250, label: 'B(0.16)' },
        { x: 400, y: 250, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    <span style="color: red">以上就是对应的完整的哈夫曼树了</span>

    (2)计算WPL（看带字母的节点，然后看这个节点到顶点经过了几条边，经过几条就数值*几就行）
    例如A，从顶点到A经过了4条边(幼儿园的都知道怎么数🤣🤣🤣)
    也就是0.15*4，总之把所有字母的边*数加起来就是WPL
    ∴WPL=1*0.41+3*0.15+3*0.07+3*0.06+3*0.21//*是乘号✖，我靠这样看起来很头疼吗？？这不就是程序员必备的？
    ∴WPL=1✖0.41+3✖0.15+3✖0.07+3✖0.06+3✖0.21//满足你

    (3)求哈夫曼编码（将哈夫曼树的左边画0，右边画1，你就知道了）

<canvas id="myCanvas13" width="800" height="300"></canvas>

<script>
    var canvas = document.getElementById('myCanvas13');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label: '      1' },
        { x: 150, y: 100, label: '    0.59' },
        { x: 400, y: 100, label: 'E(0.41)' },
        { x: 250, y: 175, label: '   0.37' },
        { x: 75, y: 175, label: '   0.22' },
        { x: 50, y: 250, label: 'A(0.15)' },
        { x: 150, y: 250, label: 'C(0.07)' },
        { x: 275, y: 250, label: 'B(0.16)' },
        { x: 400, y: 250, label: 'D(0.21)' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] ,weight:0},
        { start: vertices[0], end: vertices[2] ,weight:1},
        { start: vertices[1], end: vertices[3] ,weight:1},
        { start: vertices[1], end: vertices[4] ,weight:0},
        { start: vertices[4], end: vertices[5] ,weight:0},
        { start: vertices[4], end: vertices[6] ,weight:1},
        { start: vertices[3], end: vertices[7] ,weight:0},
        { start: vertices[3], end: vertices[8] ,weight:1},
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.rect(vertex.x - 20, vertex.y - 20, 80, 40);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });

</script>
    然后就是从顶点开始往字母走，假如我们选D，D的编码就是011(简单吧🫵)
    答案就是：
    A:000
    B:010
    C:001
    D:011
    E:1
    别觉得哈夫曼编码就是固定长度(🤣🫵)
其次呢，构造过程中产生了n-1个点，那么总数就是n+n-1=2n-1个点
哈夫曼树是没有度为1的结点的
并且所有的编辑点都是叶子结点，其余的都是生成的
---------------------------------------------
<span style="color: red;font-size: 20px">并查集</span>
并查集说白了就是两个操作
1.查：查找是否属于同一集合
2.并：如果不属于同一集合就合并，后来放到前面根的孩子里面
例如
长度为10的并查集，1-2，3-4，5-6，7-8，8-9，1-8，0-5，1-9的顺序进行查找和合并操作最终有几个集合？
1-2.1和2是不同的集合所以2合并到1中{1，2}
3-4，3和4是不同的集合所以4合并到3中{3，4}
5-6，同理{5，6}
7-8，{7，8}
8-9，9和并到8所属集合{7，8}中{7，8，9}
1-8，将8所属集合合并到1所属集合中{1，2，7，8，9}
0-5，将5所属集合合并到0中{0，5，6}
1-9，将9所属集合合并到1所属集合中{1，2，7，8，9}
所以总结下来就是
{3，4}
{5，6}
{1，2，7，8，9}
</pre>
    </div>
    <div class="block">
        <h1>图</h1>
        <h2>基本概念</h2>
        <pre>
G=(V,E)//V是顶点，E是边，G是图，说白了都是英文单词首字母
---------------------------------------------
图不能是空图，就是至少得有一个点，即便一条边都没有
---------------------------------------------
<1,2>这种是有向边，就是只能从1到2，有向边叫弧
(1,2)这种是无向边，1到2，2到1，无所谓，no care
---------------------------------------------
<span style="color: red">完全图</span>
    有向完全图：任意两点都存在来往的弧
    无向完全图：任意两点都存在边
---------------------------------------------
<span style="color: red">子图</span>
    点是子集，边是子集，并且边所对应的点都是点子集里面的，才叫子图
    怎么着，是不是对上面的话不以为意？这句话很重要，很重要，很重要
    给你解释一下，假如点是城市，边是道路，全中国的点子集就是天津，北京，上海
    但是现在边子集里面有一条是湖北到北京的，但是湖北不是点子集里面的
    那这个子图就不是它的子图。
---------------------------------------------
<span style="color: red">生成子图</span>
    顶点完全一样，但是边是子集
---------------------------------------------
<span style="color: red">连通、连通图、连通分量</span>
两个点之间有路径就是连通的
图中任意两个点之间都有路径的话就是连通图
连通图至少有n-1条边
无向图中的<span style="color: red">极大连通子图</span>称为连通分量
我知道最后一个有点，无语，学数学的时候也学过极大值这个概念
不知道你还记不记得，极大值是的前提是在一段区域内，最值才是全部作比较
也就说极大连通子图，第一个确保连通，第二个确保尽可能的多的点
---------------------------------------------
<span style="color: red">强连通图、强连通分量</span>
无他，就是任意两点都有路径，但是这个是有向图，也就说一定是，嗯懂吧，就是说一定是沿着箭头有路径
极大强连通子图是有向图的强连通分量
强连通图至少有n条边
---------------------------------------------
<span style="color: red">生成树、生成森林</span>
<span style="color:magenta">连通图</span>的<span style="color: red">生成树</span>是包含图中全部顶点的一个极小连通子图
第一个是<span style="color: red">全部顶点</span>，第二个是极小也就是<span style="color: red">边数最小</span>，但是始终<span style="color: red">保存连通</span>
对生成树来说，减去一条边就是非连通，加上一条边就是回路

<span style="color:magenta">非连通图</span>的连通分量的生成树构成了非连通图的<span style="color: red">生成森林</span>
这句话很绕，但是你想想，非连通，但是我们的每一个连通分量是连通的
连通的连通分量的生成树，也就是包含连通分量全部顶点，极小边
这些生成树不是一棵，所以就是森林
---------------------------------------------
<span style="color: red">度</span>
对于有向图来讲，度=边数*2//这是因为一个边是两个顶点共享
对于无向图来讲，入度=出度=边数//因为一个点
---------------------------------------------
<span style="color: red">简单路径、简单回路</span>
在路径中，顶点不重复出现
除第一个和最后一个，环路中没有重复的顶点
---------------------------------------------
<span style="color: red">有向树</span>
一个顶点的入度为0，其余顶点的入度为1的有向图，是有向树
        </pre>
<h2>有向图的强连通分量的求法</h2>
<pre>
1.找入度为0/出度为0的顶点（满足一个为0就行）
2.依次删除这些顶点以及相连的弧，直到不存在入度/出度为0的顶点（为什么说依次呢，以为当你删除第一个顶点以后可能会造成别的顶点就为0了）
3.删掉的顶点以及剩下的有向图就是强连通分量(每一个被你删掉的顶点就是一个单独的强连通分量)
</pre>
        <h2>邻接矩阵</h2>
        <pre>
<canvas id="myCanvas" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: '1' },
        { x: 50, y: 150, label: '2' },
        { x: 250, y: 100, label: '3' },
        { x: 150, y: 150, label: '4' },
        { x: 150, y: 50, label: '5' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[4], end: vertices[2], weight: 7 },
        { start: vertices[2], end: vertices[3], weight: 15 },
        { start: vertices[3], end: vertices[1], weight: 40 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[1], end: vertices[0], weight: 50 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></math>
我们首先不考虑边上的权值，当然存储权值也简单把有边权值替换1，无边的还是0即可，当然可能会有权值为0
无妨，我们定义一个无穷大来表示无边就是很大的数
观察以上矩阵，发现，是对称的，是因为无向图，1-2，那么就是2-1
并且矩阵中的1数是整个图的度
并且每一个点的度只用看行或者列即可
<canvas id="myCanvas1" width="400" height="200" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas1');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 50, y: 50, label: '1' },
    { x: 50, y: 150, label: '2' },
    { x: 250, y: 100, label: '3' },
    { x: 150, y: 150, label: '4' },
    { x: 150, y: 50, label: '5' }
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[4], weight: 10 },
    { start: vertices[4], end: vertices[2], weight: 7 },
    { start: vertices[2], end: vertices[3], weight: 15 },
    { start: vertices[3], end: vertices[1], weight: 40 },
    { start: vertices[0], end: vertices[3], weight: 8 },
    { start: vertices[1], end: vertices[0], weight: 50 }
];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'black';
    context.lineWidth = 2;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 10 * Math.cos(angle - Math.PI / 6), edge.end.y + 10 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 10 * Math.cos(angle + Math.PI / 6), edge.end.y + 10 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></math>
观察以上矩阵是不对称的
每一个顶点的度是行列的加和，例如1的度是第一行+第一列，因为它的度=入度+出度
整个图的度=矩阵*2(别想多了，就是1的个数*2)
<hr>
邻接矩阵的空间复杂度是O(n²)
        </pre>
        <h2>邻接表</h2>
        <pre>
<canvas id="myCanvas3" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas3');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: '1' },
        { x: 50, y: 150, label: '2' },
        { x: 250, y: 100, label: '3' },
        { x: 150, y: 150, label: '4' },
        { x: 150, y: 50, label: '5' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[4], end: vertices[2], weight: 7 },
        { start: vertices[2], end: vertices[3], weight: 15 },
        { start: vertices[3], end: vertices[1], weight: 40 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[1], end: vertices[0], weight: 50 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
  <table style="width: auto">
        <tbody>
            <tr style="">
                <td>1</td>
                <td>-></td>
                <td>5</td>
                <td>-></td>
                <td>4</td>
                <td>-></td>
                <td>2</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                <td>-></td>
                 <td>1</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>3</td>
                <td>-></td>
                 <td>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>4</td>
               <td>-></td>
                 <td>1</td>
                 <td>-></td>
                 <td>2</td>
                <td>-></td>
                 <td>3</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>1</td>
                <td>-></td>
                   <td>3</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
这个是无向图的邻接表，有向图大致同理，只不过是有指向，也就是1->2，只能是1到2，2到1没有
其次邻接表你也看出来了，1连接的是5，4，2那么4，2，5/2，4，5行不行，当然可以，都是无所谓的
<hr>
无向图的空间复杂度O(|V|+2|E|)
有向图的空间复杂度O(|V|+|E|)
        </pre>
        <h2>十字链表、邻接多重表</h2>
        <pre>
十字链表是有向图的一种链式存储结构
邻接多重表是无向图的一种链式存储结构
<hr>
十字链表的空间复杂度O(|V|+|E|)
邻接多重表的空间复杂度O(|V|+|E|)
        </pre>
<h2>图的深度优先与广度优先</h2>
<pre>
 <table style="width: auto">
        <tbody>
            <tr style="">
                <td>1</td>
                <td>-></td>
                <td>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>3</td>
                <td>-></td>
                 <td>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
我们来分析一下深度优先
    第一步    我们给1标上了①，接下来给3表上了②，于是这时候跳到了
                <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>3</td>
                <td>-></td>
                 <td>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
跳到了3处，往后给4表上③，这时候跳到
                    <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                 <td><span style="color: red">③</span>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
这时候跳到了
                     <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                 <td><span style="color: red">③</span>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">③</span>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    注意这时候，4后面没有任何东西，于是回退到上一个的最后继续标
                         <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                 <td><span style="color: red">③</span>4</td>
                 <td>-></td>
                 <td><span style="color: red">④</span>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">③</span>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    标了于是跳到5处，给5的下一个2标上
                            <table style="width: auto">
        <tbody>
            <tr style="">
                <td><span style="color: red">①</span>1</td>
                <td>-></td>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">②</span>3</td>
                <td>-></td>
                 <td><span style="color: red">③</span>4</td>
                 <td>-></td>
                 <td><span style="color: red">④</span>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">③</span>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td><span style="color: red">④</span>5</td>
                <td>-></td>
                   <td><span style="color: red">⑤</span>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    到此为止全部的数都标完了
    于是<span style="color: #022fec"> 深度优先遍历</span>就是：1、3、4、5、2


接下来我们讨论一下<span style="color: #022fec">广度优先遍历</span>(简单的一批，就是从上到下，从左到右)
     <table style="width: auto">
        <tbody>
            <tr style="">
                <td>1</td>
                <td>-></td>
                <td>3</td>
                <td>-></td>
                <td>2</td>
                <td>-></td>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>3</td>
                <td>-></td>
                 <td>4</td>
                 <td>-></td>
                 <td>5</td>
                 <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>-></td>
                   <td>2</td>
                <td>-></td>
                   <td>4</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    就是1、3、2、4、5
    <hr>

当然这是表，如果是树型的呢？
<canvas id="myCanvas20" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas20');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'A' },
        { x: 150, y: 100,label:'B' },
        { x: 400, y: 100,label:'C' },
        { x: 250, y: 175,label:'D' },
        { x: 75, y: 175, label:'E' },
        { x: 50, y: 250, label:'F' },
        { x: 120, y: 250,label:'G' },
        { x: 235, y: 250,label:'H' },
        { x: 300, y: 250,label:'I' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[3], end: vertices[8] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
很好，其实广度优先就是层次遍历，想我们的树的层序遍历，是不是借助过栈来实现
很好，如果你能想起来的话，如果不能，你g了，如果你觉得是的话也g了，因为是用的队列
就拿这个图来讲，A入队列，A接着准备出，但是先把与A相邻的BC入，A再出
|A|
然后B出，但是先把与B相邻的ED入，B出
|A|B|
然后C出，C是孤独老人
|A|B|C|
以此类推
|A|B|C|E|D|F|G|H|I|
这就是广度优先
<span style="color: red;">以上的东西，不要跳，理解以后做题会很爽，爽的一塌糊涂</span>
深度优先的树也好弄，就是一条道走黑，走不动了再依次回退，直到回退的点有别的路再走黑，这样不断循环直到走完
</pre>
        <h2>最小生成树</h2>
        <pre>
给定图，利用<span style="color: red">Kruskal算法（克鲁斯卡算法）</span>生成最小生成树

    <canvas id="myCanvas21" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas21');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[4], end: vertices[2], weight: 7 },
        { start: vertices[2], end: vertices[3], weight: 15 },
        { start: vertices[3], end: vertices[1], weight: 40 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[1], end: vertices[0], weight: 50 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
(1) 找出最小的边
    即
       <canvas id="myCanvas22" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas22');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
(2) 继续找出最小的边
    即
       <canvas id="myCanvas23" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas23');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[0], end: vertices[3], weight: 8 },
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
(3) 继续找出最小的边
    即
       <canvas id="myCanvas24" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas24');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[0], end: vertices[4], weight: 10 },
                { start: vertices[0], end: vertices[3], weight: 8 },
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
(4) 继续找出最小的边<span style="color: red">(注意：这里之所以是选40而不是15的边是因为C和D已经有了通路)</span>
    即
<canvas id="myCanvas25" width="400" height="200" style="border:1px solid #000;"></canvas>
        <script>
            var canvas = document.getElementById('myCanvas25');
            var context = canvas.getContext('2d');
            // 定义图的顶点
            var vertices = [
                { x: 50, y: 50, label: 'A' },
                { x: 50, y: 150, label: 'B' },
                { x: 250, y: 100, label: 'C' },
                { x: 150, y: 150, label: 'D' },
                { x: 150, y: 50, label: 'E' }
            ];

            // 定义图的边和权重
            var edges = [
                { start: vertices[3], end: vertices[1], weight: 40 },
                { start: vertices[0], end: vertices[4], weight: 10 },
                { start: vertices[0], end: vertices[3], weight: 8 },
                { start: vertices[4], end: vertices[2], weight: 7 }
            ];
            // 绘制顶点
            vertices.forEach(function(vertex) {
                context.beginPath();
                context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                context.fillStyle = 'lightblue';
                context.fill();
                context.stroke();

                // 绘制顶点标签
                context.fillStyle = 'black';
                context.font = '14px Arial';
                context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
            });

            // 绘制边和权重
            edges.forEach(function(edge) {
                context.beginPath();
                context.moveTo(edge.start.x, edge.start.y);
                context.lineTo(edge.end.x, edge.end.y);
                context.strokeStyle = 'black';
                context.stroke();

                // 绘制边权重标签
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            });

        </script>
    <br style="border: #6f42c1">
    <br style="border: #6f42c1">
    <br style="border: #6f42c1">
<hr>
给定图，利用<span style="color: red">Prim算法（普里姆算法）</span>生成最小生成树，给定A为初始点
<canvas id="myCanvas26" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas26');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[4], end: vertices[2], weight: 7 },
        { start: vertices[2], end: vertices[3], weight: 15 },
        { start: vertices[3], end: vertices[1], weight: 40 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[1], end: vertices[0], weight: 50 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
(1) 选出与A相连的最小权值的边
    即
<canvas id="myCanvas27" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas27');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[3], weight: 8 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
(2) 选出与AD相连的最小权值的边
    即
<canvas id="myCanvas28" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas28');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[0], end: vertices[3], weight: 8 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
(3) 选出与ADE相连的最小权值的边
    即
<canvas id="myCanvas29" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas29');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[4], end: vertices[2], weight: 7 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
(4) 选出与ADEC相连的最小权值的边(注意：不能选择已经用通路的两点的边)
    即
<canvas id="myCanvas30" width="400" height="200" style="border:1px solid #000;"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas30');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 50, y: 50, label: 'A' },
        { x: 50, y: 150, label: 'B' },
        { x: 250, y: 100, label: 'C' },
        { x: 150, y: 150, label: 'D' },
        { x: 150, y: 50, label: 'E' }
    ];

    // 定义图的边和权重
    var edges = [
        { start: vertices[1], end: vertices[3], weight: 40 },
        { start: vertices[0], end: vertices[4], weight: 10 },
        { start: vertices[0], end: vertices[3], weight: 8 },
        { start: vertices[4], end: vertices[2], weight: 7 }
    ];

    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });

    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        var weightX = (edge.start.x + edge.end.x) / 2;
        var weightY = (edge.start.y + edge.end.y) / 2;
        context.fillStyle = 'red';
        context.font = '12px Arial';
        context.fillText(edge.weight, weightX, weightY);
    });
</script>
<span style="font-size: 20px">总结两种算法的结果是相同的，但是其过程是不同的，解答这类题目的答案就是需要步骤的</span>
克鲁斯卡尔针对边数少挺好，普里姆针对边数多挺好
<hr>
        </pre>
<h2>最短路径</h2>
<pre>
<span style="color: red;font-size: 20px">迪杰斯特拉(Dijkstra)【每次选最短，基于前次来组成最短路径】</span>
<canvas id="myCanvas32" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas32');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 50, y: 150, label: 'a' },
    { x: 100, y: 100, label: 'b' },
    { x: 100, y: 200, label: 'c' },
    { x: 200, y: 100, label: 'd' },
    { x: 200, y: 200, label: 'e' },
    { x: 250, y: 150, label: 'f' }
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 2 },
    { start: vertices[0], end: vertices[2], weight: 5 },
    { start: vertices[1], end: vertices[2], weight: 1 },
    { start: vertices[1], end: vertices[3], weight: 3 },
    { start: vertices[2], end: vertices[3], weight: 3 },
    { start: vertices[2], end: vertices[4], weight: 1 },
    { start: vertices[2], end: vertices[5], weight: 4 },
    { start: vertices[3], end: vertices[4], weight: 1 },
    { start: vertices[3], end: vertices[5], weight: 4 },
    { start: vertices[4], end: vertices[5], weight: 1 },
];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 10 * Math.cos(angle - Math.PI / 6), edge.end.y + 10 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 10 * Math.cos(angle + Math.PI / 6), edge.end.y + 10 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
    第一步，画表格
    <table>
    <tr>
        <th></th>
        <th>第1次</th>
        <th>第2次</th>
        <th>第3次</th>
        <th>第4次</th>
        <th>第5次</th>
    </tr>
    <tr>
        <td>b</td>
        <td class="center">2 (a,b)</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>C</td>
        <td class="center">5 (a,c)</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>d</td>
        <td class="center">∞</td>
        <td></td>
    </tr>
    <tr>
        <td>e</td>
        <td class="center">∞</td>
    </tr>
    <tr>
        <td>f</td>
        <td class="center">∞</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>终点集</td>
        <td class="center">{a,b}</td>
    </tr>
</table>
a->b有路且权为2，a->c有路且权为5，其他都是没有的写无穷，比较a->b与a->c的权大小，选小的，标红
<table>
    <tr>
        <th></th>
        <th>第1次</th>
        <th>第2次</th>
        <th>第3次</th>
        <th>第4次</th>
        <th>第5次</th>
    </tr>
    <tr>
        <td>b</td>
        <td class="center"><span style="color: red">2 (a,b)</span></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>C</td>
        <td class="center">5 (a,c)</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>d</td>
        <td class="center">∞</td>
        <td></td>
    </tr>
    <tr>
        <td>e</td>
        <td class="center">∞</td>
    </tr>
    <tr>
        <td>f</td>
        <td class="center">∞</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>终点集</td>
        <td class="center">{a,b}</td>
    </tr>
</table>
<hr>
然后以ab为整体去看
<table>
    <tr>
        <th></th>
        <th>第1次</th>
        <th>第2次</th>
        <th>第3次</th>
        <th>第4次</th>
        <th>第5次</th>
    </tr>
    <tr>
        <td>b</td>
        <td class="center"><span style="color: red">2 (a,b)</span></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>C</td>
        <td class="center">5 (a,c)</td>
        <td class="center">3 (a,b,c)</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>d</td>
        <td class="center">∞</td>
        <td class="center">5 (a,b,d)</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
    </tr>
    <tr>
        <td>e</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center"></td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
    <tr>
        <td>f</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center"></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>终点集</td>
        <td class="center">{a,b}</td>
        <td class="center">{a,b,c}</td>
        <td class="center"></td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
</table>
ab->c=2+1=3因为a->b是2啊，然后b->c是1，a->b->c不就是3
你不会还真的信我说的，以ab为整体，从a到c是5了吧？不会吧🤣不会吧
这就相对于一个1岁的小孩子长到了5岁，我叫你整体看以后发展，你说可以到0岁和6岁，牛逼
还有ab->d=2+3=5，其他都没有了
选最小的标红
<table>
    <tr>
        <th></th>
        <th>第1次</th>
        <th>第2次</th>
        <th>第3次</th>
        <th>第4次</th>
        <th>第5次</th>
    </tr>
    <tr>
        <td>b</td>
        <td class="center"><span style="color: red">2 (a,b)</span></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>C</td>
        <td class="center">5 (a,c)</td>
        <td class="center"><span style="color: red">3 (a,b,c)</span></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>d</td>
        <td class="center">∞</td>
        <td class="center">5 (a,b,d)</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
    </tr>
    <tr>
        <td>e</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center"></td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
    <tr>
        <td>f</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center"></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>终点集</td>
        <td class="center">{a,b}</td>
        <td class="center">{a,b,c}</td>
        <td class="center"></td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
</table>
<hr>
再以abc为整体去看，c可以到def，注意了，整体也是以最后一个元素c作起始点，b是不行的
<table>
    <tr>
        <th></th>
        <th>第1次</th>
        <th>第2次</th>
        <th>第3次</th>
        <th>第4次</th>
        <th>第5次</th>
    </tr>
    <tr>
        <td>b</td>
        <td class="center"><span style="color: red">2 (a,b)</span></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>C</td>
        <td class="center">5 (a,c)</td>
        <td class="center"><span style="color: red">3 (a,b,c)</span></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>d</td>
        <td class="center">∞</td>
        <td class="center">5 (a,b,d)</td>
        <td class="center">5 (a,b,d)</td>
        <td class="center"></td>
        <td></td>
    </tr>
    <tr>
        <td>e</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center">7 (a,b,c,e)</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
    <tr>
        <td>f</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center"><span style="color: red">4 (a,b,c,f)</span></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>终点集</td>
        <td class="center">{a,b}</td>
        <td class="center">{a,b,c}</td>
        <td class="center">{a,b,c,f}</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
</table>
重复的话我就不说了，还是选择最小的，标红
<hr>
然后再选，然后你就傻眼了，f都是终点了，怎么选，嘿嘿，表格不动，把前面一次未标的平移
<table>
    <tr>
        <th></th>
        <th>第1次</th>
        <th>第2次</th>
        <th>第3次</th>
        <th>第4次</th>
        <th>第5次</th>
    </tr>
    <tr>
        <td>b</td>
        <td class="center"><span style="color: red">2 (a,b)</span></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>C</td>
        <td class="center">5 (a,c)</td>
        <td class="center"><span style="color: red">3 (a,b,c)</span></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>d</td>
        <td class="center">∞</td>
        <td class="center">5 (a,b,d)</td>
        <td class="center">5 (a,b,d)</td>
        <td class="center"><span style="color: red">5 (a,b,d)</span></td>
        <td></td>
    </tr>
    <tr>
        <td>e</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center">7 (a,b,c,e)</td>
        <td class="center">7 (a,b,c,e)</td>
        <td class="center"></td>
    </tr>
    <tr>
        <td>f</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center"><span style="color: red">4 (a,b,c,f)</span></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>终点集</td>
        <td class="center">{a,b}</td>
        <td class="center">{a,b,c}</td>
        <td class="center">{a,b,c,f}</td>
        <td class="center">{a,b,c, f,d}</td>
        <td class="center"></td>
    </tr>
</table>
标出最小的，也就是下一个f直接到d
<hr>
然后d可以到f也可以到e，但是f已经有了，只能去e了
<table>
    <tr>
        <th></th>
        <th>第1次</th>
        <th>第2次</th>
        <th>第3次</th>
        <th>第4次</th>
        <th>第5次</th>
    </tr>
    <tr>
        <td>b</td>
        <td class="center"><span style="color: red">2 (a,b)</span></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>C</td>
        <td class="center">5 (a,c)</td>
        <td class="center"><span style="color: red">3 (a,b,c)</span></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>d</td>
        <td class="center">∞</td>
        <td class="center">5 (a,b,d)</td>
        <td class="center">5 (a,b,d)</td>
        <td class="center"><span style="color: red">5 (a,b,d)</span></td>
        <td></td>
    </tr>
    <tr>
        <td>e</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center">7 (a,b,c,e)</td>
        <td class="center">7 (a,b,c,e)</td>
        <td class="center"><span style="color: red">6 (a,b,d,e)</span></td>
    </tr>
    <tr>
        <td>f</td>
        <td class="center">∞</td>
        <td class="center">∞</td>
        <td class="center"><span style="color: red">4 (a,b,c,f)</span></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>终点集</td>
        <td class="center">{a,b}</td>
        <td class="center">{a,b,c}</td>
        <td class="center">{a,b,c,f}</td>
        <td class="center">{a,b,c, f,d}</td>
        <td class="center">{a,b,c, f,d,e}</td>
    </tr>
</table>
最终答案就是终点集abcfde
<span style="color: red;font-size: 20px">弗洛伊德(Floyd)【基于上一个表，依次将每个点作为中间点去更新】</span>
<canvas id="myCanvas33" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas33');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 50, y: 100, label: '0' },
    { x: 150, y: 100, label: '1' },
    { x: 100, y: 200, label: '2' }
];

// 定义图的边和权重
var edges = [
    { start: { x: 60, y: 90 }, end: { x: 140, y: 90 }, weight: 10 },
    { start: { x: 140, y: 110 }, end: { x: 60, y: 110 }, weight: 6 },
    { start: { x: 70, y: 120 }, end: { x: 100, y: 180 }, weight: 13 },
    { start: { x: 80, y: 190 }, end: { x: 50, y: 100 }, weight: 5 },
    { start: { x: 150, y: 100 }, end: { x: 110, y: 190 }, weight: 4 }
];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 10 * Math.cos(angle - Math.PI / 6), edge.end.y + 10 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 10 * Math.cos(angle + Math.PI / 6), edge.end.y + 10 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
    我们首先画两个表格
    <table>
    <tr>
        <th>D(-1)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center"></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center"></td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
</table>
        <table>
    <tr>
        <th>Path(-1)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center"></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center"></td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
</table>
    我们是初始化第一个表为点到点之间的权，如果没有就写无穷
    第二个表，有直接路径就写前一个点的标值，例如0->1有路径，写0.没有路径写-1
    自己到自己的权值是0
    <table>
    <tr>
        <th>D(-1)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">0</td>
        <td>10</td>
        <td>13</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">6</td>
        <td class="center">0</td>
        <td>4</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">5</td>
        <td class="center">∞</td>
        <td class="center">0</td>
    </tr>
</table>
        <table>
    <tr>
        <th>Path(-1)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">-1</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">1</td>
        <td class="center">-1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">2</td>
        <td class="center">-1</td>
        <td class="center">-1</td>
    </tr>
</table>
以上就是初始的表，我们接下来分别以每一个点作为中间点更新两个表格
<hr>
    <table>
    <tr>
        <th>D(<span style="color: red">0</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">0</td>
        <td>10</td>
        <td>13</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">6</td>
        <td class="center">0</td>
        <td>4</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">5</td>
        <td class="center">∞</td>
        <td class="center">0</td>
    </tr>
</table>
        <table>
    <tr>
        <th>Path(<span style="color: red">0</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">-1</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">1</td>
        <td class="center">-1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">2</td>
        <td class="center">-1</td>
        <td class="center">-1</td>
    </tr>
</table>
有没有发现我把-1变成了0，对0是第一个中间点来更新，至于为什么是0，随你的便
怎么更新？第一个表格，我们是计算x通过0到y，有没有原来的小，有就更新
第二个表格怎么更新呢？就是看上一个path表格的数的后半段
例如现在2通过0到1，2->0->1，0是中间点，path记录的是1前面的一个点
这里的图简单，所以是0，复杂点的图，可能就不是中间点
也就是说2->....->0-><span style="color: red">.....</span>->1
我们要求的就是<span style="color: red">.....</span>最右边的一个点，靠近1的
怎么看，看上一个path表格，0到1的路径是写的0，那么就是0
好，依据这些，我们去更新表格
    <table>
    <tr>
        <th>D(<span style="color: red">0</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">0</td>
        <td>10</td>
        <td>13</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">6</td>
        <td class="center">0</td>
        <td>4</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">5</td>
        <td class="center"><span style="color: red">15</span></td>
        <td class="center">0</td>
    </tr>
</table>
        <table>
    <tr>
        <th>Path(<span style="color: red">0</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">-1</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">1</td>
        <td class="center">-1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">2</td>
        <td class="center"><span style="color: red">0</span></td>
        <td class="center">-1</td>
    </tr>
</table>
这里值得注意的是，1通过0到2，是指1到0，0到2，看上一个表就是6+13是>原本的4的所以不更新
D表不更新，那么P表也对应不更新
你也看到了，以谁作为中间点，谁的那一行与列不用动，好接下来再更新
<table>
    <tr>
        <th>D(<span style="color: red">1</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">0</td>
        <td>10</td>
        <td></td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">6</td>
        <td class="center">0</td>
        <td>4</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center"></td>
        <td class="center"><span style="color: red">15</span></td>
        <td class="center">0</td>
    </tr>
</table>
        <table>
    <tr>
        <th>Path(<span style="color: red">1</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">-1</td>
        <td>0</td>
        <td></td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">1</td>
        <td class="center">-1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center"></td>
        <td class="center"><span style="color: red">0</span></td>
        <td class="center">-1</td>
    </tr>
</table>
    因为对角线不动，并且呢中间点所在行列不变，所以，直接照搬
    然后就剩下两个
    0通过1到2就是10+4=14是大于之前的13的，所以不动
    2通过1到0就是，你是不是回去看图了，你会发现，2->1没有路径，傻眼了
    其实所有的计算都是基于上面一个表，2->1是15，然后1到0是6，就是15+6=21是大于原来的5的，所以不更新
<table>
    <tr>
        <th>D(<span style="color: red">1</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">0</td>
        <td>10</td>
        <td>13</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">6</td>
        <td class="center">0</td>
        <td>4</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">5</td>
        <td class="center"><span style="color: red">15</span></td>
        <td class="center">0</td>
    </tr>
</table>
        <table>
    <tr>
        <th>Path(<span style="color: red">1</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">-1</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">1</td>
        <td class="center">-1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">2</td>
        <td class="center"><span style="color: red">0</span></td>
        <td class="center">-1</td>
    </tr>
</table>
接下来再以2为中间点
<table>
    <tr>
        <th>D(<span style="color: red">2</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">0</td>
        <td></td>
        <td>13</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center"></td>
        <td class="center">0</td>
        <td>4</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">5</td>
        <td class="center"><span style="color: red">15</span></td>
        <td class="center">0</td>
    </tr>
</table>
        <table>
    <tr>
        <th>Path(<span style="color: red">2</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">-1</td>
        <td></td>
        <td>0</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center"></td>
        <td class="center">-1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">2</td>
        <td class="center"><span style="color: red">0</span></td>
        <td class="center">-1</td>
    </tr>
</table>
没什么好解释的吧？
    然后看0通过2到1，0->2->1=13+5=18>10不更新
    1通过2到0就是1->2->0=4+5=9>6不更新
    所以
<table>
    <tr>
        <th>D(<span style="color: red">2</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">0</td>
        <td>10</td>
        <td>13</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">6</td>
        <td class="center">0</td>
        <td>4</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">5</td>
        <td class="center"><span style="color: red">15</span></td>
        <td class="center">0</td>
    </tr>
</table>
        <table>
    <tr>
        <th>Path(<span style="color: red">2</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">-1</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">1</td>
        <td class="center">-1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">2</td>
        <td class="center"><span style="color: red">0</span></td>
        <td class="center">-1</td>
    </tr>
</table>
    以上就是最短路径了，第一个表很好看
    第二个表怎么看最短路径呢？
    </table>
    <table>
    <tr>
        <th>Path(<span style="color: red">2</span>)</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
    </tr>
    <tr>
        <td>0</td>
        <td class="center">-1</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>1</td>
        <td class="center">1</td>
        <td class="center">-1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2</td>
        <td class="center">2</td>
        <td class="center"><span style="color: red">0</span></td>
        <td class="center">-1</td>
    </tr>
</table>
    假如我们看1到0的最短路径，path表中记录的是终点的前一个点
    也就是表格中的1
    所以就是1->1->0=1->0是最短的
</pre>
<h2>拓扑排序</h2>
        <pre>
<span style="color: red;font-size: 20px">拓扑【每次选入度为0的点，删除这个点和他的边】</span>
注意是删除以后有些点就从入度为1变了0了，而且拓扑排序不唯一
<canvas id="myCanvas40" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas40');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 50, y: 150, label: 'a' },
    { x: 100, y: 100, label: 'b' },
    { x: 100, y: 200, label: 'c' },
    { x: 200, y: 100, label: 'd' },
    { x: 200, y: 200, label: 'e' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 0 },
    { start: vertices[0], end: vertices[2], weight: 0 },
    { start: vertices[0], end: vertices[4], weight: 0 },
    { start: vertices[1], end: vertices[2], weight: 0 },
    { start: vertices[2], end: vertices[3], weight: 0 },
    { start: vertices[4], end: vertices[3], weight: 0 },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
我们看这个图，从a入度为0开始，删除a以及它的边
<canvas id="myCanvas41" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas41');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 100, y: 100, label: 'b' },
    { x: 100, y: 200, label: 'c' },
    { x: 200, y: 100, label: 'd' },
    { x: 200, y: 200, label: 'e' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 0 },
    { start: vertices[1], end: vertices[2], weight: 0 },
    { start: vertices[3], end: vertices[2], weight: 0 },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
现在发现b和e都是入度为0，也就是你从b或者e都行，我们从b入手
<canvas id="myCanvas42" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas42');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 100, y: 200, label: 'c' },
    { x: 200, y: 100, label: 'd' },
    { x: 200, y: 200, label: 'e' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 0 },
    { start: vertices[2], end: vertices[1], weight: 0 },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
现在e和c都是入度为0的，都可以选我们选c
<canvas id="myCanvas43" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas43');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 200, y: 100, label: 'd' },
    { x: 200, y: 200, label: 'e' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[1], end: vertices[0], weight: 0 },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
不用多说了吧，只有e了
所以我们的拓扑序列就是abced
当然，不止这一个
        </pre>
<h2>关键路径/AOE网</h2>
<pre>
拓扑求Ve（点的最早开始时间）
<canvas id="myCanvas44" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas44');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 50, y: 150, label: 'V1' },
    { x: 150, y: 50, label: 'V2' },
    { x: 150, y: 250, label: 'V3' },
    { x: 250, y: 50, label: 'V4' },
    { x: 250, y: 250, label: 'V5' },
    { x: 350, y: 150, label: 'V6' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 'a=2' },
    { start: vertices[0], end: vertices[2], weight: 'b=5' },
    { start: vertices[1], end: vertices[3], weight: 'd=3' },
    { start: vertices[1], end: vertices[2], weight: 'c=1' },
    { start: vertices[2], end: vertices[3], weight: 'e=3' },
    { start: vertices[2], end: vertices[5], weight: 'g=1' },
    { start: vertices[2], end: vertices[4], weight: 'f=4' },
    { start: vertices[3], end: vertices[4], weight: 'h=1' },
    { start: vertices[3], end: vertices[5], weight: 'i=4' },
    { start: vertices[4], end: vertices[5], weight: 'j=1' },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
    我们把每个点的Ve（最早开始时间设置为0），先不管Vl
    <table>
    <tr>
        <th></th>
        <th>V1</th>
        <th>V2</th>
        <th>V3</th>
        <th>V4</th>
    </tr>
    <tr>
        <td>Ve</td>
        <td class="center">0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Vl</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
        <td></td>
    </tr>
</table>
然后我们从a入度为0，开始它连接V2和V3，到V2是2，到V3是5
2和5都比0大所以更新，并且删除V1以及它的边
    <table>
    <tr>
        <th></th>
        <th>V1</th>
        <th>V2</th>
        <th>V3</th>
        <th>V4</th>
    </tr>
    <tr>
        <td>Ve</td>
        <td class="center">0</td>
        <td>2</td>
        <td>5</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Vl</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
        <td></td>
    </tr>
</table>
    <canvas id="myCanvas45" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas45');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [

    { x: 150, y: 50, label: 'V2' },
    { x: 150, y: 250, label: 'V3' },
    { x: 250, y: 50, label: 'V4' },
    { x: 250, y: 250, label: 'V5' },
    { x: 350, y: 150, label: 'V6' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[2], weight: 'd=3' },
    { start: vertices[0], end: vertices[1], weight: 'c=1' },
    { start: vertices[1], end: vertices[2], weight: 'e=3' },
    { start: vertices[1], end: vertices[4], weight: 'g=1' },
    { start: vertices[1], end: vertices[3], weight: 'f=4' },
    { start: vertices[2], end: vertices[3], weight: 'h=1' },
    { start: vertices[2], end: vertices[4], weight: 'i=4' },
    { start: vertices[3], end: vertices[4], weight: 'j=1' },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
    现在从V2走，因为只有V2是入度为0，V2连接V3和V4
    V2本身是2，V2再到V3就是2+1=3
    V2本身是2，V2再到V4就是2+3=5
    但是V3是5比3大所以不更新
    V4是0比5小更新
    <table>
    <tr>
        <th></th>
        <th>V1</th>
        <th>V2</th>
        <th>V3</th>
        <th>V4</th>
         <th>V5</th>
         <th>V6</th>
    </tr>
    <tr>
        <td>Ve</td>
        <td class="center">0</td>
        <td>2</td>
        <td>5</td>
        <td>5</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Vl</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>
别奇怪了，之前的表格画少了，我不想改，太麻烦，就这样
然后我们删除V2和它的边
<canvas id="myCanvas46" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas46');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [


    { x: 150, y: 250, label: 'V3' },
    { x: 250, y: 50, label: 'V4' },
    { x: 250, y: 250, label: 'V5' },
    { x: 350, y: 150, label: 'V6' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 'e=3' },
    { start: vertices[0], end: vertices[3], weight: 'g=1' },
    { start: vertices[0], end: vertices[2], weight: 'f=4' },
    { start: vertices[1], end: vertices[2], weight: 'h=1' },
    { start: vertices[1], end: vertices[3], weight: 'i=4' },
    { start: vertices[2], end: vertices[3], weight: 'j=1' },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
入度为0的就是V3，看V3连接着V4，V6，V5
    V3本身是5，V3到V4就是5+3=8，比原来的V4的5大，更新
    V3本身是5，V3到V6就是5+1=6比原来V6的0大，更新
    V3本身是5，V3到V5就是5+4=9比原来V5的0大，更新
    <table>
    <tr>
        <th></th>
        <th>V1</th>
        <th>V2</th>
        <th>V3</th>
        <th>V4</th>
         <th>V5</th>
         <th>V6</th>
    </tr>
    <tr>
        <td>Ve</td>
        <td class="center">0</td>
        <td>2</td>
        <td>5</td>
        <td>8</td>
        <td>9</td>
        <td>6</td>
    </tr>
    <tr>
        <td>Vl</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>
再删除V3和它的边
<canvas id="myCanvas47" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas47');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 250, y: 50, label: 'V4' },
    { x: 250, y: 250, label: 'V5' },
    { x: 350, y: 150, label: 'V6' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 'h=1' },
    { start: vertices[0], end: vertices[2], weight: 'i=4' },
    { start: vertices[1], end: vertices[2], weight: 'j=1' },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
    现在入度为0的就是V4
    V4连接V5和V6
    V4本身是8，V4到V5就是8+1=9，原来的V5是9，不更新
    V4本身是8，V4到V6就是8+4=12，原来的V6是6比12小，更新为更大的12
    <table>
    <tr>
        <th></th>
        <th>V1</th>
        <th>V2</th>
        <th>V3</th>
        <th>V4</th>
         <th>V5</th>
         <th>V6</th>
    </tr>
    <tr>
        <td>Ve</td>
        <td class="center">0</td>
        <td>2</td>
        <td>5</td>
        <td>8</td>
        <td>9</td>
        <td>12</td>
    </tr>
    <tr>
        <td>Vl</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>
再删除V4
<canvas id="myCanvas48" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas48');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 250, y: 250, label: 'V5' },
    { x: 350, y: 150, label: 'V6' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 'j=1' },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
V5到V6，V5本身是9，到V6就是9+1=10，没有12大，不更新
最终的表就是
    <table>
    <tr>
        <th></th>
        <th>V1</th>
        <th>V2</th>
        <th>V3</th>
        <th>V4</th>
         <th>V5</th>
         <th>V6</th>
    </tr>
    <tr>
        <td>Ve</td>
        <td class="center">0</td>
        <td>2</td>
        <td>5</td>
        <td>8</td>
        <td>9</td>
        <td>12</td>
    </tr>
    <tr>
        <td>Vl</td>
        <td class="center"></td>
        <td class="center"></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>
<hr>
接下来我们求最晚开始时间Vl
就是逆拓扑排序：每次选 出度为0的，从最后一个点开始
也就是从V6开始，最后一个点的最晚和最早都是一样的
把所有点的最晚时间初始化为最后一个点的最晚时间
<canvas id="myCanvas49" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas49');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 50, y: 150, label: 'V1' },
    { x: 150, y: 50, label: 'V2' },
    { x: 150, y: 250, label: 'V3' },
    { x: 250, y: 50, label: 'V4' },
    { x: 250, y: 250, label: 'V5' },
    { x: 350, y: 150, label: 'V6' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 'a=2' },
    { start: vertices[0], end: vertices[2], weight: 'b=5' },
    { start: vertices[1], end: vertices[3], weight: 'd=3' },
    { start: vertices[1], end: vertices[2], weight: 'c=1' },
    { start: vertices[2], end: vertices[3], weight: 'e=3' },
    { start: vertices[2], end: vertices[5], weight: 'g=1' },
    { start: vertices[2], end: vertices[4], weight: 'f=4' },
    { start: vertices[3], end: vertices[4], weight: 'h=1' },
    { start: vertices[3], end: vertices[5], weight: 'i=4' },
    { start: vertices[4], end: vertices[5], weight: 'j=1' },

];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
    <table>
    <tr>
        <th></th>
        <th>V1</th>
        <th>V2</th>
        <th>V3</th>
        <th>V4</th>
         <th>V5</th>
         <th>V6</th>
    </tr>
    <tr>
        <td>Ve</td>
        <td class="center">0</td>
        <td>2</td>
        <td>5</td>
        <td>8</td>
        <td>9</td>
        <td>12</td>
    </tr>
    <tr>
        <td>Vl</td>
        <td class="center">12</td>
        <td class="center">12</td>
        <td>12</td>
        <td>12</td>
        <td>12</td>
        <td>12</td>
    </tr>
</table>
V6连接着V5，V4，V3，我们用12分别减去，然后比大小，更新小的那个数
     <table>
    <tr>
        <th></th>
        <th>V1</th>
        <th>V2</th>
        <th>V3</th>
        <th>V4</th>
         <th>V5</th>
         <th>V6</th>
    </tr>
    <tr>
        <td>Ve</td>
        <td class="center">0</td>
        <td>2</td>
        <td>5</td>
        <td>8</td>
        <td>9</td>
        <td>12</td>
    </tr>
    <tr>
        <td>Vl</td>
        <td class="center">12</td>
        <td class="center">12</td>
        <td><span style="color: red">11</span></td>
        <td><span style="color: red">8</span></td>
        <td><span style="color: red">11</span></td>
        <td>12</td>
    </tr>
</table>
    然后删除V6以及它的边
<canvas id="myCanvas50" width="400" height="300" style="border:1px solid #000;"></canvas>
<script>
var canvas = document.getElementById('myCanvas50');
var context = canvas.getContext('2d');

// 定义图的顶点
var vertices = [
    { x: 50, y: 150, label: 'V1' },
    { x: 150, y: 50, label: 'V2' },
    { x: 150, y: 250, label: 'V3' },
    { x: 250, y: 50, label: 'V4' },
    { x: 250, y: 250, label: 'V5' },
];

// 定义图的边和权重
var edges = [
    { start: vertices[0], end: vertices[1], weight: 'a=2' },
    { start: vertices[0], end: vertices[2], weight: 'b=5' },
    { start: vertices[1], end: vertices[3], weight: 'd=3' },
    { start: vertices[1], end: vertices[2], weight: 'c=1' },
    { start: vertices[2], end: vertices[3], weight: 'e=3' },
    { start: vertices[2], end: vertices[4], weight: 'f=4' },
    { start: vertices[3], end: vertices[4], weight: 'h=1' },


];

// 绘制顶点
vertices.forEach(function(vertex) {
    context.beginPath();
    context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
    context.fillStyle = 'lightblue';
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '14px Arial';
    context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
});

// 绘制带箭头的边和权重
edges.forEach(function(edge) {
    context.beginPath();
    context.moveTo(edge.start.x, edge.start.y);
    context.lineTo(edge.end.x, edge.end.y);
    context.strokeStyle = 'red';
    context.lineWidth = 0.5;
    context.stroke();

    // 绘制箭头
    context.beginPath();
    context.moveTo(edge.end.x, edge.end.y);
    var angle = Math.atan2(edge.start.y - edge.end.y, edge.start.x - edge.end.x);
    context.lineTo(edge.end.x + 8 * Math.cos(angle - Math.PI / 6), edge.end.y + 8 * Math.sin(angle - Math.PI / 6));
    context.lineTo(edge.end.x + 8 * Math.cos(angle + Math.PI / 6), edge.end.y + 8 * Math.sin(angle + Math.PI / 6));
    context.closePath();
    context.fillStyle = 'black';
    context.fill();

    // 绘制边权重标签
    var weightX = (edge.start.x + edge.end.x) / 2;
    var weightY = (edge.start.y + edge.end.y) / 2;
    context.fillStyle = 'red';
    context.font = '12px Arial';
    context.fillText(edge.weight, weightX, weightY);
});
</script>
接下来不多讲了，以此类推最终的表就是
        <table>
    <tr>
        <th></th>
        <th>V1</th>
        <th>V2</th>
        <th>V3</th>
        <th>V4</th>
         <th>V5</th>
         <th>V6</th>
    </tr>
    <tr>
        <td>Ve</td>
        <td class="center">0</td>
        <td>2</td>
        <td>5</td>
        <td>8</td>
        <td>9</td>
        <td>12</td>
    </tr>
    <tr>
        <td>Vl</td>
        <td class="center">0</td>
        <td class="center">4</td>
        <td>5</td>
        <td>8</td>
        <td>11</td>
        <td>12</td>
    </tr>
</table>
求出来这个表格是活动的最早最晚开始时间，我们要求事件，的最早和最晚，再画一个表格
      <table>
    <tr>
        <th></th>
        <th>最早</th>
        <th>最晚</th>
    </tr>
    <tr>
        <td>a</td>
        <td class="center"></td>
        <td></td>
    </tr>
    <tr>
        <td>b</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>c</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>d</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>e</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>f</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>j</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>h</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>i</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>j</td>
        <td class="center"></td>
        <td class="center"></td>
    </tr>
</table>
事件是边，事件的最早时间就是前面一个点的最早开始时间
      <table>
    <tr>
        <th></th>
        <th>最早</th>
        <th>最晚</th>
    </tr>
    <tr>
        <td>a</td>
        <td class="center">0</td>
        <td></td>
    </tr>
    <tr>
        <td>b</td>
        <td class="center">0</td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>c</td>
        <td class="center">2</td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>d</td>
        <td class="center">2</td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>e</td>
        <td class="center">5</td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>f</td>
        <td class="center">5</td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>j</td>
        <td class="center">5</td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>h</td>
        <td class="center">8</td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>i</td>
        <td class="center">8</td>
        <td class="center"></td>
    </tr>
              <tr>
        <td>j</td>
        <td class="center">9</td>
        <td class="center"></td>
    </tr>
</table>
    那最晚怎么算，用点的最晚开始时间减去前面边(事件)的时间
    <table>
    <tr>
        <th></th>
        <th>最早</th>
        <th>最晚</th>
    </tr>
    <tr>
        <td>a</td>
        <td class="center">0</td>
        <td>2</td>
    </tr>
    <tr>
        <td>b</td>
        <td class="center">0</td>
        <td class="center">0</td>
    </tr>
              <tr>
        <td>c</td>
        <td class="center">2</td>
        <td class="center">4</td>
    </tr>
              <tr>
        <td>d</td>
        <td class="center">2</td>
        <td class="center">5</td>
    </tr>
              <tr>
        <td>e</td>
        <td class="center">5</td>
        <td class="center">5</td>
    </tr>
              <tr>
        <td>f</td>
        <td class="center">5</td>
        <td class="center">7</td>
    </tr>
              <tr>
        <td>j</td>
        <td class="center">5</td>
        <td class="center">11</td>
    </tr>
              <tr>
        <td>h</td>
        <td class="center">8</td>
        <td class="center">10</td>
    </tr>
              <tr>
        <td>i</td>
        <td class="center">8</td>
        <td class="center">8</td>
    </tr>
              <tr>
        <td>j</td>
        <td class="center">9</td>
        <td class="center">11</td>
    </tr>
</table>
每个事件的时间余量就是最晚-最早，拿f来讲7-5=2，也就是2天
<table>
    <tr>
        <th></th>
        <th>最早</th>
        <th>最晚</th>
    </tr>
    <tr>
        <td>a</td>
        <td class="center">0</td>
        <td>2</td>
    </tr>
    <tr>
        <td>b</td>
        <td class="center"><span style="color: red">0</span></td>
        <td class="center"><span style="color: red">0</span></td>
    </tr>
              <tr>
        <td>c</td>
        <td class="center">2</td>
        <td class="center">4</td>
    </tr>
              <tr>
        <td>d</td>
        <td class="center">2</td>
        <td class="center">5</td>
    </tr>
              <tr>
        <td>e</td>
        <td class="center"><span style="color: red">5</span></td>
        <td class="center"><span style="color: red">5</span></td>
    </tr>
              <tr>
        <td>f</td>
        <td class="center">5</td>
        <td class="center">7</td>
    </tr>
              <tr>
        <td>j</td>
        <td class="center">5</td>
        <td class="center">11</td>
    </tr>
              <tr>
        <td>h</td>
        <td class="center">8</td>
        <td class="center">10</td>
    </tr>
              <tr>
        <td>i</td>
        <td class="center"><span style="color: red">8</span></td>
        <td class="center"><span style="color: red">8</span></td>
    </tr>
              <tr>
        <td>j</td>
        <td class="center">9</td>
        <td class="center">11</td>
    </tr>
</table>
    看我标红的，最晚和最早时间是一样的，也就是关键路径，一天都不能少
</pre>
    </div>
    <div class="block">
        <h1>查找</h1>
<h2>顺序查找、折半查找、分块查找</h2>
<pre>
<span style="color: red;font-size: 20px">顺序查找</span>对<span style="color: green">顺序表</span>和<span style="color: green">链表</span>适用
<span style="color: #00feff">一般线性表的顺序查找</span>
等概率：ASL(成功)=(n+1)/2
不等概率：概率*该点的查找长度---------举例子：长度为3，1的概率是2，2的概率是1，3的概率是9，ASL=1*2+2*1+3*9
等概率：ASL(不成功)=n+1
<span style="color: #00feff">有序线性表的顺序查找</span>
ASL成功与一般无异
ASL不成功=n/2+n/(n+1)
<span style="color: red;font-size:20px">折半查找(二分查找)</span>只适用<span style="color: green">有序</span>的<span style="color: red">顺序表</span>，不适合链表
具体过程如下，挺简单的，值得注意的是，指针的移动是多一位或者，少一位的，因为你看1到6没有，那肯定把指针移到比1小如0，或者比6大如7，而不是1和6这边界
为什么不是？给你10个有序摆放的屎找出是你拉的
你一开始找的是第1个到第5个
没找到，结果第二次找，是第5个到第10个
你说滑稽吗？明明你也很爱我，我也很爱你，没结果~
🙂明明第一轮已经看过了第5个了，干嘛第二轮还要看，你说呢
<hr>
<span style="color: #00daff">对{5,13,17,29,37,41,61,79,89}利用折半查找值为29的元素</span>
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="100" font-size="12" text-anchor="middle" >↑</text>
        <text x="160" y="100" font-size="12" text-anchor="middle">↑</text>
        <text x="260" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="110" font-size="12" text-anchor="middle" >low</text>
        <text x="160" y="110" font-size="12" text-anchor="middle">mid</text>
        <text x="260" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>
我们规定了首尾都有一个指针，其次mid的指针由下面式子给出
    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>0</mn><mo>+</mo><mn>8</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>4</mn></mrow></math></span>
是的，折半的想法，此时mid指向的值为<span style="color: red">37</span>比我们要找的值29大
这就是说明我们的中间的指针是比这个大的(😏废话)
所以我们把高指针的指向重新定义为mid(中间指针)的<span style="color: red">前一个</span>
如果你对为什么是前一个没有疑虑，那么你很聪明
因为我们比较的就是中间指针肯定是要么大要么小，如果相同的就结束了啊
所以这个相当于不属于我们下一次查找的范围了

<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="100" font-size="12" text-anchor="middle" >↑</text>
        <text x="85" y="100" font-size="12" text-anchor="middle">↑</text>
        <text x="135" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="110" font-size="12" text-anchor="middle" >low</text>
        <text x="85" y="110" font-size="12" text-anchor="middle">mid</text>
        <text x="135" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>

    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>0</mn><mo>+</mo><mn>3</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>1</mn></mrow></math></span>(向下取整)
mid指向的是13，比29小，我们把low(小)指针改为mid(中间指针)的后面一个
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="110" y="100" font-size="12" text-anchor="middle" >↑</text>
        <text x="110" y="130" font-size="12" text-anchor="middle">↑</text>
        <text x="135" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="110" y="110" font-size="12" text-anchor="middle" >low</text>
        <text x="110" y="140" font-size="12" text-anchor="middle">mid</text>
        <text x="135" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>

    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mo>+</mo><mn>3</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>2</mn></mrow></math></span>(向下取整)
此时mid指向的是17还是比29小，于是把low指针指向mid的下一个
<svg width="400" height="200" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="135" y="160" font-size="12" text-anchor="middle" >↑</text>
        <text x="135" y="130" font-size="12" text-anchor="middle">↑</text>
        <text x="135" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="135" y="170" font-size="12" text-anchor="middle" >low</text>
        <text x="135" y="140" font-size="12" text-anchor="middle">mid</text>
        <text x="135" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>
    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>3</mn><mo>+</mo><mn>3</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>3</mn></mrow></math></span>
bingo！mid指向29，刚好是我们要找的，好吧，麻烦是麻烦了点
但是编程实现起来比其他简单啊🤨
<hr>
思考一个问题，折半查找的过程能不能用一棵树来表示
给你一个序列：7  10  13  16  19  29  32  33  37  41  43
<canvas id="myCanvas60" width="800" height="400"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas60');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 350, y: 25, label:'29' },
        { x: 150, y: 100,label:'13' },
        { x: 500, y: 100,label:'37' },
        { x: 50, y: 175,label:'7' },
        { x: 200, y: 175, label:'16' },
        { x: 350, y: 175, label:'32' },
        { x: 550, y: 175,label:'41' },
        { x: 80, y: 250,label:'10' },
        { x: 230, y: 250,label:'19' },
        { x: 380, y: 250,label:'33' },
        { x: 580, y: 250,label:'43' },

        { x: 20, y: 200,label:'失败' },
        { x: 180, y: 200,label:'失败' },
        { x: 330, y: 200,label:'失败' },
        { x: 530, y: 200,label:'失败' },
        { x: 50, y: 300,label:'失败' },
        { x: 110, y: 300,label:'失败' },
        { x: 200, y: 300,label:'失败' },
        { x: 260, y: 300,label:'失败' },
        { x: 350, y: 300,label:'失败' },
        { x: 410, y: 300,label:'失败' },
        { x: 550, y: 300,label:'失败' },
        { x: 610, y: 300,label:'失败' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[5] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[3], end: vertices[11] },
        { start: vertices[3], end: vertices[7] },
        { start: vertices[4], end: vertices[12] },
        { start: vertices[4], end: vertices[8] },
        { start: vertices[5], end: vertices[13] },
        { start: vertices[5], end: vertices[9] },
        { start: vertices[6], end: vertices[14] },
        { start: vertices[6], end: vertices[10] },
        { start: vertices[7], end: vertices[15] },
        { start: vertices[7], end: vertices[16] },
        { start: vertices[8], end: vertices[17] },
        { start: vertices[8], end: vertices[18] },
        { start: vertices[9], end: vertices[19] },
        { start: vertices[9], end: vertices[20] },
        { start: vertices[10], end: vertices[21] },
        { start: vertices[10], end: vertices[22] },




    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '15px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
看到这个图，注意没有，每一个根结点就我们每次的中间指针
并且，这个树的中序遍历是一个升序的，是一棵平衡二叉树
平均查找长度ASL=log₂(n+1)-1
树高h=[log₂(n+1)]//向上取整
折半查找的时间复杂度=O(log₂n)
在如图中的查找成功的ASL=（1*1+2*2+3*4+4*4）/10=3
查找不成功的ASL=（3*4+4*8）/12=11/3
为什么？看第一层1个，第二层两个，每一层代表查找几次
即第一层1个并且查找一次=1*1
第二层2个并且查找两次=2*2
....
看不成功的
第三层有4个不成功=3*4
第四层有8个不成功=4*8
为什么它看起来失败的在第四层，而我说第三层呢？
你是不是傻瓜，失败那个点需要找吗？你找到7，还比7小，往左子树走，没有东西了，不需要比较了，可不就是3层
<span style="color: red;font-size:20px">分块查找</span>
它结合了顺序查找和折半查找的优点
什么意思？
看下面给定序列
88 24 72 61 21 6 32 11 8 31 22 83 78 54
我们建立一个索引表
|24|54|78|88|
|1 |7 |10|13|    这是当前数在查找表中的位置
我们把序列简单构成查找表
|24|21|6|11|8|22|32|31|54|72|61|78|88|83|
  ↑             ↑       ↑       ↑
  24             54       78       88
为什么？难道你不奇怪吗？凭什么，四个索引是怎么来的？
你凭什么这么分，当我是傻子吗？
很好，我们分的依据第一个是根号（总数）
也就是对总个数求开方，对14求开方就是，就是不知道🤣
3到4之间，我们分4块，我知道你想问为什么不分3块，考试的时候脑袋一抽分3块怎么办？
不怎么办，你取3块就取3块呗，怎么地，厕所五个坑，想去哪里去哪里，我选第一个就是社牛，第5个就是社恐了？
分为4块以后，选择合适的数作为分块的边界，54指向32是因为32是22后面第一个比24大的
你可以简单的看到，就算索引表是有序的，但是查找表的<span style="color: red">分块</span>是无序的
分块查找的ASL=L(索引表查找长度)+L(查找表的查找长度)=(b+1)/2+(s+1)/2
为什么是(b+1)/2首先这是顺序查找，顺序查找的等概率是长度除上个数[(b+1)×n]/2 × 1/n = (b+1)/2
例如我们找6，首先在索引表中找，4个，（4+1）/2=2.5
然后在24-54这个查找表分块中找
有6个，（6+1）/2=3.5
所以ASL=2.5+3.5=6
假如一个序列有n个值，我们索引表分多少块比较好？
√n次（啊呀，就是根号n啊）
</pre>
<h2>二叉排序树、二叉平衡树、红黑树(头疼，不讲)</h2>
<pre>
<span style="color: red;font-size: 20px">二叉排序树（二叉查找树）</span>
左子树 < 根 < 右子树
这里重点介绍<span style="color: red">构建</span>和<span style="color: red">删除</span>，会构建就会插入，查找
构建给你一个序列：100 80 90 60 120 110 130
<canvas id="myCanvas61" width="400" height="50"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas61');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'100' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
再放入80，80比100小，进入左子树
<canvas id="myCanvas62" width="400" height="100"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas62');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'100' },
        { x: 150, y: 75, label:'80' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
再看90，比100小进入左子树，再比较80，比80大，进入80的右子树
<canvas id="myCanvas63" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas63');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'100' },
        { x: 150, y: 75, label:'80' },
        { x: 200, y: 125, label:'90' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[1], end: vertices[2] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
再看60，比100小，进左子树，比80小进入80的左子树
<canvas id="myCanvas64" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas64');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'100' },
        { x: 150, y: 75, label:'80' },
        { x: 200, y: 125, label:'90' },
        { x: 100, y: 125, label:'60' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
再看120比100大进入右子树
<canvas id="myCanvas65" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas65');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'100' },
        { x: 150, y: 75, label:'80' },
        { x: 200, y: 125, label:'90' },
        { x: 100, y: 125, label:'60' },
        { x: 350, y: 75, label:'120' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[0], end: vertices[4] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
再看110，比100大进入右子树，比120小，进入120的左子树
<canvas id="myCanvas66" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas66');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'100' },
        { x: 150, y: 75, label:'80' },
        { x: 200, y: 125, label:'90' },
        { x: 100, y: 125, label:'60' },
        { x: 350, y: 75, label:'120' },
        { x: 320, y: 125, label:'110' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[0], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
再看130，比100大进入右子树，比120还大进入120的右子树
<canvas id="myCanvas67" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas67');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'100' },
        { x: 150, y: 75, label:'80' },
        { x: 200, y: 125, label:'90' },
        { x: 100, y: 125, label:'60' },
        { x: 350, y: 75, label:'120' },
        { x: 320, y: 125, label:'110' },
        { x: 370, y: 125, label:'130' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[0], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
结束
<hr>
我们来看删除
叶子结点直接pass无所谓，如果我们删除120这个结点怎么办？
两种，让直接后继代替，或者直接前驱代替
<canvas id="myCanvas68" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas68');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'100' },
        { x: 150, y: 75, label:'80' },
        { x: 200, y: 125, label:'90' },
        { x: 100, y: 125, label:'60' },
        { x: 350, y: 75, label:'130' },
        { x: 320, y: 125, label:'110' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[0], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
或者
<canvas id="myCanvas69" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas69');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'100' },
        { x: 150, y: 75, label:'80' },
        { x: 200, y: 125, label:'90' },
        { x: 100, y: 125, label:'60' },
        { x: 350, y: 75, label:'110' },
        { x: 370, y: 125, label:'130' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[1], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[0], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
<span style="color: red;font-size: 20px">平衡二叉树（AVL树）</span>
任意结点的左右子树高度差的绝对值不超过1
定义左子树和右子树高度差为该结点的<span style="color: red">平衡因子</span>
并且平衡因子的值只能为-1，0，1
---------------------------------
LL型：失衡结点在左子树左孩子上
    办法：以平衡因子结点右旋//注意区别失衡结点和平衡因子结点
---------------------------------
RR型：失衡在右子树的右孩子上
    办法：以平衡因子结点左旋
---------------------------------
LR：失衡在左子树的右孩子上
    办法：左旋平衡因子结点的左孩子，在右旋平衡因子结点
---------------------------------
RL：失衡在右子树的左孩子上
    办法：右旋右孩子再左旋
---------------------------------
现在到了喜闻乐见的举例子环节，什么？不喜欢，拉到🤣
给定关键字序列{15,3,7,10,9,8}构造一棵平衡二叉树
<canvas id="myCanvas70" width="400" height="70"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas70');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'' },
    ];

    // 定义图的边
    var edges = [
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
一开始是一棵空树，然后我们加入15
<canvas id="myCanvas71" width="400" height="70"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas71');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'15' },

    ];

    // 定义图的边
    var edges = [
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
然后加入3，因为3比15小，加入15的左子树
<canvas id="myCanvas72" width="400" height="100"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas72');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'15' },
        { x: 150, y: 75, label:'3' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
再加入7，比15小加入左子树，比3大，加入3的右子树
<canvas id="myCanvas73" width="400" height="150"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas73');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'15' },
        { x: 150, y: 75, label:'3' },
        { x: 200, y: 110, label:'7' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[1], end: vertices[2] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
现在我们看三个结点的平衡因子，15的，左右子树高度差是不是2-0=2.为什么是2，你要把左子树当成整体看
然后3的左右子树高度差是0-1=-1
然后7的左右子树高度差是0-0=0
失衡结点是（7），因为是（7）造成的，然后失衡因子是2也就是结点（15）
失衡节点是在左子树的右孩子，也就是LR
先左旋左孩子，再右旋
我们看看左旋左孩子怎么做
<canvas id="myCanvas74" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas74');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 25, label:'15' },
        { x: 150, y: 150, label:'3' },
        { x: 200, y: 110, label:'7' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[1], end: vertices[2] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
我们再右旋平衡因子结点
<canvas id="myCanvas75" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas75');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 150, label:'15' },
        { x: 150, y: 150, label:'3' },
        { x: 200, y: 110, label:'7' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[1], end: vertices[2] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
然后连线
<canvas id="myCanvas76" width="400" height="200"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas76');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 150, label:'15' },
        { x: 150, y: 150, label:'3' },
        { x: 200, y: 110, label:'7' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[1], end: vertices[2] },
        { start: vertices[0], end: vertices[2] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
然后再插入我们的10，因为10比7大，进入右子树，然后比15小，进入15的左子树
<canvas id="myCanvas77" width="400" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas77');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 150, label:'15' },
        { x: 150, y: 150, label:'3' },
        { x: 200, y: 110, label:'7' },
        { x: 250, y: 200, label:'10' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[1], end: vertices[2] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[0], end: vertices[3] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
这个时候也没有失衡，我们就继续插入9，因为9比7大，进入右子树，比15小进入15的左，比10小，进入10的左
<canvas id="myCanvas78" width="400" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas78');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 150, label:'15' },
        { x: 150, y: 150, label:'3' },
        { x: 200, y: 110, label:'7' },
        { x: 250, y: 200, label:'10' },
        { x: 200, y: 250, label:'9' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[1], end: vertices[2] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[0], end: vertices[3] },
        { start: vertices[4], end: vertices[3] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
好，开始失衡了，因为（7）的左右子树高度差=1-3=-2
但是你看15的平衡因子=2-0=2，我们找的是最小的树的不平衡因子
9是在15树的左子树的孩子上
即LL，以15为核心，右旋
<canvas id="myCanvas79" width="400" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas79');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 250, label:'15' },
        { x: 150, y: 150, label:'3' },
        { x: 200, y: 110, label:'7' },
        { x: 250, y: 200, label:'10' },
        { x: 200, y: 250, label:'9' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[1], end: vertices[2] },
        { start: vertices[0], end: vertices[3] },
        { start: vertices[4], end: vertices[3] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
再连线
<canvas id="myCanvas80" width="400" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas80');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 250, label:'15' },
        { x: 150, y: 150, label:'3' },
        { x: 200, y: 110, label:'7' },
        { x: 250, y: 200, label:'10' },
        { x: 200, y: 250, label:'9' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[1], end: vertices[2] },
        { start: vertices[0], end: vertices[3] },
        { start: vertices[4], end: vertices[3] },
        { start: vertices[2], end: vertices[3] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
我们再插入8，因为8比7大，进入右子树，8比10小进入10的左子树，8比9小再进入9的左子树
<canvas id="myCanvas81" width="400" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas81');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 200, label:'15' },
        { x: 150, y: 100, label:'3' },
        { x: 200, y: 60, label:'7' },
        { x: 250, y: 150, label:'10' },
        { x: 200, y: 200, label:'9' },
        { x: 150, y: 250, label:'8' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[1], end: vertices[2] },
        { start: vertices[0], end: vertices[3] },
        { start: vertices[4], end: vertices[3] },
        { start: vertices[2], end: vertices[3] },
        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
此时，（7）的平衡因子是1-3=-2，（10）的平衡因子是2-1=1
只有（7）是不平衡的，而（8）在（7）的右子树的左孩子上
即RL型，先右旋右孩子，再左旋
<canvas id="myCanvas82" width="400" height="400"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas82');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 300, label:'15' },
        { x: 150, y: 100, label:'3' },
        { x: 200, y: 60, label:'7' },
        { x: 250, y: 250, label:'10' },
        { x: 200, y: 200, label:'9' },
        { x: 150, y: 250, label:'8' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[1], end: vertices[2] },
        { start: vertices[0], end: vertices[3] },
        { start: vertices[4], end: vertices[3] },

        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
这个时候，（7）的左旋是指将（7）作为9的左孩子，但是9已经有了怎么办？就将9的孩子抢过来当成自己的右孩子
<canvas id="myCanvas83" width="400" height="250"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas83');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 200, label:'15' },
        { x: 100, y: 200, label:'3' },
        { x: 200, y: 200, label:'8' },
        { x: 250, y: 150, label:'10' },
        { x: 200, y: 100, label:'9' },
        { x: 150, y: 150, label:'7' },
    ];

    // 定义图的边
    var edges = [

        { start: vertices[0], end: vertices[3] },
        { start: vertices[4], end: vertices[3] },
        { start: vertices[5], end: vertices[2] },
        { start: vertices[5], end: vertices[1] },
        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
完结撒花
二叉平衡树的<span style="color: red;font-size: 20px">删除</span>怎么办？
<canvas id="myCanvas84" width="400" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas84');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 200, label:'88' },
        { x: 180, y: 200, label:'32' },
        { x: 250, y: 150, label:'78' },
        { x: 200, y: 100, label:'44' },
        { x: 150, y: 150, label:'17' },
        { x: 220, y: 200, label:'50' },
        { x: 180, y: 250, label:'48' },
        { x: 260, y: 250, label:'62' },
    ];

    // 定义图的边
    var edges = [

        { start: vertices[0], end: vertices[3] },
        { start: vertices[4], end: vertices[3] },
        { start: vertices[5], end: vertices[2] },
        { start: vertices[4], end: vertices[1] },
        { start: vertices[6], end: vertices[5] },
        { start: vertices[7], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
假如我们删除32这个结点，删除节点方法和排序二叉树一样，然后才是使用平衡二叉树的方法整合为平衡二叉树
32是叶子结点直接删除
<canvas id="myCanvas85" width="400" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas85');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 200, label:'88' },
        { x: 250, y: 150, label:'78' },
        { x: 200, y: 100, label:'44' },
        { x: 150, y: 150, label:'17' },
        { x: 220, y: 200, label:'50' },
        { x: 180, y: 250, label:'48' },
        { x: 260, y: 250, label:'62' },
    ];

    // 定义图的边
    var edges = [

        { start: vertices[2], end: vertices[1] },
        { start: vertices[2], end: vertices[3] },
        { start: vertices[1], end: vertices[0] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
删除和插入构建很大的不同就是你不能通过肉眼简单的看出来是什么型
只能通过编程的思想，程序是如何判断的呢？就是靠平衡因子
（44）的平衡因子是-2，（78）的平衡因子是1，所以就是RL型
为什么？-2是因为左减右，为负，所以右大于左，所以不平衡一定在右中
1是正数，所以左大于右，所以不平衡在左中
合起来就是右左RL
好，用我教你的方法以（44）为基础，执行RL变换
<canvas id="myCanvas86" width="400" height="400"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas86');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 300, label:'88' },
        { x: 220, y: 300, label:'62' },
        { x: 200, y: 100, label:'44' },
        { x: 150, y: 150, label:'17' },
        { x: 220, y: 200, label:'50' },
        { x: 180, y: 250, label:'48' },
        { x: 260, y: 250, label:'78' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[6], end: vertices[0] },
        { start: vertices[6], end: vertices[1] },
        { start: vertices[2], end: vertices[3] },


        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
然后（44）再左旋，因为（50）有左孩子了，所以抢过来当右孩子，（44）再自己当（50）左孩子
<canvas id="myCanvas87" width="400" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas87');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 300, y: 200, label:'88' },
        { x: 220, y: 200, label:'62' },
        { x: 180, y: 200, label:'48' },
        { x: 150, y: 200, label:'17' },
        { x: 220, y: 100, label:'50' },
        { x: 180, y: 150, label:'44' },
        { x: 260, y: 150, label:'78' },
    ];

    // 定义图的边
    var edges = [
        { start: vertices[6], end: vertices[0] },
        { start: vertices[6], end: vertices[1] },
        { start: vertices[5], end: vertices[2] },
        { start: vertices[5], end: vertices[3] },

        { start: vertices[4], end: vertices[5] },
        { start: vertices[4], end: vertices[6] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '10px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd></mtd><mtd><msub><mi>n</mi><mi>h</mi></msub><mo>表示深度为</mo><mi>h</mi><mo>的平衡二叉树中含有最少结点数</mo></mtd></mtr><mtr><mtd></mtd><mtd><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>n</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><mn>2</mn></mtd></mtr><mtr><mtd></mtd><mtd><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mn>1</mn></mtd></mtr></mtable></math>
咋地，以上公式不以为意是吧，反正我突然摆出来，莫名其妙的，懒得看就是说
那我问你：具有5层结点的AVL至少有多少个结点？12个
AVL不是AV，是平衡二叉树😡
</pre>
<h2><span style="color: red">B</span>、B+树</h2>
        <pre>
m阶B树是所有结点平衡因子均为0的m路平衡查找树
<span style="color: red">重要性质</span>
m阶B树最多m个分支，m-1个元素
m阶B树最少[m/2]个分支，[m/2]-1个元素，向上取整。注意根例外，根最少2个分支，1个元素
<span style="color: #00ffa6">三个特性</span>
平衡：所有叶子都在同一层
有序：结点内有序排列，结点外呢，按照排序树一样，左小右大
多路
<canvas id="myCanvas100" width="800" height="300"></canvas>
    <script>
        var canvas = document.getElementById('myCanvas100');
        var context = canvas.getContext('2d');

        // 定义图的顶点
        var vertices = [
            { x: 250, y: 50, label: '            22' },
            { x: 150, y: 100, label: '5                  11' },
            { x: 400, y: 100, label: '36                 45' },
            { x: 50, y: 175, label: '1                   3' },
            { x: 150, y: 175, label: '  6        8        9' },
            { x: 250, y: 175, label: ' 13                15' },
            { x: 350, y: 175, label: ' 30                35' },
            { x: 450, y: 175, label: ' 40                42' },
            { x: 550, y: 175, label: ' 47   48   50   56 ' },
            { x: 50, y:  225, label: '         失败' },
            { x: 150, y: 225, label: '         失败' },
            { x: 250, y: 225, label: '         失败' },
            { x: 350, y: 225, label: '         失败' },
            { x: 450, y: 225, label: '         失败' },
            { x: 550, y: 225, label: '         失败' },
        ];

        // 定义图的边
        var edges = [
            { start: { x: 245, y: 60 }, end: { x: 180, y: 80 }, weight: '' },
            { start: { x: 325, y: 60 }, end: { x: 435, y: 80 }, weight: '' },
            { start: { x: 145, y: 110 }, end: { x: 80, y: 155 }, weight: '' },
            { start: { x: 185, y: 110 }, end: { x: 185, y: 155 }, weight: '' },
            { start: { x: 225, y: 110 }, end: { x: 285, y: 155 }, weight: '' },
            { start: { x: 395, y: 110 }, end: { x: 385, y: 155 }, weight: '' },
            { start: { x: 435, y: 110 }, end: { x: 485, y: 155 }, weight: '' },
            { start: { x: 475, y: 110 }, end: { x: 585, y: 155 }, weight: '' },

            { start: { x: 45, y: 185 }, end: { x: 45, y: 205 }, weight: '' },
            { start: { x: 85, y: 185 }, end: { x: 85, y: 205 }, weight: '' },
            { start: { x: 125, y: 185 }, end: { x: 125, y: 205 }, weight: '' },

            { start: { x: 145, y: 185 }, end: { x: 145, y: 205 }, weight: '' },
            { start: { x: 170, y: 185 }, end: { x: 170, y: 205 }, weight: '' },
            { start: { x: 200, y: 185 }, end: { x: 200, y: 205 }, weight: '' },
            { start: { x: 225, y: 185 }, end: { x: 225, y: 205 }, weight: '' },

            { start: { x: 245, y: 185 }, end: { x: 245, y: 205 }, weight: '' },
            { start: { x: 285, y: 185 }, end: { x: 285, y: 205 }, weight: '' },
            { start: { x: 325, y: 185 }, end: { x: 325, y: 205 }, weight: '' },

            { start: { x: 445, y: 185 }, end: { x: 445, y: 205 }, weight: '' },
            { start: { x: 485, y: 185 }, end: { x: 485, y: 205 }, weight: '' },
            { start: { x: 525, y: 185 }, end: { x: 525, y: 205 }, weight: '' },

            { start: { x: 345, y: 185 }, end: { x: 345, y: 205 }, weight: '' },
            { start: { x: 385, y: 185 }, end: { x: 385, y: 205 }, weight: '' },
            { start: { x: 425, y: 185 }, end: { x: 425, y: 205 }, weight: '' },

            { start: { x: 545, y: 185 }, end: { x: 545, y: 205 }, weight: '' },
            { start: { x: 565, y: 185 }, end: { x: 565, y: 205 }, weight: '' },
            { start: { x: 585, y: 185 }, end: { x: 585, y: 205 }, weight: '' },
            { start: { x: 605, y: 185 }, end: { x: 605, y: 205 }, weight: '' },
            { start: { x: 625, y: 185 }, end: { x: 625, y: 205 }, weight: '' },

        ];

        // 绘制顶点
        vertices.forEach(function(vertex) {
            context.beginPath();
            context.rect(vertex.x -5, vertex.y - 20, 80, 30);
            context.fillStyle = 'lightblue';
            context.fill();
            context.stroke();

            // 绘制顶点标签
            context.fillStyle = 'black';
            context.font = '10px Arial';
            context.fillText(vertex.label, vertex.x - 1, vertex.y );
        });

        // 绘制边和权重
        edges.forEach(function(edge) {
            context.beginPath();
            context.moveTo(edge.start.x, edge.start.y);
            context.lineTo(edge.end.x, edge.end.y);
            context.strokeStyle = 'black';
            context.stroke();

            // 绘制箭头
            context.fillStyle = 'black';
            drawArrow(context, edge.start.x, edge.start.y, edge.end.x, edge.end.y);

            // 绘制边权重标签
            if (edge.weight !== undefined) {
                var weightX = (edge.start.x + edge.end.x) / 2;
                var weightY = (edge.start.y + edge.end.y) / 2;
                context.fillStyle = 'red';
                context.font = '12px Arial';
                context.fillText(edge.weight, weightX, weightY);
            }
        });

        // 绘制箭头的函数
        function drawArrow(context, x1, y1, x2, y2) {
            var angle = Math.atan2(y2 - y1, x2 - x1);
            context.lineTo(x2, y2);
            context.beginPath();
            context.moveTo(x2, y2);
            context.lineTo(x2 - 10 * Math.cos(angle - Math.PI / 6), y2 - 10 * Math.sin(angle - Math.PI / 6));
            context.lineTo(x2 - 10 * Math.cos(angle + Math.PI / 6), y2 - 10 * Math.sin(angle + Math.PI / 6));
            context.fill();
        }
    </script>
呼~~~累死我了，网页画图真的是一个个坐标点自己尝试出来的
以上就是一棵五阶B树
注意看我的<span style="color: red">箭头</span>，可不是随便指的，例如我们找16
首先比22小，去（5  11）里面
比最大的11都大，所以走（5  11）的第三个箭头
去（13  15）里面，结果比里面最大15还大，去（13  15）的第三个箭头，也就是失败，查找失败
如果说我们找10，那就是22到（5  11）然后因为比5大，比11小，所以走（5  11）的第二个箭头，还是失败
也不是说全失败啊，我们找11，可不就是11了
------------------------------------------------
<span style="color: red">B树的插入和删除</span>
<span style="color: red">插入</span>一定是插入到叶子结点
插入以后如果满足元素个数要求就直接插
插入以后如果比要求的多了，那么就分裂，这中情况是叫溢出
怎么分裂：
<span style="color: #00ebff">在插入以后的结点，从中间位置[m/2]向上取整，分成两半，左半部分不动，此点上移，右半部分分裂一个新结点</span>
太懒了，不想画图了，我贴个图又可能加载不出来咋办呢，头疼啊
<span style="color: red">删除</span>
1.如果不是叶子结点，那么删除以后用它的直接前驱或者后继上来顶替就行
如果是叶子结点三种情况：
    直接删，还是满足
    兄弟够借，左右兄弟随便一个上去，父亲下来顶替被删元素
    兄弟不够借，合并：
            左合并：此点左父下移，此点右并过来
            右合并：此点右父下移，此点左并过去
<span style="color: red;font-size: 20px">B+</span>
其他和B一样，只是<span style="color: red">结点子树的个数与此结点里面关键字个数相同</span>
B+树，除了叶子结点，都是索引，也就是说，还没有到叶子结点就找到一样的时候，并不是找到了
还要继续向下，找到叶子结点以后，还要找，找到对应的以后，叶子结点本身也是一个对应的关键字，如同
我们之前那个B树图，下面都是失败，而这个则是成功对应的记录
</pre>
<h2>散列表(哈希表)</h2>
        <pre>
 设散列表长为11，记录关键字集合为{15，17，28，41，37，31，56，23，45，51，73}，散列函数：H(Key) = key MOD 11，冲突处理采用线性探测法，请给出散列表的构造过程，再求平均查找程度ASL
(1)先看散列函数，H(Key) = Key MOD 11.(对每个数都取余，与11相除，取余)
    <table>
        <tbody>
            <tr>
                <td>余数</td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">7</span></td>
            </tr>
            <tr>
                <td>原数</td>
                <td>15</td>
                <td>17</td>
                <td>28</td>
                <td>41</td>
                <td>37</td>
                <td>31</td>
                <td>56</td>
                <td>23</td>
                <td>45</td>
                <td>51</td>
                <td>73</td>
            </tr>
        </tbody>
    </table>
(2)我们先写出一个0-10（11个）
        <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
        </tbody>
    </table>
我们规定，按照余数，放进这个表格中，如果冲突线性探测就是往后顺延一位（如果一位不行就再继续顺）
我们一步步来，把余数4对应的15放到4处
            <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">15</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
            </tr>
        </tbody>
    </table>
此时记录15到位4处动了（1）次，接着把17放到6处
                <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">15</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">17</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
            </tr>
        </tbody>
    </table>
记录17动了（1）次，接着放28，因为28是6，和之前的17冲突了，采用线性探测就是往后顺延一位
                    <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">15</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">17</span> </td>
                <td><span style="color: red">28</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
            </tr>
        </tbody>
    </table>
记录28动了（2）次，接着41放8处
                        <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">15</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red">17</span> </td>
                <td><span style="color: red">28</span> </td>
                <td><span style="color: red">41</span> </td>
                <td><span style="color: red"></span> </td>
                <td><span style="color: red"></span> </td>
            </tr>
        </tbody>
    </table>
记录41动了（1）次，接着37，与15冲突了往后顺延1位
                            <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录37动了（2）次，接着31，放9处
                                <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录31动了（1）次，接着56放1处
                                    <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录56动了（1）次，接着23放1处冲突顺延到2处
                                        <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red">23</span></td>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录23动了（2）次，接着45放1处冲突顺延到2处再冲突再顺延3处
                                            <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red">23</span></td>
                <td><span style="color: red">45</span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red"></span></td>
            </tr>
        </tbody>
    </table>
记录了45动了（3）次，接着把51放7处与28冲突顺延到8冲突到9冲突于是放到10
                                                <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red"></span></td>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red">23</span></td>
                <td><span style="color: red">45</span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red">51</span></td>
            </tr>
        </tbody>
    </table>
记录51动力4次，接着73放7处冲突，再8冲突，再9冲突，再10冲突，再0放
                                                    <table>
        <tbody>
            <tr>
                <td><span style="color: #6d02af">0</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">2</span></td>
                <td><span style="color: #6d02af">3</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">5</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">10</span></td>
            </tr>
            <tr>
                <td><span style="color: red">73</span></td>
                <td><span style="color: red">56</span></td>
                <td><span style="color: red">23</span></td>
                <td><span style="color: red">45</span></td>
                <td><span style="color: red">15</span></td>
                <td><span style="color: red">37</span></td>
                <td><span style="color: red">17</span></td>
                <td><span style="color: red">28</span></td>
                <td><span style="color: red">41</span></td>
                <td><span style="color: red">31</span></td>
                <td><span style="color: red">51</span></td>
            </tr>
        </tbody>
    </table>
以上就是表的构造过程了
    15：1次
    17：1次
    28：2次
    41：1次
    37：2次
    31：1次
    56：1次
    23：2次
    45：3次
    51：4次
    73：5次
    求ASL(平均查找程度就是将以上数加起来再除他们的总个数)
    <p>ASL= <math xmlns='http://www.w3.org/1998/Math/MathML'> <mfrac> <mrow> <mn> 1 </mn> <mo> + </mo> <mn> 1 </mn> <mo> + </mo> <mn> 2 </mn> <mo> + </mo> <mn> 1 </mn> <mo> + </mo> <mn> 2 </mn> <mo> + </mo> <mn> 1 </mn> <mo> + </mo> <mn> 1 </mn> <mo> + </mo> <mn> 2 </mn> <mo> + </mo> <mn> 3 </mn> <mo> + </mo> <mn> 4 </mn> <mo> + </mo> <mn> 5 </mn> </mrow> <mrow> <mn> 10 </mn> </mrow> </mfrac> <mo> = </mo> <mn> 2.3 </mn> </math></p>
    <span style="color: red;font-size: 25px">还有一种题目是冲突采用链地址表示法</span>
    前面求余数的步骤一样就是构造的时候采用链表的思想

    <table>
        <tbody>
            <tr>
                <td>余数</td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">6</span></td>
                <td><span style="color: #6d02af">8</span></td>
                <td><span style="color: #6d02af">4</span></td>
                <td><span style="color: #6d02af">9</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">1</span></td>
                <td><span style="color: #6d02af">7</span></td>
                <td><span style="color: #6d02af">7</span></td>
            </tr>
            <tr>
                <td>原数</td>
                <td>15</td>
                <td>17</td>
                <td>28</td>
                <td>41</td>
                <td>37</td>
                <td>31</td>
                <td>56</td>
                <td>23</td>
                <td>45</td>
                <td>51</td>
                <td>73</td>
            </tr>
        </tbody>
    </table>
    就是构造以下基表竖着的
        <table style="width: auto">
        <tbody>
            <tr style="">
                <td>0</td>
                <td>^</td>
            </tr>
            <tr>
                <td>1</td>
                <td>-></td>
                <td>56</td>
                <td>-></td>
                <td>23</td>
                <td>-></td>
                <td>45</td>
                <td>^</td>
            </tr>
            <tr>
                <td>2</td>
                <td>^</td>
            </tr>
            <tr>
                <td>3</td>
                <td>^</td>
            </tr>
            <tr>
                <td>4</td>
                <td>-></td>
                   <td>15</td>
                <td>-></td>
                   <td>37</td>
                <td>^</td>
            </tr>
            <tr>
                <td>5</td>
                <td>^</td>
            </tr>
            <tr>
                <td>6</td>
                <td>-></td>
                <td>17</td>
                <td>-></td>
                <td>28</td>
                <td>^</td>
            </tr>
            <tr>
                <td>7</td>
                <td>-></td>
                <td>51</td>
                <td>-></td>
                <td>73</td>
                <td>^</td>
            </tr>
            <tr>
                <td>8</td>
                <td>-></td>
                <td>41</td>
                <td>^</td>
            </tr>
              <tr>
                <td>9</td>
                <td>-></td>
                  <td>31</td>
                  <td>^</td>
            </tr>
              <tr>
                <td>10</td>
                <td>^</td>
            </tr>
        </tbody>
        </table>
    求ASL，就是1*第一列的个数+2*第二列的个数+3*第三列的个数...
    此题就是ASL=1*6+2*4+3*1
<hr>
散列表查找效率取决三个因素：散列函数、处理冲突、装填因子α
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>α</mi><mo>=</mo><mfrac><mrow><mo>表中记录数</mo><mi>n</mi></mrow><mrow><mo>散列表长度</mo><mi>m</mi></mrow></mfrac></math>
α越大，说明装填记录越满，发生冲突可能性越大
这里补充一个，查找失败的ASL怎么算，什么时候算查找失败？当然是碰到空地址就是查找失败了
        </pre>
    </div>
    <div class="block">
<h1>排序</h1>
<h2>排序的基本概念</h2>
<pre>
除去我写的外部排序，本节所有排序都是属于内部排序
<span style="color: red">算法的稳定性</span>
    待排序表中两个元素如果对应关键字一样，在使用某一种排序方法后，相对位置不变，则算法稳定
算法的稳定性不代表算法的好坏
    <table>
        <tbody>
            <tr>
                <td>呵呵，背吧哥们🤣🐒🫵🏿</td>
                <td><span style="color: #6d02af">最好时间复杂度</span></td>
                <td><span style="color: #6d02af">最坏时间复杂度</span></td>
                 <td><span style="color: #6d02af">平均复杂度</span></td>
                <td><span style="color: #6d02af">辅助空间复杂度</span></td>
                <td><span style="color: #6d02af">稳定性</span></td>
            </tr>
            <tr>
                <td>直接插入排序</td>
                <td>O(n)</td>
                <td>O(n²)</td>
                <td>O(n²)</td>
                <td>O(1)</td>
                <td>稳定</td>
            </tr>
            <tr>
                <td>折半插入排序</td>
                <td>O(n)</td>
                <td>O(n²)</td>
                <td>O(n²)</td>
                <td>O(1)</td>
                <td>稳定</td>
            </tr>
          <tr>
                <td>希尔</td>
                <td>O(n)</td>
                <td>O(n²)</td>
                <td>O(n的1.3次方)</td>
                <td>O(1)</td>
                <td>不稳定</td>
            </tr>
         <tr>
                <td>冒泡</td>
                <td>O(n)</td>
                <td>O(n²)</td>
                <td>O(n²)</td>
                <td>O(1)</td>
                <td>稳定</td>
            </tr>
                 <tr>
                <td>快排</td>
                <td>O(nlog₂n)</td>
                <td>O(n²)</td>
                <td>O(nlog₂n)</td>
                <td>O(1)</td>
                <td>不稳定</td>
            </tr>
                         <tr>
                <td>简单选择排序</td>
                <td>O(n²)</td>
                <td>O(n²)</td>
                <td>O(n²)</td>
                <td>O(1)</td>
                <td>不稳定</td>
            </tr>
        <tr>
                <td>堆排序</td>
                <td>O(nlog₂n)</td>
                <td>O(nlog₂n)</td>
                <td>O(nlog₂n)</td>
                <td>O(1)</td>
                <td>不稳定</td>
            </tr>
        <tr>
                <td>2路归并排序</td>
                <td>O(nlog₂n)</td>
                <td>O(nlog₂n)</td>
                <td>O(nlog₂n)</td>
                <td>O(n)</td>
                <td>稳定</td>
            </tr>
        <tr>
                <td>基数排序</td>
                <td>O(d(n+r))</td>
                <td>O(d(n+r))</td>
                <td>O(d(n+r))</td>
                <td>O(r)</td>
                <td>稳定</td>
            </tr>
        </tbody>
    </table>
</pre>
<h2>插入排序(直接插入、折半插入、希尔)</h2>
<pre>
<hr>
<span style="color: red;font-size: 20px">直插</span>
直插听起来简单，实际上确实简单
给你一个序列
{49，38，65，97，76，13，27，49}
我们会每次选一个作为比较值，例如一开始我们选择第一个49作为已经排好的数字
{<span style="color: red">（49）</span>，38，65，97，76，13，27，49}给它做上标记
然后我们选38对比我们的49，发现38比49小，直接把49往后移动一位
{，<span style="color: red">（49）</span>，65，97，76，13，27，49}因为我们是把38存放在temp临时变量中，即便49替代了原本的38也无所谓
现在继续比较发现已经没有元素了，所以把38放入，并且标记排好的序列
{<span style="color: red">（38，49）</span>，65，97，76，13，27，49}
接下来我们把65放到临时变量temp中，依次从后比较已经排好的序列
比49大，也就是比排好的序列最大都大，所以不动，将排好序列标记覆盖到65
{<span style="color: red">（38，49，65）</span>，97，76，13，27，49}
同样拿出97，比所有都大
{<span style="color: red">（38，49，65，97）</span>，76，13，27，49}
现在拿出76，发现比97小，97，往后退一位，占了76位置
{<span style="color: red">（38，49，65，，97）</span>，13，27，49}
然后比较76和65，发现比65大，所以放到65的位置+1处，也就是原本97的位置
{<span style="color: red">（38，49，65，76，97）</span>，13，27，49}
再比较13，比97小，97后退，76后退，65、49、38依次后退
{<span style="color: red">（13，38，49，65，76，97）</span>，27，49}
后面我就不说了，都是一样的，但是注意这最后一次
{<span style="color: red">（13，27，38，49，65，76，97）</span>，49}
到这里的时候，49按照以往的一样进行排序
比97、76、65都小，他们都后退，但是到49的时候，两个相等怎么办？
比它小的才后退，不然不动，也就是
{<span style="color: red">（13，27，38，49，65，76，97）</span>，<span style="color: #00ebff">49</span>}
{<span style="color: red">（13，27，38，49，<span style="color: #00ebff">49</span>，65，76，97）</span>}
相信你也看出来了，算法稳定性是指关键字一样的元素使用排序后相对位置是否改变，这里49和49的相对位置没有改变
所以直插排序是稳定算法
<hr>
<span style="color: red;font-size: 20px">折半</span>
<span style="color: #00daff">对{5,13,17,29,37,41,61,79,89}利用折半查找值为29的元素</span>
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">
        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="100" font-size="12" text-anchor="middle" >↑</text>
        <text x="160" y="100" font-size="12" text-anchor="middle">↑</text>
        <text x="260" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="110" font-size="12" text-anchor="middle" >low</text>
        <text x="160" y="110" font-size="12" text-anchor="middle">mid</text>
        <text x="260" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>
我们规定了首尾都有一个指针，其次mid的指针由下面式子给出
    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>0</mn><mo>+</mo><mn>8</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>4</mn></mrow></math></span>
是的，折半的想法，此时mid指向的值为<span style="color: red">37</span>比我们要找的值29大
这就是说明我们的中间的指针是比这个大的(😏废话)
所以我们把高指针的指向重新定义为mid(中间指针)的<span style="color: red">前一个</span>
如果你对为什么是前一个没有疑虑，那么你很聪明
因为我们比较的就是中间指针肯定是要么大要么小，如果相同的就结束了啊
所以这个相当于不属于我们下一次查找的范围了

<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="100" font-size="12" text-anchor="middle" >↑</text>
        <text x="85" y="100" font-size="12" text-anchor="middle">↑</text>
        <text x="135" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="110" font-size="12" text-anchor="middle" >low</text>
        <text x="85" y="110" font-size="12" text-anchor="middle">mid</text>
        <text x="135" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>

    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>0</mn><mo>+</mo><mn>3</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>1</mn></mrow></math></span>(向下取整)
mid指向的是13，比29小，我们把low(小)指针改为mid(中间指针)的后面一个
<svg width="400" height="150" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="110" y="100" font-size="12" text-anchor="middle" >↑</text>
        <text x="110" y="130" font-size="12" text-anchor="middle">↑</text>
        <text x="135" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="110" y="110" font-size="12" text-anchor="middle" >low</text>
        <text x="110" y="140" font-size="12" text-anchor="middle">mid</text>
        <text x="135" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>

    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mo>+</mo><mn>3</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>2</mn></mrow></math></span>(向下取整)
此时mid指向的是17还是比29小，于是把low指针指向mid的下一个
<svg width="400" height="200" xmlns="http://www.w3.org/2000/svg">


        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle" >_0_</text>
        <text x="85" y="50" font-size="12" text-anchor="middle" >_1_</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">_2_</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">_3_</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">_4_</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">_5_</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">_6_</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">_7_</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">_8_</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="12" text-anchor="middle" >5</text>
        <text x="85" y="80" font-size="12" text-anchor="middle" >13</text>
        <text x="110" y="80" font-size="12" text-anchor="middle">17</text>
        <text x="135" y="80" font-size="12" text-anchor="middle">29</text>
        <text x="160" y="80" font-size="12" text-anchor="middle">37</text>
        <text x="185" y="80" font-size="12" text-anchor="middle">41</text>
        <text x="210" y="80" font-size="12" text-anchor="middle">61</text>
        <text x="235" y="80" font-size="12" text-anchor="middle">79</text>
        <text x="260" y="80" font-size="12" text-anchor="middle">89</text>
        </g>
        <g id="loading-txt">
        <text x="135" y="160" font-size="12" text-anchor="middle" >↑</text>
        <text x="135" y="130" font-size="12" text-anchor="middle">↑</text>
        <text x="135" y="100" font-size="12" text-anchor="middle">↑</text>
        </g>
        <g id="loading-txt">
        <text x="135" y="170" font-size="12" text-anchor="middle" >low</text>
        <text x="135" y="140" font-size="12" text-anchor="middle">mid</text>
        <text x="135" y="110" font-size="12" text-anchor="middle">high</text>
        </g>
    </svg>
    <span style="color: #00aa44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>3</mn><mo>+</mo><mn>3</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>3</mn></mrow></math></span>
bingo！mid指向29，刚好是我们要找的
<span style="color: red;font-size: 20px">以上就是我们折半查找的思想</span>
可是我们说的是折半排序啊，对没错，和直接插入排序一样，每次都会构建一个部分有序序列
但是每次往后拿新的元素比较的时候，不再是从后往前一个个比，而且是采取折半查找方法定位元素位置
定位以后，该元素+1位置直到我们新的元素位置的所有元素都后移一位
然后把新的元素插入到该元素+1位置，是不是很抽象，我有时候挺无奈的
因为我确实觉得这样说，是很清晰的，但是这是基于我本身是十分了解的前提下
但是很多人是没有我这样的基础的，也就说，这是一种自我陶醉
所以说这是一个稳定的算法，因为只有比它小的才会往前面放
注意折半查找用在已经排好序的里面，从后面依次选一个进行查找，然后查找位置插入
<hr>
<span style="color: red;font-size: 20px">希尔</span>
<span style="color: #00daff">利用希尔排序对关键字系列{40，24，80，39，43，18，20，10，90，70}从小到大排序(增量5，3，1)</span>
    增量的意思就是每个x个为一个组比较大小
    当增量为5时
    <span style="color: red">40</span>，24，80，39，43，<span style="color: red">18</span>，20，10，90，70
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，80，39，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，10，90，70
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，39，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，90，70
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，<span style="color: #00feff"> 39</span>，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，<span style="color: #00feff">90</span>，70
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，<span style="color: #00feff"> 39</span>，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，<span style="color: #00feff">90</span>，70
    最终我们得出增量为5的分组（颜色不同来区分）
    <span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，<span style="color: #00feff"> 39</span>，43，<span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，<span style="color: #00feff">90</span>，70
    （把小的放前，大的放后就行）
    <span style="color: red">18</span>，<span style="color: #00aa44">20</span>，<span style="color: #007dff">10</span>，<span style="color: #00feff"> 39</span>，43，<span style="color: red">40</span>，<span style="color: #00aa44">24</span>，<span style="color: #007dff">80</span>，<span style="color: #00feff">90</span>，70
    就是以上的第一次增量，当增量为3的时候
    <span style="color: red">18</span>，<span style="color: blueviolet">20</span>, 39，<span style="color: red">43</span>，<span style="color: blueviolet">40</span>，24，<span style="color: red">80</span>，<span style="color: blueviolet">90</span>，70
    <span style="color: red">18</span>，<span style="color: blueviolet">20</span>, 24，<span style="color: red">43</span>，<span style="color: blueviolet">40</span>，39，<span style="color: red">80</span>，<span style="color: blueviolet">90</span>，70
    完成，以下是增量为1的
    18，20, 24，43，40，39，80，90，70
    18，20，24，39，40，43，70，80，90
    完成
咋，我说完成就完成了？这就是你完全把自己托付给别人了
算法稳定性呢？怎么看？这是一个不稳定的算法，因为你选取的比较有可能导致呢，两个相同元素的相对位置发生变换
因为不是依次比较的，反正你知道大概原理就行
<hr>
</pre>
<h2>交换排序(冒泡排序、快速排序)</h2>
<pre>
<hr>
<span style="color: red;font-size: 20px">冒泡</span>
每轮从前往后依次比较相邻两个元素大小，小放前大放后，相等不动，每轮可以选出一个最大的放在最后一个位置
{36，27，20，60，55，7，28，36，52，44，16}
比较36和27，27放前，36放后
{27，36，20，60，55，7，28，36，52，44，16}
比较36和20，20放前，36放后
{27，20，36，60，55，7，28，36，52，44，16}
比较36和60，60比36大，不动
{27，20，36，60，55，7，28，36，52，44，16}
比较60和55，55放前
{27，20，36，55，60，7，28，36，52，44，16}
然后不说了
{27，20，36，55，7，60，28，36，52，44，16}
{27，20，36，55，7，28，60，36，52，44，16}
{27，20，36，55，7，28，36，60，52，44，16}
{27，20，36，55，7，28，36，52，60，44，16}
{27，20，36，55，7，28，36，52，44，60，16}
{27，20，36，55，7，28，36，52，44，16，<span style="color: red">60</span>}
以上就是第一轮比较次数 ，后面的几轮以此类推
<hr>
<span style="color: red;font-size: 20px">快排</span>
<span style="color: #00daff">对{46，58，15，45，90，18，10，62}进行快速排序</span>
    以第一个数为基准提出来
        ___  58  15  45  90  18  10  62
        ___  58  15  45  90  18  10  62<--
    <span style="color: #00aa44">这时候比较最后一个数与第一个数46的大小，62>46(不动)</span>
        ___  58  15  45  90  18  10<--  62
    <span style="color: #00aa44">这时候比较向前移动一位比较10和46大小，10<46(将10移动到46原本在的第一位)</span>
        10  58  15  45  90  18  ___  62
    <span style="color: #00aa44">这个时候比较的指向是从前面也就是10的后面开始</span>
        10  58<--  15  45  90  18  ___  62
    <span style="color: #00aa44">58>46(将58移动到10原本的位置)</span>
        10  ___  15  45  90  18  58  62
    <span style="color: #00aa44">这时候再从后面也就是58的前面</span>
        10  ___  15  45  90  18<--  58  62
    <span style="color: #00aa44">18<46(移动到58原本所在的前面)</span>
        10  18  15  45  90  ___  58  62
    <span style="color: #00aa44">再从18的后面开始比较</span>
        10  18  15<--  45  90  ___  58  62
    <span style="color: #00aa44">15<46(不动)</span>
        10  18  15  45<--  90  ___  58  62
    <span style="color: #00aa44">45<46(不动)</span>
        10  18  15  45  90<--  ___  58  62
    <span style="color: #00aa44">90>46(移动到后面的空位去)</span>
        10  18  15  45  ___  90  58  62
    <span style="color: #00aa44">到此为止全部元素都和46比较过了，于是把46放到空位处</span>
        10  18  15  45  <span style="color: red">46</span>  90  58  62
    <span style="color: #00aa44">此时46的位置已经确定了，46所在的位置就是这里，你可能也感觉出来了，这一轮比较就是把比46小的一股脑丢46前面，比46大的一股脑丢到后面去</span>
    <span style="color: #00aa44">既然46确定了，只需要比较两块内容就行了，也就是46前面的，和46后面的就行，还是按照之前的方法</span>
        ___  18  15  45<--  <span style="color: red">46</span>  ___  58   62<--
    <span style="color: #00aa44">哈哈哈，开启双开模式，前面提10，后面提90</span>
    <span style="color: #00aa44">45>10(不动);62<90(动)</span>
        10  18  15<--  45  <span style="color: red">46</span>  62  58<--  ___
        10  18<--  15  45  <span style="color: red">46</span>  62  58  <span style="color: red">90</span>
    <span style="color: #00aa44">我会把比较完成的数标红</span>
        <span style="color: red">10</span>  18  15 45  <span style="color: red">46</span>  62  58  <span style="color: red">90</span>
        <span style="color: red">10</span>  ___  15 45<--  <span style="color: red">46</span>  ___  58<--  <span style="color: red">90</span>
        <span style="color: red">10</span>  ___  15<-- 45  <span style="color: red">46</span>  58  ___  <span style="color: red">90</span>
        <span style="color: red">10</span>  <span style="color: red">15  18  45</span>  <span style="color: red">46</span>  <span style="color: red"> 58  62</span>  <span style="color: red">90</span>
注意如果碰到相同的是不动的
快速排序是内部排序中平均性能最好的
快排最大递归深度是n，最小是log₂n
怎样快速判断，快排第几趟是不可能的结果
将序列完整排好，对比选项，看看是否至少有2个位置是对应上的
<hr>
</pre>
<h2>选择排序(简单选择、堆排序)</h2>
<pre>
<hr>
<span style="color: red;font-size: 20px">简单选择</span>
如同名字一样，简单
{60，27，20，36，55，77，28，36，52，44，16}
每轮都在剩下的数中选最小的换到前面
用一个temp临时变量存储数组中元素最小的下标，依次比较数组，找出最小的，然后和数组从前到后交换
例如第一个
我们记录假设最小就是数组开头k=0，然后我们比较第二个
{60，<span style="color: #00ebff">27</span>，20，36，55，7，28，36，52，44，16}
发现27更小，更新k=1，一定是数组下标，而不是本身数值，因为我们要交换
{60，27，<span style="color: #00ebff">20</span>，36，55，7，28，36，52，44，16}
20比存储的k=1（27）更小，再更新k=2
以此类推
{60，27，20，36，55，7，28，36，52，44，16}
k最终的值是5，也就是元素7
让数组[0]与数组[k]交换
{<span style="color: #2193b0">7</span>，27，20，36，55，<span style="color: #2193b0">60</span>，28，36，52，44，16}
第一个我们就确定了，第二趟我们让k假设第二个元素，也就是k=1最大，也就是让k=1，然后依次比较记录
后面就不说了
唯一需要注意的是，这个简单选择排序是不稳定的，因为假如有两个一样的，一个在前一个后
由于最小的数在最后面，让第一个和最小的交换位置，所以第一个就跑第二个后面了
<hr>
<span style="color: red;font-size: 20px">堆排</span>
<span style="color: #00daff">对{5,1,6,9,2}如何构造大/小根堆</span>
    怎么说呢，就是大小根堆简单就是根是最大/小的就是
    我们操作的步骤第一步就是将给出的数列按完全二叉树排列(完全二叉树不知道的话那，废了)
    <canvas id="myCanvas104" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas104');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'5    【1】' },
        { x: 150, y: 100,label:'1    【2】' },
        { x: 400, y: 100,label:'6    【3】' },
        { x: 100, y: 175, label:'9    【4】' },
        { x: 190, y: 175, label:'2    【5】' },

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
我们这样5个数，我们取一半（向下取整）
    <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mn>5</mn><mn>2</mn></mfrac><mo>=</mo><mn>2</mn></mrow></math>
我们从第二个数开始即1【2】开始比较它与它的左右孩子们的大小，大的放根上就行
    <canvas id="myCanvas105" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas105');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'5    【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'6    【3】' },
        { x: 100, y: 175, label:'1    【4】' },
        { x: 190, y: 175, label:'2    【5】' },

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
    然后再第1个数即5【1】比较它与它的左右孩子大小
    <canvas id="myCanvas106" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas106');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'9    【1】' },
        { x: 150, y: 100,label:'5    【2】' },
        { x: 400, y: 100,label:'6    【3】' },
        { x: 100, y: 175, label:'1    【4】' },
        { x: 190, y: 175, label:'2    【5】' },

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[4], end: vertices[5] },
    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
以上就是大根堆的构造过程，小根堆同理但是这只是简单数字比较少的时候的情况
一旦数字过多就会出现，一些没讲过的情况例如
    {9,43,-54,4,-13,10,36}(初步一看就不是最大根堆/最小根堆，因为第一个数既不是最大也不是最小)
<canvas id="myCanvas107" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas107');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'9   【1】' },
        { x: 150, y: 100,label:'43    【2】' },
        { x: 400, y: 100,label:'-54  【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'36   【7】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
我们构造大根堆，第一步还是总个数/2
    <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mn>7</mn><mn>2</mn></mfrac><mo>=</mo><mn>3</mn></mrow></math>(向下取整)
比较第三个与它的左右孩子的大小，大的放根上
<canvas id="myCanvas108" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas108');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'9   【1】' },
        { x: 150, y: 100,label:'43    【2】' },
        { x: 400, y: 100,label:'36   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'-54   【7】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
接着比较第二个数与它的左右孩子的大小，大的放根上
<canvas id="myCanvas109" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas109');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'9   【1】' },
        { x: 150, y: 100,label:'43    【2】' },
        { x: 400, y: 100,label:'36   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'-54   【7】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
接着比较第一个数与它的左右孩子的大小大的放根上
<canvas id="myCanvas110" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas110');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'43   【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'36   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'-54   【7】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
OK，此时就是最大根堆了，哎呀呀，我想说的那种情况没有发生，
    就是那种像最后一步的时候，9和43不是换了嘛，9到新位置以后如果它的左右孩子有比它大的，也要再调换

然后就是仅仅这样不算是堆排序，这一步只是把最大值选出来了
我们可以通过移除最大值，来继续排但这样多此一举
不如直接让这个根（最大值）和我们的第七个数（大概率最小值）调换
调换以后，我们可以忽略它，然后重新排序
    按照我们说的，继续
<canvas id="myCanvas111" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas111');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'-54   【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'36   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'43   【被灭了】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
    嘿嘿
    <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mn>6</mn><mn>2</mn></mfrac><mo>=</mo><mn>3</mn></mrow></math>
    还是比较第三个数和它的左右孩子，但是这次，它只有左孩子了
    然后就是第二个数和它的左右孩子，9还是最大的，然后我们比较
    第一个数，发现36是最大的调上去
<canvas id="myCanvas101" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas101');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'36   【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'-54   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'10 【6】' },
        { x: 440, y: 175, label:'43   【被灭了】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
    <span style="color: red">到这里并没有结束，我之前说的情况发生了</span>
    就是第六个数10比第三个数（掉下来的）-54大，此时同样需要换
    最终就是
<canvas id="myCanvas102" width="800" height="300"></canvas>
    <script>
    var canvas = document.getElementById('myCanvas102');
    var context = canvas.getContext('2d');

    // 定义图的顶点
    var vertices = [
        { x: 250, y: 50, label:'36   【1】' },
        { x: 150, y: 100,label:'9    【2】' },
        { x: 400, y: 100,label:'10   【3】' },
        { x: 100, y: 175, label:'4    【4】' },
        { x: 190, y: 175, label:'-13  【5】' },
        { x: 370, y: 175, label:'-54 【6】' },
        { x: 440, y: 175, label:'43   【被灭了】' }

    ];

    // 定义图的边
    var edges = [
        { start: vertices[0], end: vertices[1] },
        { start: vertices[0], end: vertices[2] },
        { start: vertices[1], end: vertices[3] },
        { start: vertices[1], end: vertices[4] },
        { start: vertices[2], end: vertices[6] },
        { start: vertices[2], end: vertices[5] },

    ];


    // 绘制顶点
    vertices.forEach(function(vertex) {
        context.beginPath();
        context.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();
        context.stroke();

        // 绘制顶点标签
        context.fillStyle = 'black';
        context.font = '14px Arial';
        context.fillText(vertex.label, vertex.x - 5, vertex.y + 5);
    });


    // 绘制边和权重
    edges.forEach(function(edge) {
        context.beginPath();
        context.moveTo(edge.start.x, edge.start.y);
        context.lineTo(edge.end.x, edge.end.y);
        context.strokeStyle = 'black';
        context.stroke();

        // 绘制边权重标签
        if (edge.weight !== undefined) {
            var weightX = (edge.start.x + edge.end.x) / 2;
            var weightY = (edge.start.y + edge.end.y) / 2;
            context.fillStyle = 'red';
            context.font = '12px Arial';
            context.fillText(edge.weight, weightX, weightY);
        }
    });
</script>
然后就是再把根36和最后位第六位调换，然后重新排，以此往复
直到排完就是一个以完全二叉树的从小到大的排序了
小根堆是同理的。（暂时更到这里，累死我了😭😣🤤😬😰😨🥶🥵🥴😵‍💫🤧🤮🤢🫵😗）
<hr>
</pre>
<h2>归并排序</h2>
<pre>
归并的含义是将两个或者两个以上的有序表合并成一个新的有序表
<span style="color: #00daff">对{40，24，80，39，43，18，20，10，90，70} 进行从小到大排序过程(两两分组比较)</span>
    <svg width="500" height="300" xmlns="http://www.w3.org/2000/svg">
        <g>
        <text x="40" y="40" font-size="12" text-anchor="middle">[40]</text>
        <text x="80" y="40" font-size="12" text-anchor="middle">[24]</text>
        <text x="120" y="40" font-size="12" text-anchor="middle">[80]</text>
        <text x="160" y="40" font-size="12" text-anchor="middle">[39]</text>
        <text x="200" y="40" font-size="12" text-anchor="middle">[43]</text>
        <text x="240" y="40" font-size="12" text-anchor="middle">[18]</text>
        <text x="280" y="40" font-size="12" text-anchor="middle">[20]</text>
        <text x="320" y="40" font-size="12" text-anchor="middle">[10]</text>
        <text x="360" y="40" font-size="12" text-anchor="middle">[90]</text>
        <text x="400" y="40" font-size="12" text-anchor="middle">[70]</text>
        </g>

        <g>
        <text x="60" y="80" font-size="12" text-anchor="middle">[24，40]</text>
        <text x="140" y="80" font-size="12" text-anchor="middle">[39，80]</text>
        <text x="220" y="80" font-size="12" text-anchor="middle">[18，43]</text>
        <text x="300" y="80" font-size="12" text-anchor="middle">[10，20]</text>
        <text x="380" y="80" font-size="12" text-anchor="middle">[70，90]</text>
            <!-- 画线 -->
    <line x1="40" y1="40" x2="60" y2="80" stroke="black" stroke-width="1"/>
    <line x1="80" y1="40" x2="60" y2="80" stroke="black" stroke-width="1"/>
    <line x1="120" y1="40" x2="140" y2="80" stroke="black" stroke-width="1"/>
    <line x1="160" y1="40" x2="140" y2="80" stroke="black" stroke-width="1"/>
    <line x1="200" y1="40" x2="220" y2="80" stroke="black" stroke-width="1"/>
    <line x1="240" y1="40" x2="220" y2="80" stroke="black" stroke-width="1"/>
    <line x1="280" y1="40" x2="300" y2="80" stroke="black" stroke-width="1"/>
    <line x1="320" y1="40" x2="300" y2="80" stroke="black" stroke-width="1"/>
    <line x1="280" y1="40" x2="300" y2="80" stroke="black" stroke-width="1"/>
    <line x1="320" y1="40" x2="300" y2="80" stroke="black" stroke-width="1"/>
    <line x1="360" y1="40" x2="380" y2="80" stroke="black" stroke-width="1"/>
    <line x1="400" y1="40" x2="380" y2="80" stroke="black" stroke-width="1"/>
        </g>

<g>
        <text x="100" y="120" font-size="12" text-anchor="middle">[24，39，40，80]</text>
        <text x="260" y="120" font-size="12" text-anchor="middle">[10，18，20，43]</text>
        <text x="380" y="120" font-size="12" text-anchor="middle">[70，90]</text>
        <line x1="60" y1="80" x2="100" y2="120" stroke="black" stroke-width="1"/>
        <line x1="140" y1="80" x2="100" y2="120" stroke="black" stroke-width="1"/>
        <line x1="220" y1="80" x2="260" y2="120" stroke="black" stroke-width="1"/>
        <line x1="300" y1="80" x2="260" y2="120" stroke="black" stroke-width="1"/>
        <line x1="380" y1="80" x2="380" y2="120" stroke="black" stroke-width="1"/>
</g>
<g>
        <text x="180" y="160" font-size="12" text-anchor="middle">[10，18，20，24，39，40，43，80]</text>
        <text x="380" y="160" font-size="12" text-anchor="middle">[70，90]</text>
        <line x1="100" y1="120" x2="180" y2="160" stroke="black" stroke-width="1"/>
        <line x1="260" y1="120" x2="180" y2="160" stroke="black" stroke-width="1"/>
        <line x1="380" y1="120" x2="380" y2="160" stroke="black" stroke-width="1"/>
</g>
<g>
        <text x="260" y="200" font-size="12" text-anchor="middle">[10，18，20，24，39，40，43，70，80，90]</text>
        <line x1="180" y1="160" x2="260" y2="200" stroke="black" stroke-width="1"/>
        <line x1="380" y1="160" x2="260" y2="200" stroke="black" stroke-width="1"/>
</g>
    </svg>
    <span style="color: #00aa44">这应该看得懂吧？一目了然了都😏😏</span>
趟数与元素以及归并路数之间关系
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>m</mi><mo>=</mo><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>k</mi></msub><mi>N</mi><mo stretchy="false">]</mo><mrow><mo>/</mo></mrow><mrow><mo>/</mo></mrow><mi>m</mi><mo>趟，</mo><mi>k</mi><mo>路，</mo><mi>N</mi><mo>元素</mo></math>
</pre>
<h2>基数排序</h2>
<pre>
<span style="color: #00daff">对{457,131,481,219,392,674,350,815,315}进行基数排序</span>
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
    <line x1="100" y1="50" x2="100" y2="200" stroke="black" stroke-width="2"/>
    <line x1="125" y1="50" x2="125" y2="200" stroke="black" stroke-width="2"/>
    <line x1="150" y1="50" x2="150" y2="200" stroke="black" stroke-width="2"/>
    <line x1="175" y1="50" x2="175" y2="200" stroke="black" stroke-width="2"/>
    <line x1="200" y1="50" x2="200" y2="200" stroke="black" stroke-width="2"/>
    <line x1="225" y1="50" x2="225" y2="200" stroke="black" stroke-width="2"/>
     <line x1="250" y1="50" x2="250" y2="200" stroke="black" stroke-width="2"/>
     <line x1="275" y1="50" x2="275" y2="200" stroke="black" stroke-width="2"/>
     <line x1="300" y1="50" x2="300" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">看</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">个</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">位</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">数</text>
        <text x="30" y="160" font-size="12" text-anchor="middle">放</text>
        </g>

        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle">Q_0</text>
        <text x="85" y="50" font-size="12" text-anchor="middle">Q_1</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">Q_2</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">Q_3</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">Q_4</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">Q_5</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">Q_6</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">Q_7</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">Q_8</text>
        <text x="285" y="50" font-size="12" text-anchor="middle">Q_9</text>
        </g>
        <g id="loading-txt">
        <text x="60" y="80" font-size="10" text-anchor="middle"  >350</text>
        <text x="85" y="80" font-size="10" text-anchor="middle"  >481</text>
        <text x="110" y="80" font-size="10" text-anchor="middle" >392</text>
        <text x="160" y="80" font-size="10" text-anchor="middle" >674</text>
        <text x="185" y="80" font-size="10" text-anchor="middle" >475</text>
        <text x="185" y="110" font-size="10" text-anchor="middle" >815</text>
        <text x="185" y="140" font-size="10" text-anchor="middle" >315</text>
        <text x="235" y="80" font-size="10" text-anchor="middle" >137</text>
        <text x="285" y="80" font-size="10" text-anchor="middle" >219</text>
        </g>
    </svg>
<span style="color: #fa0a0a">接下来就是收集（从上到下，从左到右）：{350,481,392,674,475,815,315,137,219}</span>
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
    <line x1="100" y1="50" x2="100" y2="200" stroke="black" stroke-width="2"/>
    <line x1="125" y1="50" x2="125" y2="200" stroke="black" stroke-width="2"/>
    <line x1="150" y1="50" x2="150" y2="200" stroke="black" stroke-width="2"/>
    <line x1="175" y1="50" x2="175" y2="200" stroke="black" stroke-width="2"/>
    <line x1="200" y1="50" x2="200" y2="200" stroke="black" stroke-width="2"/>
    <line x1="225" y1="50" x2="225" y2="200" stroke="black" stroke-width="2"/>
     <line x1="250" y1="50" x2="250" y2="200" stroke="black" stroke-width="2"/>
     <line x1="275" y1="50" x2="275" y2="200" stroke="black" stroke-width="2"/>
     <line x1="300" y1="50" x2="300" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">看</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">十</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">位</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">数</text>
        <text x="30" y="160" font-size="12" text-anchor="middle">放</text>
        </g>

        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle">Q_0</text>
        <text x="85" y="50" font-size="12" text-anchor="middle">Q_1</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">Q_2</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">Q_3</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">Q_4</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">Q_5</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">Q_6</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">Q_7</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">Q_8</text>
        <text x="285" y="50" font-size="12" text-anchor="middle">Q_9</text>
        </g>
        <g id="loading-txt">
        <text x="85" y="80" font-size="10" text-anchor="middle"  >815</text>
        <text x="85" y="110" font-size="10" text-anchor="middle"  >315</text>
        <text x="85" y="140" font-size="10" text-anchor="middle" >219</text>
        <text x="135" y="80" font-size="10" text-anchor="middle" >137</text>
        <text x="185" y="80" font-size="10" text-anchor="middle" >350</text>
        <text x="235" y="80" font-size="10" text-anchor="middle">674</text>
        <text x="235" y="110" font-size="10" text-anchor="middle">475</text>
        <text x="260" y="80" font-size="10" text-anchor="middle" >481</text>
        <text x="285" y="80" font-size="10" text-anchor="middle" >392</text>
        </g>
    </svg>
<span style="color: #fa0a0a">接下来就是收集（从上到下，从左到右）：{815,315,219,137,350,674,475,481,392}</span>
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
    <!-- 轴 -->
    <line x1="50" y1="50" x2="50" y2="200" stroke="black" stroke-width="2"/>
    <line x1="75" y1="50" x2="75" y2="200" stroke="black" stroke-width="2"/>
    <line x1="100" y1="50" x2="100" y2="200" stroke="black" stroke-width="2"/>
    <line x1="125" y1="50" x2="125" y2="200" stroke="black" stroke-width="2"/>
    <line x1="150" y1="50" x2="150" y2="200" stroke="black" stroke-width="2"/>
    <line x1="175" y1="50" x2="175" y2="200" stroke="black" stroke-width="2"/>
    <line x1="200" y1="50" x2="200" y2="200" stroke="black" stroke-width="2"/>
    <line x1="225" y1="50" x2="225" y2="200" stroke="black" stroke-width="2"/>
     <line x1="250" y1="50" x2="250" y2="200" stroke="black" stroke-width="2"/>
     <line x1="275" y1="50" x2="275" y2="200" stroke="black" stroke-width="2"/>
     <line x1="300" y1="50" x2="300" y2="200" stroke="black" stroke-width="2"/>
        <g id="loading-txt">
        <text x="30" y="80" font-size="12" text-anchor="middle">看</text>
        <text x="30" y="100" font-size="12" text-anchor="middle">百</text>
        <text x="30" y="120" font-size="12" text-anchor="middle">位</text>
        <text x="30" y="140" font-size="12" text-anchor="middle">数</text>
        <text x="30" y="160" font-size="12" text-anchor="middle">放</text>
        </g>

        <g id="loading-txt">
        <text x="60" y="50" font-size="12" text-anchor="middle">Q_0</text>
        <text x="85" y="50" font-size="12" text-anchor="middle">Q_1</text>
        <text x="110" y="50" font-size="12" text-anchor="middle">Q_2</text>
        <text x="135" y="50" font-size="12" text-anchor="middle">Q_3</text>
        <text x="160" y="50" font-size="12" text-anchor="middle">Q_4</text>
        <text x="185" y="50" font-size="12" text-anchor="middle">Q_5</text>
        <text x="210" y="50" font-size="12" text-anchor="middle">Q_6</text>
        <text x="235" y="50" font-size="12" text-anchor="middle">Q_7</text>
        <text x="260" y="50" font-size="12" text-anchor="middle">Q_8</text>
        <text x="285" y="50" font-size="12" text-anchor="middle">Q_9</text>
        </g>
        <g id="loading-txt">
        <text x="85" y="80" font-size="10" text-anchor="middle"  >137</text>
        <text x="110" y="80" font-size="10" text-anchor="middle"  >219</text>
        <text x="135" y="80" font-size="10" text-anchor="middle" >315</text>
        <text x="135" y="110" font-size="10" text-anchor="middle" >350</text>
        <text x="135" y="140" font-size="10" text-anchor="middle" >392</text>
        <text x="235" y="80" font-size="10" text-anchor="middle">475</text>
        <text x="235" y="110" font-size="10" text-anchor="middle">481</text>
        <text x="210" y="80" font-size="10" text-anchor="middle" >674</text>
        <text x="260" y="80" font-size="10" text-anchor="middle" >815</text>
        </g>
    </svg>
<span style="color: #fa0a0a">接下来就是收集（从上到下，从左到右）：{137，219，315，350，392，475，481，674，815}</span>
至此你也看出来了，它到底是怎么运作来实现排序的
也不难，先个位数，再十位数，再百位数，一步步确保
切记：基数排序不能对浮点以及双精度类型进行排序
</pre>
<h2>内部排序总结</h2>
<pre>
以上的各种排序都是内部排序
========================================
n较小，采用直接插入排序/简单排序，并且当记录本身信息量大的时候使用简单排序
========================================
n较大，采用快速排序、堆排序、归并排序，其中快速排序被认为是平均最好，快排、堆排不稳定，但是归并稳定
========================================
文件基本有序的时候，选择直接插入或冒泡
========================================
n巨大，关键字位数少的前提下，使用基数排序
========================================
当记录本身信息量巨大，采用链表，避免耗费大量时间移动记录
</pre>
<h2>外部排序</h2>
<pre>
</pre>
<h2>排序算法</h2>
<pre>
</pre>
    </div>
    <div class="block">
        <h1>算法</h1>
        <h2>代码示例</h2>
        <pre>

        </pre>
    </div>
    <div class="block">
        <h1>递归和分治</h1>
        <h2>二分查找(基于递归分治)</h2>
        <pre>
        <code type="c">
/*问题：给定一个长度为n的有序数组nums，其中所有元素都是唯一，查找元素target*/
#include< stdio.h >//基于分治递归的二分查找
int dfs(int[], int, int, int);
void main() {
	int a[] = {1, 2, 3, 4, 5, 6, 7, 8};//定义一个数组
	int b = dfs(a, 2, 0, sizeof(a)/sizeof(a[0])-1);
	//第四个参数是计算数组大小，因为sizeof返回的是存储大小，所以总大小/一个大小就是个数
	printf("这个元素是数组中的第%d个\n",b+1);
	return 0;
}
int dfs(int a[], int target, int i, int j)
{
	if (i > j)
		return -1;//如果左指针大于右指针说明查找失败，因为二分都分劈叉了，你说呢
	int m = (i + j) / 2;//依据我们理论来讲，m中间指针是指向首尾/2，也就是一半，向下取整
	if (target > a[m])//如果目标比中间大，我们将目光看向大的那一半
		return dfs(a, target, m + 1, j);//进入大的一半
	else if (target < a[m])//如果目标比中间小，将目光看向小的那一半
		return dfs(a, target, i, m - 1);//进入小的一半
	else
		return m;//如果此时首尾指针指向一个元素，那么就是我们要找的
}
/*分治的体现，使用递归，每次割分，不断将问题化为一个个小问题，小问题之间无联系*/

        </code>
        </pre>
    </div>
    <div class="block">
        <h1>动态规划</h1>
        <h2>代码示例</h2>
        <pre>
<code class="c" type="c">
/*动态规划*/
/*
-----------------------------------------
背包问题
打家劫舍
股票问题
子序列问题
-----------------------------------------
dp[i][j]
1.dp数组以及下标含义
2.递推公式
3.dp数组如何初始化
4.遍历顺序
5.打印数组
-----------------------------------------
*/
/*--------------------------------------------*/
/*--------------------------------------------*/
/*斐波那契数列*/
//1 1 2 3 5 8 13 ...
//1.确定dp数组，dp[i]，代表第i个斐波那契数
//2.确定递推公式，dp[i] = dp[i-1]+dp[i-2]
//3.初始化，dp[0]=1,dp[1]=1
//4.遍历顺序，从前向后遍历
//5.打印dp数组
int dp[n + 1];
dp[0] = 1;
dp[1] = 1;
for (int i = 2; i < n; i++)
{
	dp[i] = dp[i - 1] + dp[i - 2];
}
return dp[n];
/*--------------------------------------------*/
/*--------------------------------------------*/
/*爬楼梯*/
//1.确定dp数组，dp[i],代表达到第i阶有dp[i]中方法
//2.确定递归公式，dp[i] = dp[i-1]+dp[i-2]
//3.初始化，dp[0]从含义上是没营养的，到达第0阶有1种方法。所以直接dp[1]=1,dp[2]=2
//4.遍历，从前向后
//5.打印dp
/*--------------------------------------------*/
/*--------------------------------------------*/
/*使用最小花费爬楼梯*/
/*
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。
-------------------------------------
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
--------------------------------------
1.花费的力气是当前所在的台阶
2.顶楼是数组大小+1，也就是最后一个力气再后一个
*/
//1.确定dp数组，dp[i]代表到达i位置所需要最小花费为dp[i]
//2.确定递推公式，dp[i]是由dp[i-1]或者dp[i-2]得到
//		dp[i] = dp[i-1]+cost[i-1]到i处需要i-1处需要i-1处的力气
//		dp[i] = dp[i-2]+cost[i-2]到i处需要i-2处需要i-2处的力气
//		两个都能去第i处，但是要求最小花费，所以选择两者中较小者
//		所以就是dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
//3.初始化，dp[2]由dp[1]和dp[0]决定，所以只需要初始化dp[1]和dp[0]
//		我们站在1和0处是不需要花费的，只有跳上去才需要
//		所以dp[0] = 0;dp[1] = 0;
//4.遍历，从前向后
//5.打印dp
int minCostClimbingStairs(int* cost, int costSize) {
	int dp[costSize + 1];//初始化数组
	dp[0] = dp[1] = 0;//初始化，第一个和第二个
	for (int i = 2; i <= costSize; i++) {
		dp[i] = fmin(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);//选每一步最小的跳
	}
	return dp[costSize];//返回dp数组，最后一个就是最小花费的总力气
}
/*--------------------------------------------*/
/*--------------------------------------------*/
</code>
        </pre>
    </div>
    <div class="block">
        <h1>贪心算法</h1>
        <h2>代码示例</h2>
        <pre>
<code class="search-box">
/*贪心算法*/
/*
本质：找到每个阶段的局部最优
局部最优推出全局最优
*/
//贪心没有套路，基本思路就是局部最优、
/*饼干问题*/
//孩子需要的饼干：1，2，7，10
//饼干：1，3，5，9
//思路，局部：每次用最大的饼干匹配胃口最大的孩子
//1.选最大饼干9，匹配尽量胃口大的7
//2.再选最大饼干5，匹配胃口大的2
//3.再选最大饼干3，匹配胃口大的1
sort(胃口);//对胃口排序
sort(饼干);//对饼干排序
int 成功投喂小孩数 = 0;
int index = 饼干.size-1;
for (int i = 胃口.size-1; i >= 0; i--)//胃口从大到小进行遍历
{
	while (index >= 0 && 饼干[index] >= 胃口[i])//饼干从大到小进行遍历匹配
	{
		成功投喂小孩数++;
		index--;
	}
}
</code>
        </pre>
    </div>
    <div class="block">
        <h1>回溯和其他算法</h1>
        <h3>基本认知</h3>
        <pre>
<code class="search-box">
/*回溯算法*/
/*
有递归就会有回溯
回溯算法：纯暴力搜索
可以解决：
1.组合问题：从一堆东西中找出数量为n的组合（无序）
2.切割问题：给一个字符串，问如何切割保证子串都是回文字串
3.子集问题：给一堆东西，列出所有的子集
4.排列问题：从一堆东西中找出数量为n的排列，排序不同顺序即便相同东西也是不同排列
5.棋盘问题：N皇后，解数独
-----------------------------------------------------
回溯法针对任何问题，都可以抽象为一个树形问题
一般来说回溯法的递归函数无返回值
函数取名为（模板）
*/
void backtracking(参数)
{
	if (停止条件)
	{
		收集结果;//叶子节点来收集结果
		return ;
	}
	for (集合元素)
	{
		处理节点;
		递归函数;
		回溯操作;
	}
}
/*
举个例子，集合1234
组合问题
取1 取2
12
此时回溯，也就是回溯到2还没有进来
1
然后加入3
13
再回溯，也就是回溯到3还没有加进来
1
然后加入4
14
以此类推
*/
-----------------------------------------
/*组合问题*/
/*
给定两个整数n和k，返回范围[1,n]中所有可能的k个数的组合
*/
int** combine(int n, int k, int* returnSize, int** returnColumnSizes)
{
	for (int i = 0; i < size; i++)
	{
		for (int j = i + 1; j < size; j++)
		{
			for (int a1 = j + 1; a1 < size; a1++)
			{
				for (int a2 = a1 + 1; a2 < size; a2++)
				{
					for (int a3 = a2 + 1; a3 < size; a3++)
					{
						for (int a4 = a3 + 1; a4 < size; a4++)
						{
							for (int a5 = a4 + 1; a5 < size; a5++)
							{
								for (int a6 = a5 + 1; a6 < size; a6++)
								{
									for (int a7 = a6 + 1; a7 < size; a7++)
									{
										.......
											直到
											for (int ak = a(k - 1) - 1; ak < size; ak++)
											{
												return k个数的组合
											}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
/*
是的，没看错，这种用for循环死磕，还能加工资，毕竟代码行就是工资
今天你给我从0-10000000000000000找出999999999999个
你就得写999999999999for循环，牛逼
所以回溯法就来了，它可以控制递归来达到控制for循环的次数
*/
class Solution {
private:
	vector< vector< int>> result; // 存放符合条件结果的集合
	vector< int> path; // 用来存放符合条件结果
	void backtracking(int n, int k, int startIndex) {
		if (path.size() == k) {//如果到叶子，也就是存了k个以后结束
			result.push_back(path);//将结果存储到二维数组中
			return;
		}
		for (int i = startIndex; i <= n; i++) {
			path.push_back(i); // 处理节点，也就是加入节点
			backtracking(n, k, i + 1); // 递归
			path.pop_back(); // 回溯，撤销处理的节点
		}
	}
public:
	vector< vector < int>> combine(int n, int k) {
		result.clear(); // 可以不写
		path.clear();   // 可以不写
		backtracking(n, k, 1);
		return result;
	}
};
/*
for循环  保证 从左到右  单向遍历
递归  保证 从上到下
结束条件 保证 从上到下有尽头
撤销操作  保证 能回溯，也就是保证了能从下到上
*/
--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------
</code>
        </pre>
<h3>复原IP地址</h3>
        <pre>
            <code>

            </code>
        </pre>

    </div>
    <div class="block">
        <h1>数据结构经典题</h1>
        <h2>代码示例</h2>
        <pre>
<code><strong>1.以下属于逻辑结构的是:</strong>
A. 顺序表
B. 哈希表
C. 有序表
D. 单链表
<strong>答案:</strong> C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
其实很不好理解，毕竟你的脑子不够聪明。顺序表顺序存储。哈希表散列存储。单链表链式存储。
怎么？有序表，有序存储是吧，有序是指元素之间有序，不是说地址有序，所以只要涉及元素的关系就是逻辑
</code>
<code><strong>2.以下关于数据结构的说法中正确的是:</strong>
A.数据的逻辑结构独立于其存储结构
B.数据的存储结构独立于其逻辑结构
C.数据的逻辑结构唯一决定其存储结构
D.数据结构仅由其逻辑结构和存储结构决定
<strong>答案:</strong> A &nbsp; &nbsp; &nbsp; &nbsp; &n

    bsp; &nbsp; &nbsp; &nbsp; &nbsp;
这道题主要的任务就是说，逻辑结构其实是人先想出来，然后用计算机实现
所以说逻辑结构独立存储结构
但是存储结构是要靠逻辑结构作为支撑的
数据结构的三要素：逻辑、存储、操作
</code>
<code><strong>3.若长度为n的非控股线性表采用顺序存储结构，在表的第i个位置插入一个数据元素，则i的合法值是:</strong>
A.1≤i≤n
B.1≤i≤n+1
C.0≤i≤n-1
D.0≤i≤n
<strong>答案:</strong> B &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
我知道你可能会选C，第i个位置插入元素，你给我在第0个位置插入试试看？又不是数组下标，哦，喝杯咖啡就是程序员了？
线性表的顺序存储，就是数组，动态分配，可以在最后追加一个元素的啊，反正重新创建数据，重新整体搬迁完事了
</code>
<code><strong>4.栈和队列具有相同的:</strong>
A.抽象数据类型
B.逻辑结构
C.存储结构
D.运算
<strong>答案:</strong> B &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
栈和队列都是线性结构，是逻辑结构，是元素之间是有关系的，你前我后
</code>
<code><strong>5.若一个栈的输入序列为1，2，3...n,输出序列的第一个元素是n，则第i个输出元素是:</strong>
A.不确定
B.n-i
C.n-i-1
D.n-i+1
<strong>答案:</strong> D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
这题我选过B，以为第一个输出n，那第二个就是n-1,第i个不就是n-i了？
哦哦哦，不对是我太蠢了，第i个应该是n-i+1,害，老了
</code>
<code><strong>5.最适合用作链队的链表是:</strong>
A.带队首指针和队尾指针的循环单链表
B.带队首指针和队尾指针的非循环单链表
C.只带队首指针的非循环单链表
D.只带队首指针的循环单链表
<strong>答案:</strong> B &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
队列是要一头进行删除一头进行增加的，C、D不合适，因为只有队首，队尾进行操作是要遍历的
A为什么不行？A和B差距就是循环两个字，看队列的性质，循环不循环是无所谓的，因为我们只通过两个指针的跳变
完成我们首末的工作，还不清楚去看队列的相关知识
</code>
<code><strong>6.已知循环队列存储在一维数组A[0...n-1]中，且队列非空时，front和rear分别指向队头元素和队尾元素。
    若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是:</strong>
A.0，0
B.0，n-1
C.n-1,0
D.n-1,n-1
<strong>答案:</strong> B &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
这道题的文本本身就是一个坎，进队操作就是rear=(rear+1)%MAXSIZE
好，现在rear尾指针指向哪里？包是0啊
我们在队列讲解中说的《约定空出一个不存储，也就是队尾+1就是队头的时候就是满,注意队尾指向的不是最后一个元素而是最后一个元素的下一个空位置》
是指一种特殊的情况
n%n=0,也就是(n-1+1)%n=0
所以rear就是n-1，front不动，那就是0
</code>
<code><strong>7.设二叉树有2n个结点，且m < n,则不可能存在的结点是:</strong>
A.n个度为0
B.2m个度为0
C.2m个度为1
D.2m个度为2
<strong>答案:</strong> C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
这道题最好的办法就是判断奇偶性，我们知道n0=n2+1
而且2n=n0+n1+n2，代入结合一下
2n=2n2+n1+1
n1=2n-2n2-1
n1=2(n-n2)-1
说明n1是奇数，所以C不对
</code>
<hr>
<strong>8.高度为h的完全二叉树最少有多少个结点:</strong>
A.<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mi>h</mi></msup></math>
B.<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mi>h</mi></msup><mo>+</mo><mn>1</mn></math>
C.<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></math>
D.<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></math>
<strong>答案:</strong> C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
想象一下，如果我们的第h层只有一个结点，是不是就是最少的情况
那前面的h-1层就是满的，我们用等比数列算<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><mrow><mn>1</mn><mo>−</mo><mn>2</mn></mrow></mfrac><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></math>
然后我们第h层有一个，加上这一个
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></math>
<hr>
<strong>9.已知一棵完全二叉树的第6层(根为第一层)有8个叶结点，则该完全二叉树的结点个数最多是:</strong>
A.39
B.52
C.111
D.119
<strong>答案:</strong> C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
想象一下完全二叉树第6层如果有叶结点，那么就是第七层没有满，也有可能是第六层就是这几个叶子结点了
我们要算最多，那不就是存在第七层的嘛
我们前6层都满，算一下<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mn>2</mn><mn>6</mn></msup></mrow><mrow><mn>1</mn><mo>−</mo><mn>2</mn></mrow></mfrac><mo>=</mo><mn>63</mn></math>
我们第七层什么情况？我们第6层有8个叶子，也就是第7层少了16个结点，我们把第七层算一下减去16就行
第七层的结点用等比第n项公式
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mn>6</mn></msup><mo>=</mo><mn>64</mn><mo>,</mo><mn>64</mn><mo>−</mo><mn>16</mn><mo>=</mo><mn>48</mn><mo>,</mo><mn>48</mn><mo>+</mo><mn>63</mn><mo>=</mo><mn>111</mn></math>
<hr>
<strong>10.在二叉树中有两个结点m和n，若m是n的祖先，则使用什么可以找到从m到n的路径:</strong>
A.先序遍历
B.中序遍历
C.后序遍历
D.层次遍历
<strong>答案:</strong> C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
二叉树的代码实现中，是递归的，递归就是说先深入再回退，那么就是左右根可以不断的输入从n到m的路径
相当于可以找到从m到n的路径
<hr>
<strong>11.线索二叉树是一种什么结构:</strong>
A.逻辑
B.逻辑和存储
C.物理
D.线性
<strong>答案:</strong> C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
烦死了，这种题目
<hr>
<strong>12.二叉树在线索化后，仍不能有效求解的问题是:</strong>
A.先序线索二叉树中求先序后继
B.中序线索二叉树中求中序后继
C.中序线索二叉树中求中序前驱
D.后序线索二叉树中求后序后继
<strong>答案:</strong> D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
根左右，右的线索前驱是左，要找右的前驱根，显然不太行
<hr>
<strong>13.在有n个叶结点的哈夫曼树中，非叶结点的总数是:</strong>
A.n-1
B.n
C.2n-1
D.2n
<strong>答案:</strong> A &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
哈夫曼树中只有度为0和2的结点，根据度为0和度为2的公式
n0=n2+1
n2=n0-1
<hr>
<strong>14.对n个互不相同的符号进行哈夫曼编码，若生成的哈夫曼树共有115个结点，则n的值是:</strong>
A.56
B.57
C.58
D.60
<strong>答案:</strong> C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
n个符号共新建了n-1个结点，2n-1=115
2n=116
n=58
<hr>
<strong>15.若从无向图的任意顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是:</strong>
A.强连通图
B.连通图
C.有回路
D.一棵树
<strong>答案:</strong> B &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
A是有向图的东西
B对
C有回路不一定是连通图，因为可能是单独一个顶点，其他剩下的有回路
D一棵树是不可能有环的，而这个连通图是可能有的
<hr>
<strong>16.一个28条边的非连通无向图至少有多少个顶点:</strong>
A.7
B.8
C.9
D.10
<strong>答案:</strong> C
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
我们知道边数和顶点的关系，也就是<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>e</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></math>
以上的完全图的边对应点的关系，我们如果再增加一个点，这个点就是单独的点，也就是构成非连通图
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>28</mn><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></math>
算出n=8，此时再加一个顶点就是非连通
所有就是9
<hr>
<strong>17.无向图G有23条边，度为4的顶点有5个，度为3的顶点有4个，其余都是度为2的顶点，则图G有多少个顶点:</strong>
A.11
B.12
C.15
D.16
<strong>答案:</strong> D
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
分析题目，只有度4度3度2，也就是总度=n4+n3+n2
我们又知道无向图度与边的关系，就是总度数=边数*2
23*2=n4+n3+n2
46=20+12+n2
n2=14
那度为2的顶点个数就是12/2=7
所有总的顶点个数=7+4+5=16
<hr>
<strong>18.在有n个顶点的有向图中，顶点的度最大可达:</strong>
A.n
B.n-1
C.2n
D.2n-2
<strong>答案:</strong> D
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
有向图的度=入度+出度
我们看题目，问的是一个顶点的度
这个顶点可以与n-1个有来往
来是n-1
往是n-1
总是2n-2
<hr>
<strong>19.具有6个顶点的无向图，当有多少条边时能确保是一个连通图:</strong>
A.8
B.9
C.10
D.11
<strong>答案:</strong> D
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
考虑我们的知识点，n个顶点的完全图对应有多少条边？
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>e</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></math>
假如5个顶点组成是一个完全图，现在加入一个顶点就是非连通，但是再加入一条边就是连通的了，因为完全图里面加不了边了
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>10</mn><mo>=</mo><mfrac><mrow><mn>5</mn><mo stretchy="false">(</mo><mn>5</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></math>
5个顶点完全图需要10条边，再加入一条不就是让6个顶点连通的了，所以就是11
<hr>
<strong>20.若具有n个顶点的图是一个环，则它有多少棵生成树:</strong>
A.n方
B.n
C.n-1
D.1
<strong>答案:</strong> B
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
n个顶点是一个环，环去掉任意一条边都是一个生成树
所以可以有n种
<hr>
<strong>21.若一个具有n个顶点、e条边的无向图是一个森林，则该森林中必有多少棵树:</strong>
A.n
B.e
C.n-e
D.1
<strong>答案:</strong> C
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
对于任意一棵树而言，e=n-1 ,就是边数等于顶点数-1
假设有x棵数
那么就是e=(n1-1)+(n2-1)+...+(nx-1)
e=n-x
x=n-e
<hr>
<strong>22.n个顶点的无向图的邻接表最多有多少个边表结点:</strong>
A.n方
B.n(n-1)
C.n(n+1)
D.[n(n-1)]/2
<strong>答案:</strong> B
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
对于一个具有n 个顶点的无向图：
每个顶点都至少有一个边表节点，即使它不与任何其他顶点相连（这种情况下，该顶点的链表只有一个节点，代表一个孤立顶点）。
在无向图中，每条边在邻接表中会出现两次，因为无向图的边是双向的。因此，如果顶点
A与顶点B相连，那么在顶点A的链表中会有一个边表节点指向B，在顶点B的链表中也会有一个边表节点指向A。
因此，对于一个具有n个顶点的无向图：最多有n个顶点，每个顶点都与其他个顶点相连(n-1)（除了它自己）。
因此，最多有n×(n−1) 个边表节点，因为每条边贡献了两个边表节点（每个顶点的链表中各一个）。
但是，由于每条边被计算了两次（一次在每个顶点的链表中），实际的边数是边表节点数的一半，即边数=[n×(n−1)]/2
<hr>
<strong>23.在有向图的邻接表存储结构中，顶点v在边表中出现的次数是:</strong>
A.顶点v的度
B.顶点v的出度
C.顶点v的入度
D.依附于顶点v的边数
<strong>答案:</strong> C
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
邻接表有向图，连接的一定是向有路径的方向，这个点被上一个点过来，一定是入度
<hr>
<strong>24.设有向图G=(V，E)，顶点集V={V0,V1,V2,V3},边集={< V0 , V1>,< V0,V2 >,< V0,V3 >,< V1,V3 >}若从顶点V0开始对图进行深度优先遍历，则可能得到的不同遍历序列个数是:</strong>
A.2
B.3
C.4
D.5
<strong>答案:</strong> D
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
嗯，我知道你可能会有疑问，我想告诉你的是，你设想到的所有可能是存在的，分岔路口是包括的。
<hr>
只有缩短所有关键路径上的至少一个关键活动可以缩短整个工程工期
<hr>
<strong>25.用Prim算法和Kruskal算法构造图的最小生成树，所得到的最小生成树:</strong>
A.相同
B.不相同
C.可能相同、可能不同
D.无法比较
<strong>答案:</strong> C
当权值有一样的时候，普利姆和克鲁斯卡尔是有可能构造出不同的最小生成树
为什么我突然想到权力的游戏，还有戒指
<hr>
<strong>26.为提高查找效率，对65025个元素的有序顺序表建立索引结构，在最好情况下查找到表中已有元素最多需要执行多少次2关键字比较:</strong>
A.10
B.14
C.16
D.21
<strong>答案:</strong> C
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
首先最好是建立的索引表求开方<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msqrt><mn>65025</mn></msqrt><mo>=</mo><mn>255</mn></math>
也就是说索引表有255个，索引块中也有255，分别采用折半查找
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>2</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>255</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>16</mn></math>
<hr>
<strong>27.含有n个非叶结点的m阶B树中至少包含多少个关键字:</strong>
A.n(m+1)
B.n
C.n([m/2]-1)
D.(n-1)([m/2]-1)+1
<strong>答案:</strong> D
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
至少，根至少一个关键字
其他结点至少[m/2]-1个关键字
所以就是(n-1)([m/2]-1)+1个
<hr>
<strong>28.已知一棵五阶B树中共有53个关键字，则树的最大高度为，最小高度为:</strong>
A.2
B.3
C.4
D.5
<strong>答案:</strong> C B
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
树的高度要最高，也就是分支最少，每一个结点的关键字最少
套用等比数列求和公式<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mn>3</mn><mi>h</mi></msup></mrow><mrow><mn>1</mn><mo>−</mo><mn>3</mn></mrow></mfrac><mo>=</mo><mfrac><mn>53</mn><mn>2</mn></mfrac></math>
树的高度要求最低，也就是每一个结点关键字最多，分支最多
套用等比数列公式就是<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mn>5</mn><mi>h</mi></msup></mrow><mrow><mn>1</mn><mo>−</mo><mn>5</mn></mrow></mfrac><mo>=</mo><mfrac><mn>53</mn><mn>4</mn></mfrac></math>
分别得出4和3
<hr>
<strong>29.依次将关键字5，6，9，13，8，2，12，15插入初始为空的4阶B树后，根结点中包含的关键字是:</strong>
A.8
B.6，9
C.8，13
D.9，12
<strong>答案:</strong> B
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
我们插入
            5 6 9 13
这个时候超过了元素可以容忍的最大个数，我们从m/2也就是4/2第二个分开，第二个成根，其他分为左右
            6
       5         9 13
8入
            6
       5         8 9 13
2入
              | 6 |
     |2  5|           |8 9 13|
12入
              | 6 |
     |2  5|           |8 9 12 13|
超了，我们还是以9为分割
               |6 9|
     |2  5|     |8|     |12 13|
再加入15
               |6 9|
     |2  5|     |8|     |12 13 15|
所以根结点就是6 9
<hr>
<strong>30.现有长度为11且初始为空的散列表HT，散列函数是H(Key)=Key%7,采用线性探测法解决冲突，将关键字序列87，40，30，6，11，22，98，20依次插入HT后，HT查找失败的平均查找长度为:</strong>
A.4
B.5.25
C.6
D.6.29
<strong>答案:</strong> C
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
我们把数装进去
散列地址    |0 | 1 |2 | 3 | 4 | 5 | 6 | 7 | 8 ||||
关键字     |98 |22 |30|87| 11 |40 | 6 |20|
我们查找第一个失败肯定是从0到7然后再到8然后失败，也就是9次
第二个从1到7再到8然后失败，也就是8次
以此类推
注意什么时候停止，肯定是到6，3次的时候
因为%7是不可能出现余数为7的
(9+8+7+6+5+4+3)/7=6
<hr>
<strong>31.对n个关键字进行快速排序，最大递归深度为，最小递归深度为:</strong>
A.1
B.n
C.log2n
D.nlog2n
<strong>答案:</strong> B C
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
最大深度就是一条路到黑，那就是n，最小如果递归化为一棵树，那就是树高
<hr>
<strong>32.设数组a[1...50,1...80]的基地址是2000，每个元素占两个存储单元，若以行序为主序顺序存储，则元素a[45][68]的存储地址为多少？若以列序为主序顺序存储，则元素a[45][68]的地址是多少:</strong>
<strong>答案:</strong> 9174  8788
这里我讲第一个概念，行序为主就是先把第一行存完再到下一行
列序为主就是先把第一列存完，再存第二列
还有一点就是，这里的数组是从1开始，区别于0开始的是，存储大小一样，但是a[5]在1看来是第4个，在0看来是第5个
这里a[45][68]是从1开始，也就是行有44行存满，第45行有67个
44行×每一行的个数80=3520
3520+67=3587
数组的总个数为3587
然后×上每一个元素的大小3587×2=7174
再加上首地址2000=9174
--------------------------------------
以列序为主
也就是a[45][68]中，67列是满的，为什么是67，因为在1看来它是，如果在0开来就是68了
67列满了，第68列只存到第44行，也就是第68列从上往下只有44个元素
67×50=3350，为什么是乘50？因为数组行数大小是1...50，也就是最大50行，那不就是一列从上到下的个数
3350+44=3394
3394×2=6788
再加上首地址2000=8788
==================================================
好，我们总结一下，这里比较误导的区域
从0开始，和从1开始
从0开始的a[5][5]
你自己读读，a[5][5]是第几行第几列
当然是第6行第6列啊，难不成a[0][3]是第0行吗？
这里是从0开始
从1开始呢？a[5][5]。当然是第5行第5列啊
它没有a[0][x],或者a[x][0]这种，更不用说a[0][0]
我们上面计算的时候，假设行优先，为什么a[45][68]，是计算44行完整大小，再加上67
因为a[45][68]是指第45行第68列的元素，也就是前面44行地址都要计算，45行的67列地址也要算
如果是从0开始a[45][68]是指第46行第69个元素，所以要计算前45行地址，再加上46行的68个元素地址
还是不了解的话是我的错，请记住数组下标只能到比定义-1
比如a[5][5]，你在调用的时候最多调用a[4][4],a[5][5]是越界的
所以从1开始和从0开始当然少一个
<hr>
最大深度就是一条路到黑，那就是n，最小如果递归化为一棵树，那就是树高
<hr>
<strong>33.具有n个关键字的m阶b-树，有多少个叶子节点（查找不成功的节点）</strong>
n+1个
b-树就是b树，如果不清楚b树概念，点击目录，或者翻上去，找到b树复习
我也挺迷的，我甚至第一次做这题的时候一点思路都没
我还乱套公式，比如什么n(n-1)/2这种
给你讲个东西
下面是
            A
       B         C
   D       E   F      G
请问有几个查找不成功的节点
其实你把这个隆起的树，看成平的就好了，你不会想到胸了吧？
D  B  E  A  F  C   G
你看，这样虽然反人类，但是b树的本意就是如此
  D     B    E    A    F   C     G
1    2    3    4    5    6    7     8
你看7个节点一共有8个查找不成功的
还不明白？
2      4      6      8       10
让你找一个数，你可能会经历哪些失败？
1.比2小
2.比2大比4小
3.比4大比6小
4.比6大比8小
5.比5大比10小
6.比10大
你看5个点，6个可能结果，也就是叶子节点
注意在b树中叶子节点是指外部节点也就是内部叶子节点的下一层虚空的，满的
            <hr>
<strong>34.若平衡二叉树的高度为6，且所有非叶子节点的平衡因子均为1，则该平衡二叉树的节点总数为</strong>
这题很有意思，看似很难，其实对于你来讲确实难，因为你如果忘记了平衡二叉树是什么
也不知道平衡因子怎么算的话，建议你去上边，查看平衡二叉树定义，以及平衡因子计算方法
不需要看多，就看这两个，别看着看着，点开blbl，结果看美女去了☝🏻🤣
言归正传，不是阿甘正传
假设你知道平衡因子计算，就是这个点的左子树和右子树高度差，哈哈哈哈哈
其实你不上去看，继续看我也会告诉你，哎，我老是忍不住啊啊啊啊啊啊啊
       A
   B       C
D
这样的二叉树中的A的平衡因子是多少？是1，怎么来的，2-1=1（你不会看不懂个吧？🐒🫤）
看不懂，我告诉你，A的左子树是B和D，两个，A的右子树是C一个，二个减去一个就是一个，2-1=1，别问我为什么2-1=1，这涉及到哲学
♂，别想多了，不是那个哲学，是正经哲学
好，然后我们构造层次为6的并且非叶子的平衡因子为1的二叉树
一步步来
                                           A
                                       B
这样满足条件吗？满足，但是高度为2，还差
                                           A
                                       B
                                    C
这样呢？不行啦，哪里不行？不是那里，是A，A没有右孩子，但是左孩子2个，2-0=2，多了，怎么办？
补呗
                                           A
                                       B       D
                                    C
好，现在满足了，当也才3层啊，继续，我知道你看的不耐烦了（你他妈一股脑搞到6层会死吗？傻逼），好好好，我搞😭😭
                                           A
                                       B       D
                                    C
                                 E
                              F
                          G
现在是有6层了，但是平衡因子严重多处不符，没事，考研嘛，总是把那些耐不住性子的人剔除，咱耐心，穿针引线一步步来
我们看A肯定是最严重的，左5-右1=4，也就是右边要加3个
怎么加是关键
                                           A
                                       B       D
                                    C        H
                                 E
                              F
                          G
我现在加了H，刚好让D成为平衡因子为1的节点，因为此时D不是叶子了，那我们下一个加哪里？既然我们想要的是右子树的层数，肯定是接着H下面
                                           A
                                       B       D
                                    C        H
                                 E         I
                              F
                          G
好，现在I放进去，但是D的平衡因子变成2了啊，怎么办？补呗，你还想不劳而获？我也想
                                           A
                                       B       D
                                    C        H   J
                                 E         I
                              F
                          G
ok，现在D的平衡因子变1了，接着我们的补层数
                                           A
                                       B       D
                                    C        H   J
                                 E         I
                              F         K
                          G
皆大欢喜，A的右子树层数为4了，刚好让A的平衡因子为1，但是有人喜就有人忧
是谁在哭泣啊？当然是我们的D公主啦，D的左树比右树多2个，怎么办？补啊
                                           A
                                       B       D
                                    C        H   J
                                 E         I    L
                              F         K
                          G
补的是J的左子树L，现在H哭了，竟然没人关心他，他也是左2右0啊啊啊啊
                                           A
                                       B       D
                                    C        H   J
                                 E         I  M L
                              F         K
                          G
至此右子树施工完毕，按照上面的方法补全左子树
                                               A
                                       B                D
                                    C     N         H       J
                                 E   R   O   P    I   M   L
                              F    S  U T       K
                          G
大功告成！数下来刚好20个，over
没事，我知道自己画了一团屎🫤🫤
            <hr>
<strong>35.下面给出的排序中，不稳定的排序算法是</strong>
A.插入排序
B.冒泡排序
C.二路归并
D.堆
答案：D
别急，别骂街，这麽简单的题目，我拿出来自然是为了水字数
A的插入排序，回想一下，插入有直接插入和希尔以及折半插入
直接插入就是假定第一个是排好的，然后依次从后面取一个放到已经排好的序列中，从排好的序列中从后往前比较大小，实现插入正确位置
也就是说，这种排序是稳定的，两个关键字相同的，一个前一个后，不会说经过排序后面跑前面去
折半，和直接插入的区别在于每次也是从后面选一个加入已经排好的序列，但是不是傻瓜一样从后往前依次比较
采用折半查找的方式，找到自己的为然后直接插进去，讲究快(还行🫤)准(不准就不学你了😐)狠(这个字不是狼)
希尔就是增量的方式，比如每5个进行一组排序然后交换(这里不属于交换排序是因为，这个是夸几个进行交换，交换是连着的两个交换是交换排序)
希尔每5个进行排，就可能导致相同的被打乱（还不清楚去看上面的希尔排序介绍）
冒泡排序就是交换排序，因为从第一个开始每次比较相邻两个大小，一趟可以选出一个最大或者最小的
冒泡是因为连续比较所以稳定（不是连续所以稳定，是因为相同关键字在排序过后前后位置不变才稳定）
二路归并，重要在于归并两个字，不知道你听说过分治法没，没有算了，如果听过，其实就是分-治哈哈哈哈，我没有说废话！
归并的意思就是两个合并成一个（这里是指二路），具体点
{1，5}和{2，9}怎么合并？
分别比较两个数组的第一个，始终是第一个
1和2比，1小放进我们的新数组中，新数组开辟的大小由两个数组大小的和觉得
{1，}
现在变成了{，5}和{2，9}
比较5和2，2小，2放进去
{1，2，}
比较{，5}和{，9}的5和9
5小，5放
{1，2，5，}，由于第一个数组没有数字了，依次把第二个数组放进去就行，因为两个数组，自己本身内部是有序的
{1，2，5，9}，归并思路就是如此，所以归并也不会改变相同关键字前后位置。
            <hr>
<strong>36.若一个有向图的邻接矩阵中，主对角线以下的元素均为零，则该图的拓扑有序序列是否存在？</strong>
答案是：存在
拓扑是每次选择入度为0的点，删除它以及它的边
邻接矩阵主对角线下全为0意味着什么？
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>3</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>3</mn></mtd><mtd><mn>4</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></math>
意味着高节点到底节点没有入度，低到高可能有，还不止一个
我们本来就是从低到高，依次选入度为0，并且删除的，刚好符合拓扑的想法
<hr>
<strong>37.设H(x)是一个哈希函数，有K个不同关键字,满足H(x1)=H(x2)=...=H(xk)若采用线性探测法将这k个关键字存入哈希表中，至少要探测多少次？</strong>
答案：k(k-1)/2
这个问题，值得深思，初看，你可能会觉得，啊，最少，那不就是第一次放入就行了？
都没有冲突，就是K次嘛
注意审题，H(x1)=H(x2)=...=H(xk)说明，每一个关键字的哈希值都一样
也就是说，都是冲突的
第一个放，需要0次探测，以为直接放嘛
第二个放，需要1次，第三次需要2次
第k个放，需要k-1次
S=项数（首项+末项）/2
项数k
首项0
末尾k-1
S=k(k-1)/2
你是不是好奇第一个为什么是0，以为线性探测是在冲突发生的时候使用的哟，怎么还没有捡芝麻就丢了西瓜
也就是第二个才冲突，所以第二个是1
 <hr>
<strong>38.(多选)将森林转换成对应的二叉树，若在二叉树中，节点u是节点v的父节点的父节点，则在原来的森林中，u和v可能具有的关系是</strong>
A.父子关系
B.兄弟关系
C.u的父节点与v的父节点是兄弟关系
答案：AB
还记得左孩右兄吗？森林、树，二叉树的转换规则
题目说u是v的双亲的双亲
一共的可能性就是
                u
             X
               V
            -------
                 u
              x
           v
            -------
            u
               x
                  v
            --------
            u
               x
            v
            --------
一共就这四种
第一个就是左孩然后右兄，也就是v是u的孩子节点，v与x是兄弟节点
第二个是左孩然后再左孩，也就是v是x的孩子，u是x的孩子，u就是v的双亲的双亲了
第三个u和x和v之间是兄弟关系
第四个v是u的兄弟x的孩子，也就是v的双亲x的兄弟是u
所以就选A和B
            <hr>
<strong>39.设顺序存储的某线性表共有123个元素，按分块查找的要求分为3块。(想吃蛋糕了😰)索引表采用顺序查找方法来确定子块，且在确定的子块中也采用顺序存储查找方法，则在等概率的情况下，分块查找的平均查找长度为</strong>
A.21
B.23
C.41
D.62
答案：B
分块，索引这些关键词没有触发你吗？
123分3块，一块就是41，也就是我们一开始就要从3个选一个
这可是顺序查找，什么意思？【A】【B】【C】【D】【E】【F】
第一次查找，走到A，需要查1次
第二次查找，走到B，需要查找2次
第三次查找，走到C，需要查找3次
。。。
是的，顺序查找就是这样
好，我们第一轮分3块，也就是说
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mrow><mn>3</mn><mo stretchy="false">(</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>×</mo><mfrac><mn>1</mn><mn>3</mn></mfrac></math>
因为等分3块，每一块不就是还要除以3嘛
好，第一轮我们算出来了，第二轮就是在41个里面选，为什么是41？因为第一轮已经确定了，你的数在三块中的哪一块了
还是顺序查找
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mrow><mn>41</mn><mo stretchy="false">(</mo><mn>41</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>×</mo><mfrac><mn>1</mn><mn>41</mn></mfrac><mo>=</mo><mn>21</mn></math>
所以我们两轮的平均查找都算完了，我们加起来就行
21+2=23
            <hr>
<strong><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd></mtd></mtr><mtr><mtd></mtd><mtd><mn>40.</mn><mo>将一个</mo><mi>A</mi><mo stretchy="false">[</mo><mn>1.</mn><mo>.</mo><mn>.100</mn><mo>,</mo><mn>1.</mn><mo>.</mo><mn>.100</mn><mo stretchy="false">]</mo><mo>的三对角矩阵，按行优先存入一维数组</mo><mi>B</mi><mo stretchy="false">[</mo><mn>1.</mn><mo>.</mo><mn>.298</mn><mo stretchy="false">]</mo><mo>中，</mo></mtd></mtr><mtr><mtd></mtd><mtd><mi>A</mi><mo>中元素</mo><msub><mi>A</mi><mrow><mn>66</mn><mo>,</mo><mn>65</mn></mrow></msub><mo stretchy="false">(</mo><mo>下标</mo><mn>66</mn><mo>,</mo><mn>65</mn><mo stretchy="false">)</mo><mo>在数组</mo><mi>B</mi><mo>中的位置</mo><mi>K</mi><mo>为</mo></mtd></mtr></mtable></math></strong>
A.198
B.195
C.197
答案：B
三对角矩阵，你学过线性代数啦？就是三线行列式
这里用一个公式就行
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>3</mn><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo>≤</mo><mi>K</mi><mo>&lt;</mo><mn>3</mn><mi>i</mi><mo>−</mo><mn>1</mn></math>
如果是以行优先，i就是行数，如果是列优先，i就是列数
这里是行，i就是行数66
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>3</mn><mo stretchy="false">(</mo><mn>66</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>≤</mo><mi>K</mi><mo>&lt;</mo><mn>3</mn><mo>×</mo><mn>66</mn><mo>−</mo><mn>1</mn></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>194</mn><mo>≤</mo><mi>K</mi><mo>&lt;</mo><mn>197</mn></math>
然后对比选项，就是195了
            <hr>
算法原地工作是需要少量的辅助空间的，不是不需要。同一个算法，实现语言越高不一定效率越低。
            <hr>
AOE网（Activity On Edge Network）用边表示活动，用顶点表示事件（活动的完成）。边是带权的，表示活动需要的时间。
             <hr>
<strong>二叉树的创建，以及前中后序</strong>
<code>
/*二叉树的创建和遍历*/
#include< stdio.h>
#include< stdlib.h>
//二叉树的创建
typedef struct TreeNode {
	char data;
	struct TreeNode *lchild;
	struct TreeNode *rchild;
}TreeNode;
void creatTree(TreeNode**T)
{
	char ch;
	scanf_s("%c\n", &ch);
	//这里为什么放一个换行符？
	//因为你喜欢回车，回车也是字符被读入，所以会导致一直进行下去
	if (ch == '#')
	{
		*T = NULL;
	}
	else
	{
		*T = (TreeNode*)malloc(sizeof(TreeNode));
		(*T)->data = ch;
		creatTree(&((*T)->lchild));
		creatTree(&((*T)->rchild));
	}
}
void pre(TreeNode *T)
{
	if (T == NULL)
	{
		return;
	}
	else{
		if(T!=NULL)
		printf("%c", T->data);
		pre(T->lchild);
		pre(T->rchild);
	}

}
void in(TreeNode* T)
{
	if (T == NULL)
	{
		return;
	}
	else {

		in(T->lchild);
		printf("%c", T->data);
		in(T->rchild);
	}

}
void le(TreeNode* T)
{
	if (T == NULL)
	{
		return;
	}
	else {

		le(T->lchild);
		le(T->rchild);
		printf("%c", T->data);
	}
}
int main()
{
	printf("这是树的创建\n");
	TreeNode *T;
	creatTree(&T);//测试使用ABD##E##CF##G###，多出来的一个#是C的缺陷
	//之所以有#是因为二叉树空后代都要标出来
	//这是使用前序遍历创建二叉树
	printf("\n前序遍历为：\n");
	pre(T);
	printf("\n中序遍历为：\n");
	in(T);
	printf("\n后序遍历为：\n");
	le(T);
	return 0;
}
</code>
<hr>
<strong>二叉树的层序遍历</strong>
<code>
/*二叉树的层序遍历*/
#include< stdio.h>
#include< stdlib.h>
//二叉树的创建
typedef struct TreeNode {
	char data;
	struct TreeNode *lchild;
	struct TreeNode *rchild;
}TreeNode;
typedef struct Queue
{
	TreeNode* data;
	struct Queue* pre;
	struct Queue* next;
}Queuel;
void creatTree(TreeNode**T,char*str,int*index)
{
	char ch;
	ch = str[*index];
	(*index)++;
	if (ch == '#')
	{
		*T = NULL;
	}
	else
	{
		*T = (TreeNode*)malloc(sizeof(TreeNode));
		(*T)->data = ch;
		creatTree(&((*T)->lchild),str,index);
		creatTree(&((*T)->rchild),str,index);
	}
}
void pre(TreeNode *T)//前序遍历
{
	if (T == NULL)
	{
		return;
	}
	else{
		if(T!=NULL)
		printf("%c", T->data);
		pre(T->lchild);
		pre(T->rchild);
	}

}
void in(TreeNode* T)//中序遍历
{
	if (T == NULL)
	{
		return;
	}
	else {

		in(T->lchild);
		printf("%c", T->data);
		in(T->rchild);
	}

}
void le(TreeNode* T)//后序遍历
{
	if (T == NULL)
	{
		return;
	}
	else {

		le(T->lchild);
		le(T->rchild);
		printf("%c", T->data);
	}
}
Queuel* initQueue()//初始化队列
{
	Queuel* Qnead = (Queuel*)malloc(sizeof(Queuel));
	Qnead->data = NULL;
	Qnead->next = Qnead;
	Qnead->pre = Qnead;
	return Qnead;
}
void addQueue(TreeNode* T,Queuel*Qhead)//队尾增加元素
{
	Queuel *node = (Queuel*)malloc(sizeof(Queuel));
	node->data = T;//将树结点存储结点
	node->pre = Qhead;//让新结点的前驱指向头
	node->next = Qhead;//让新结点的后继指向头
	Qhead->pre->next = node;//让最后一个结点指向新结点
	Qhead->pre = node;//让头的前一个指向新结点
}
Queuel* deleteQueue(Queuel* Qhead)//队头删除元素
{
	if (isEmpty(Qhead))//如果链表为空则删除失败
	{
		return NULL;
	}
	else {
		Queuel * Qnode = Qhead->next;//建立一个结点存储我们要删除的
		Qhead->next->next->pre = Qhead;//让头结点的后继的后继的前驱指向头
		Qhead->next = Qhead->next->next;//让头的后继指向后继的后继
		return Qnode;//返回删除的结点
	}
}
int isEmpty(Queuel* Q)
{
	if (Q->next==Q)//队列判空
	{
		return 1;
	}
	else {
		return 0;
	}
}
void level(TreeNode* T,Queuel *Qhead)//层序遍历
{

		addQueue(T, Qhead);//进入第一个结点
		while (!isEmpty(Qhead))//判断队列是否为空
		{
			Queuel* outnode = deleteQueue(Qhead);//建立一个结点存储出队列的结点
			printf("%c", outnode->data->data);//打印这个结点
			if (outnode->data->lchild)//如果结点有左子树
			{
				addQueue(outnode->data->lchild, Qhead); //就让左子树进入
			}
			if (outnode->data->rchild)//如果结点有右子树
			{
				addQueue(outnode->data->rchild, Qhead);//就让右子树进入
			}

	}

}
int main()
{
	printf("这是树的创建\n");
	TreeNode *T;
	char * str = "ABD##E##CF##G###";
	int index = 0;
	creatTree(&T,str,&index);
	printf("\n前序遍历为：\n");
	pre(T);
	printf("\n中序遍历为：\n");
	in(T);
	printf("\n后序遍历为：\n");
	le(T);
	printf("\n层序遍历为：\n");
	Queuel * Qhead = initQueue();
	level(T, Qhead);
	return 0;
}
</code>
           <hr>
<strong>二叉树的前中后序遍历(非递归)</strong>
这里主要使用了，<span style="color: red">栈来模拟前序遍历</span>，根进根出，右先进左再进
为什么右先进呢，因为是栈，所以后进才能先出
左退，左的右孩先进左孩子再进...

<span style="color: red">后序遍历</span>：我们前序是：根左右，后序是：左右根
假如现在我们让左孩子先进，右孩子后进，也就是右孩子先出，左孩子后出
是不是就是中右左
我们把中右左存入数组，如何整体翻转一下
那不就是左右中了！

以上前序和后序   判断停止条件就是栈不为空
-----------------------------------------
中序遍历：左中右
还是借助栈来实现
一路向左，接连入栈，直到有人左孩子是空
此时弹出栈顶元素
此时判断栈顶元素的右孩子是否为空
如果不为空，右孩子入栈，判断右孩子的左孩子是否为空，如果不为空一路向左入栈
假如栈顶元素的右孩子也空，那么继续输出栈顶元素
什么时候停止呢？就是栈为空的时候，别想多了，第一次入栈是放到判空的外面的、
值得注意的是，需要一个指针来遍历节点，用栈来存储遍历过的节点
<code class="search-container">
    /*二叉树的前中后序遍历的非递归
1.入栈根节点
2.循环，直到左孩子为空
3.出栈，访问节点，入栈右孩子
*/
#include< stdio.h>
#include< stdlib.h>

//二叉树的创建
typedef struct TreeNode {
	char data;
	struct TreeNode *lchild;
	struct TreeNode *rchild;
}TreeNode;
typedef struct StackNode {//栈
	TreeNode* data;
	struct StackNode* next;
}StackNode;
void creatTree(TreeNode**T,char*str,int*index)
{
	char ch;
	ch = str[*index];
	(*index)++;
	if (ch == '#')
	{
		*T = NULL;
	}
	else
	{
		*T = (TreeNode*)malloc(sizeof(TreeNode));
		(*T)->data = ch;
		creatTree(&((*T)->lchild),str,index);
		creatTree(&((*T)->rchild),str,index);
	}
}
StackNode* initStack()
{
	StackNode* S = (StackNode*)malloc(sizeof(StackNode));
	S->data = NULL;
	S->next = NULL;
	return S;
}
void StackPush(TreeNode* T, StackNode* S)
{
	StackNode* node = (StackNode*)malloc(sizeof(StackNode));
	node->data = T;
	node->next = S->next;
	S->next = node;
}
int isEmptyStack(StackNode* node)
{
	if (node->next == NULL)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
StackNode* StackPop(StackNode* S)
{
	if (isEmptyStack(S))
	{
		return NULL;
	}
	else
	{
		StackNode* node = S->next;
		S->next = node->next;
		return node;
	}
}
void pre(TreeNode *T)//前序遍历
{
	TreeNode* node = T;
	StackNode* S = initStack();//初始化一个栈
	while (node||!isEmptyStack(S))//当树节点不为空或者栈不为空
	{
		if (node)//当节点非空
		{
			printf("%c",node->data);//打印这个节点
			StackPush(node,S);//将这个节点入栈
			node = node->lchild;//进入这个节点的左孩子
		}
		else//当节点为空
		{
			node = (StackPop(S))->data;//将父节点出栈并赋予当前节点
			node = node->rchild;//进入父节点的右孩子，进入右孩子如果还为空
			//还会进入这个父节点的父节点，然后再进入右孩子，以此类推
		}
	}

}
void in(TreeNode* T)//中序遍历
{
	TreeNode* node = T;
	StackNode* S = initStack();//初始化一个栈
	while (node || !isEmptyStack(S))//当树节点不为空或者栈不为空
	{
		if (node)//当节点非空
		{
			StackPush(node, S);//将这个节点入栈
			node = node->lchild;//进入这个节点的左孩子
		}
		else//当节点为空
		{
			node = (StackPop(S))->data;//将父节点出栈并赋予当前节点
			printf("%c", node->data);//打印这个空节点的父节点
			node = node->rchild;//进入父节点的右孩子，进入右孩子如果还为空
			//还会进入这个父节点的父节点，然后再进入右孩子，以此类推
		}
	}

}
StackNode* getTop(StackNode* S)
{
	if (isEmptyStack(S))
	{
		return NULL;
	}
	else
	{
		StackNode* node = S->next;
		return node;
	}
}
void le(TreeNode* T)//后序遍历
{
	StackNode *S=  initStack();//初始化栈
	TreeNode* node = T, * r = NULL;//r标记最近访问过的节点
	while (node || !isEmptyStack(S))//当节点不为空或者栈不为空的时候
	{
		if (node)//如果节点不为空
		{
			StackPush(node,S);//将节点入栈
			node = node->lchild;//将节点进入它的左子树
		}
		else  //当节点为空
		{
			TreeNode* top = getTop(S)->data;//取得它的父节点

			if (top->rchild && top->rchild != r)//如果栈顶节点的右孩子不为空，并且没有访问过
			{
				top = top->rchild;//右孩子进入栈顶
				StackPush(top, S);//将右孩子加入栈顶
				node = top->lchild;//加入右孩子的左孩子节点
			}
			else//栈顶没有右孩子或者右孩子被访问过
			{
				top = StackPop(S)->data;//取出栈顶元素
				printf("%c",top->data);//打印栈顶元素
				r = top;//将当前栈顶标记为被访问
			}
		}
	}

}
int main1()
{
	printf("这是树的创建\n");
	TreeNode *T;
	char * str = "ABD##E##CF##G###";
	int index = 0;
	creatTree(&T,str,&index);
	printf("\n前序遍历为：\n");
	pre(T);
	printf("\n中序遍历为：\n");
	in(T);
	printf("\n后序遍历为：\n");
	le(T);
	return 0;
}
</code>
        </pre>
<strong>翻转链表</strong>
        <pre>
            <code class="block">
/*双指针实现翻转链表*/
/*
| a | -> | b | -> | c | -> | d | -> | e |
| a | <- | b | <- | c | <- | d | <- | e |
*/
/*
  pre      cue
  ↓       ↓
  NULL    | a | -> | b | -> | c | -> | d | -> | e |
*/
/*
           pre      cue
            ↓       ↓
  NULL  <-| a | -> | b | -> | c | -> | d | -> | e |
*/
/*
                     pre      cue
                     ↓       ↓
  NULL  <-| a | <- | b | -> | c | -> | d | -> | e |
*/
//没错，正常人看不懂我的鬼画符
/*通俗来讲，就是借助两个指针,让pre指向空，cue指向第一个*/
/*
然后再让cue指向的第一个指向pre也就是第一个节点反转
然后pre和cue整体后移，pre指向第一个，cue指向第二个
再让cue指向的东西指向pre，就是反转第二个
那什么时候结束呢？
                                               pre    cue
                                                ↓    ↓
  NULL  <-| a | <- | b | -> | c | -> | d | -> | e |->NULL
  没错，当cue指向null的时候就不需要翻转了
  简单！🫵🏿🤣
*/
/*
很好，我们看这一步
  pre      cue
  ↓       ↓
  NULL  <-| a |    | b | -> | c | -> | d | -> | e |
           pre      cue
            ↓       ↓
  NULL  <-| a | -> | b | -> | c | -> | d | -> | e |
是不是第一个的下一个，已经翻转了，我的下一个都没了，我的pre和cue如何后移？
很好，我们需要一个零食指针，不对，是临时指针
保存temp = a->next，如何将cue = temp
*/
 turn()
{
     cue = Node->head;//让cue指向链表第一个节点
     pre = NULL;//pre设置为空，目的是模拟链表最后一个就是指向空
     while (cue)//当cue为空的时候停止
     {
         temp = cue->next;//使用临时变量保存节点的下一个
         cue->next = pre;//让当前节点指向前面一个
         pre = cue;//整体后移
         cue = temp;//整体后移
     }//完成翻转
     return pre;//返回翻转后的头结点,cue指向的是null啊，蠢猪
}
            </code>
        </pre>
<strong>两两交换链表</strong>
<pre>
<code class="block">
/*两两交换链表中的节点*/
/*
| a | -> | b | -> | c | -> | d | -> | e | -> | f | -> | g |->NULL
| b | -> | a | -> | d | -> | c | -> | f | -> | e | -> | g |->NULL
怎么变？

               ↗→→→→→→→→→→
             ↗    ↓  ←   ↰       ↓
   head      ⇦   | a | -> | b | -> | c | -> | d | -> | e | -> | f | -> | g |->NULL
    ↑ ↘
    ↑    ↘→→→→→→ →↗
   cue
   如果你想象这都是绳子，一拉直，就是变换好了
*/
/*
               | b | -> | a | -> | c | -> | d | -> | e | -> | f | -> | g |->NULL
                         ↑
                         cue
cue指向的后面两个进行变换
*/
/*什么时候为停止？*/
/*
当cue指向的后一个为空的时候，或者cue指向的下一个的下一个为空，因为不足两个
也停止
这里是或的条件
当然了
if(cue->next!=NULL&&cue->next->next!=NULL)
这两个条件是不能写反的，因为如果cue的下一个是空，你还能对空取它的下一个吗？
*/
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* swapPairs(struct ListNode* head) {

    struct ListNode* pre = head->next;
    struct ListNode* cue = pre;
    while (cue->next != NULL && cue->next->next != NULL)
    {
        struct ListNode* temp1 = cue->next;
        struct ListNode* temp2 = cue->next->next->next;
        cue->next = cue->next->next;
        cue->next->next = temp1;
        temp1->next = temp2;
    }
    return pre->next;
}
            </code>
        </pre>
<strong>翻转二叉树</strong>
        <pre>
<code class="block">
/*翻转二叉树*/
/*你画个二叉树，然后将整个树盖到纸上*/
/*类似镜像*/
/*注意嗷，不是交换左右孩子的数值，是左右孩子的指针*/
/*用前序和后序是比较好的*/
TreeNode* invertTree(root)//前序实现
{
	if (root == NULL)//如果树为空，就返回空
		return root;
	swap(root->left, root->right);//交换左右子树
	invertTree(root->left);
	inverTree(root->rright);
}

TreeNode* invertTree(root)//后序实现
{
	if (root == NULL)//如果树为空，就返回空
		return root;
	invertTree(root->left);
	inverTree(root->rright);
	swap(root->left, root->right);//交换左右子树
}
            </code>
        </pre>
        <strong>对称二叉树</strong>
        <pre>
            <code class="block">
/*判断对称二叉树*/
/*
判断一个树是否为对称二叉树
具体思路就是，判断左-右孩子是否一样
注意这里的左右孩子不是一个根的左右
而是靠左侧最外侧的左孩子
以及右侧最外侧的右孩子
以及内部的左边的右孩子
和内部的右边的左孩子
递归三要数：开始停止过程
什么时候停止呢？
当左右子树都空停止？nonono
当左右子树只要有一个为空就停止返回失败
如果这里想不明白，那你还是没有区别我说的左右子树
这里的左右子树是最左边，以及最右边的树
你都有一个为空了，还对称个毛线
当然了，左右子树都不为空，但是值不等的时候也返回失败
使用后序遍历现实《递归》
*/
bool compare(TreeNode* left,TreeNode *right)//比较的实现
{
	if (left = NULL && right != NULL)//但凡有一边为空就失败
		return false;
	else if (left != NULL && right == NULL)//但凡有一边为空失败
		return false;
	else if (left->val != right->val)//数值不相等也为空
		return false;
	else if (left == NULL && right == NULL)//当都为空的时候，也是对称，返回成功
		return true;//除以上几种情况外的，到最后都会到两边都为空的，所以不用判断
	bool ouside = compare(left->left, right->right);//相对于判断你的两个胳膊是不是对称
	bool inside = compare(left->right, right->left);//相对于判断你的两条腿是不是对称
	bool result = outside && inside;//如果胳膊和腿同时对称才是对称
	return result;//返回比较的结果
}
            </code>
        </pre>
<strong>二叉树最大深度</strong>
        <pre>
            <code class="c">
/*求解二叉树的最大深度*/
/*
-----------------------------------
深度：任意节点到根节点的距离，本身和根节点都算进去，用先序遍历
根左右

高度：任意一个节点到叶子节点的距离，本身和叶子节点都算进去，用后序遍历
左右根

也就是说求高度就是需要从下往上遍历
后序遍历刚好就是左右（下），然后根（上）
通过返回当前节点高度给根，然后根+1就是，根节点的高度

也就是说求深度就是需要从上往下遍历
后序遍历刚好就是根（上），然后左右（下）
通过返回当前根节点高度给孩子，然后孩子+1就是，孩子节点的深度


重点：最大深度就是根节点的高度

-----------------------------------
*/
int gethight(TreeNode* node)
{
	if (node == NULL)
	{
		return 0;
	}//终止条件
	//单层递归过程如下
	int lefthight = gethight(node->left);//进入左
	int righthight = gethight(node->right);//进入右
	int heigh = 1 + Max(lefthight, righthight);// 取左右孩子最大值，然后+1，因为自己也算一个
	//就是左右根，后序遍历求根高度，就是最大深度
	return heigh;
}
            </code>
        </pre>
<strong>二叉树的最小深度</strong>
        <pre>
            <code>
/*二叉树最小深度*/
//根节点到最近叶子节点的距离
//后序遍历
int gethight(TreeNode* node)
{
	if (node == NULL)//明确递归终止条件
	{
		return 0;//空节点的高度是0
	}
	int left_height = gethight(node->left);//遍历左子树
	int right_hight = gethight(node->right);//遍历右子树
	if (node->left == NULL && node->right != NULL)//当左为空，右不为空，取右边，因为深度不包括空节点
	{
		return 1 + right_hight;
	}
	if (node->right == NULL && node->left != NULL)//当右为空，左不为空，取边
	{
		return 1 + left_height;
	}
	//还有就是都不为空的时候，取左右子树最小高度即可
	int result = 1 + min(left_hight, right_hight);
	return result;
}
            </code>
        </pre>
        <strong>完全二叉树节点数量</strong>
        <pre>
            <code class="c">
/*完全二叉树的节点数量*/
//后序遍历
//
//普通二叉树
int getNum(TreeNode* node)
{
	if (node == NULL)
		return 0;
	leftNum = getNum(node->left);//左
	rightNum = getNum(node->right);//右
	int result = leftNum + rightNum + 1;//中
	return result;
}

//完全二叉树
//计算思路，借助满二叉树的节点计算辅助计算完全二叉树
//例如深度为3的满二叉树就是2的3次方-1
//通过拆分左右子树，来形成满二叉树计算的式子
//判断子树是否为满二叉树，只需要向左走到底，和向右走到底
//左右深度一样就是满二叉树，单独的叶子节点一定是满二叉树

int getNum(TreeNode* node)
{
	if (node == NULL)//递归终止条件
	{
		return 0;
	}
		TreeNode* Left = node->left;
		TreeNode* Right = node->right;
		int leftpath = 0;//计量左侧深度
		int rightpath = 0;//计量右侧深度
		while(Left)//去遍历左侧
		{
			Left = Left->left;
			leftpath++;
		}
		while (Right)//遍历右侧，统计右侧深度
		{
			Right = Right->right;
			rightpath++;
		}
		if (leftpath == rightpath)//如果两边相等，就是满二叉树
		{
			return (2<< leftpath)-1 //计算子树节点数量,左移一位就是平方，以此类推
		}
		//以下是单层递归的逻辑
		int leftnum = getNum(node->left);//去计算左树
		int rightnum = getNum(node->right);//去计算右树
		int result = leftnum + rightnum;
		return result;

}
            </code>
        </pre>
<strong>合并二叉树</strong>
        <pre>
            <code>
/*合并二叉树*/
//现在有两棵二叉树
//如果有对应节点，则节点相加
//如果一棵有，一棵没有就是把有的放上去，连带其子树
//使用前序，根左右

TreeNode* margeTree(TreeNode* t1, TreeNode* t2)
{
	if (t1 == NULL)//终止条件
	{
		return t2;//如果t1此处没有点，就把t2此处点返回
		//反正不管t2也没有，就当它现在有，至少得让它证明自己
	}
	if (t2 == NULL)
	{
		return t1;
	}
	//以下是单层递归逻辑
	t1->value += t2->value;//都不为空就是相加(中)
	t1->left = margeTree(t1->left, t2->left);//让合并的树就在t1上表现，左子树就是t1，t2的合并（左）
	t1->right = margeTree(t1->right,t2->right);//让合并的树就在t1上表现，右子树就是t1，t2的合并（右）
	return t1;//返回被覆盖的t1

}
            </code>
        </pre>
    </div>
<pre>
<code>
    快来看这有个美女摔倒啦！🫵🏿🤣
                      _ _-^^"-,---,
              _-""./  ||//_  /
            _< _../    <-"__)'
    _..--'''         _.-"  \
  .'         _..--""' `  ` \
  `,    _..-" ' /      `   |
    \  ' \   ' |  //||\    \
     \  /"|      // -- |   /
      \/ \|   |""   G>/  ,/`.
     ,'   `   '. -  .;-""    |
    <'     \""\ \_"  /  _.-_"
     `\      _ "//-.'.-" --."\
       \    (c`//// /  /"   \ |
        "-___/| U |  ,/      \|
             "|  /  ,'        \
              / /   | |  .     ,
             (  (   ) J /      |
              \  \   \."   .   /
               '  "-_/   /'   /
                `.   \==.    """-._
                  \      `+-'./~   ".
              ,.   "-_   /  //'   .- \
         _.--"  ""--_-"-/       /"    `,
       /"        \           |-<--""-  |
       |  -.__..--""""""'-->'`         |
       /  |      .-")/"  ,'   \        J
      |   \   .-"  ..-"""  _.-'        J
       \   \  ' <"/     ./"         ./'/
        \.  \_.-,'`\   /    _      ((  |
          \    /    \        \      '\/,
           \ ,'      \_       \      / _\
            /        _/--""""\_'(   ""' /
           /      _/'/        /\_    _-"
          /      <-"/       <'   "\ /
         /         /      ." "-"=-""     __.
         \,       /      /_   |   """-/""   `.
           `-----Y       " ""-_         \    |
                 (             ". __     +   |
                  `-___          `\.""-/\|   |
                       `--._       /  <.  \) `,
                            ""-._ /     "\    |
                                 "._       ""-\C.-.
                                    "-._      /ryt|
                                        "-   )    '
                                        < \_ /   /
                                         `\ ",  /
                                           )|,  |
                                           |    '
                                           '   /
                                          |   '
                                          \ ,'
                                           "

</code>
</pre>
    <script>
        function toggleExplanation(button) {
            var explanation = button.nextElementSibling;
            if (explanation.style.display === 'none' || explanation.style.display === '') {
                explanation.style.display = 'block';
            } else {
                explanation.style.display = 'none';
            }
        }
    </script>

    <div id="algorithm-container">
        <h1 id="algorithm-title">算法经典题</h1>
觉得页面太小点击下面链接
        <a href="../algorithm.html" target="_blank">算法</a>
        <iframe src="../algorithm.html" title="算法"></iframe>
    </div>
    <div class="block">
        <h1>C语言总结</h1>
        <h2>基本要点和易错点</h2>
        <pre>
函数是组成C程序的基本单位，语句是组成C程序的最小单位。
-------------------------------------------------------------
C程序总是从main开始，main结束
-------------------------------------------------------------
三种结构：顺序，选择，循环
-------------------------------------------------------------
开发C过程：编辑、编译(.obj)、连接(.exe)、执行。其中obj是在编译完后才有，exe同理
-------------------------------------------------------------
C的基本数据类型(5种)：整型、字符、单精度浮点、双精度浮点、枚举
-------------------------------------------------------------
变量定义以及变量声明：定义是创建，声明是告诉编译器别处存在，不需要重新创建，我要使用别处的。
-------------------------------------------------------------
空白字符不能出现在整数数字之间
-------------------------------------------------------------
字符常量(4种)：普通字符常量、字符串常量、转义字符、符号常量
-------------------------------------------------------------
实型常量：.前可以省略，e后必为整型
-------------------------------------------------------------
转义字符只能用小写
-------------------------------------------------------------
自增自减只能用于<span style="color: red">单个变量</span>
-------------------------------------------------------------
sizeof是单目运算符，而不是函数
-------------------------------------------------------------
运算符优先级口诀：成单乘加移等位辑赋//成员、单目、乘法、加减、移位、判等、位运算符、逻辑、赋值
-------------------------------------------------------------
printf中，从右向左计算出表达式的值//printf(，i++,i--),i++显示的值是i进行自减以后的
-------------------------------------------------------------
else与其前面最靠近的if配对
-------------------------------------------------------------
case后只能是整型或者字符型的常量或常量表达式
-------------------------------------------------------------
对数组不赋初值，那么会分配随机内存数，如果是static声明的，会自动分配0
-------------------------------------------------------------
static是静态变量的意思，只随着程序的销毁而销毁
-------------------------------------------------------------
数组定义时，只能省略后面的元素初始值，不能隔山大牛：[10,,3]
-------------------------------------------------------------
char s[5]={'a','b','c'}|char s[5]="abc"//这两种区别在于后者会被自动末尾添加一个'\0'
-------------------------------------------------------------
指针变量就是一个变量，就是指向double和指向int的指针本身大小是一样的，保存的就是地址
-------------------------------------------------------------
int a[10];a是指数组的首元素的地址，即a==&a[0],而"整个数组"的首地址是 &a
-------------------------------------------------------------
字符数组不能整体赋值，但是字符指针可以
-------------------------------------------------------------
void类型的函数，是可以使用return的。函数内部不能定义其他函数
-------------------------------------------------------------
函数定义出现在函数使用之前不会报错，也不需要函数声明，这个时候就是函数原型
-------------------------------------------------------------
函数参数的计算顺序是从右向左
-------------------------------------------------------------
auto是自动分配自动销毁，函数外部直接定义是全局，static是静态，与全局不同的是，它只能被本编译单位使用，extern使用的是直接声明，而不是static
-------------------------------------------------------------
编译预处理都以‘#’开头，每个预处理语句必须单独占一行
-------------------------------------------------------------
宏是在程序执行之前完成
-------------------------------------------------------------
文件中位置编号从1开始，第一个字节编号为1
-------------------------------------------------------------
输入数据的时候不能规定精度
-------------------------------------------------------------
\b是让光标位置回退一格，而不是向前删除一个字符
-------------------------------------------------------------
两指针相加没有意义
-------------------------------------------------------------
在二维数组中a[3][3],a[2]是一个地址，而不是a[2][0]这个值，但是a和a[0]指向的地址是一样的
-------------------------------------------------------------
一个文件中不一定必须要有main函数
-------------------------------------------------------------
头文件不一定以.h结束，.c也是一样的，头文件的h只是方便区分
-------------------------------------------------------------
e前e后必有数，e后必定为整数，小数点两边有一个是0，可省略
-------------------------------------------------------------
共用体的大小由共用体中所占最大的那个决定
-------------------------------------------------------------
#include< stdio.h>
int main()
{
	float a = 1.5;
	printf("%f", ++a);
}
//2.500000
没想到吧，浮点数也可以进行自加自减
-------------------------------------------------------------
~（取反）不能用于浮点数
-------------------------------------------------------------
右移操作有两种情况，一种是不管符号位是不是0，空缺位都补0，即逻辑移位；一种是符号位是什么，空缺位就补什么，即算术移位。
-------------------------------------------------------------
指针用惯了，但是结构体指针时，你想去下一个，可不兴指针++的方式
-------------------------------------------------------------
-：左对齐。
+：输出符号（正数前面加上“+”）。
#：八进制前缀（0）、十六进制前缀（0x 或 0X）或浮点数小数点（.）。
0：用 0 在左侧填充数据输出的空白，而不是默认的空格字符。
m.n：m 是指定的最小宽度，n 是指定的精度。
*：用来接收动态传入的宽度和精度。例如，%*.*f 表示输出浮点数，宽度和精度由后面带两个 int 类型的参数动态传入。
-------------------------------------------------------------
逗号表达式的值
表达式1，表达式2，表达式3....表达式n
从左到右，依次计算各个表达式，表达式n是整个逗号表达式的值
-------------------------------------------------------------
-------------------------------------------------------------
<hr>
<span style="color: red;font-size: 20px">字符串处理函数</span>(#include< string.h >)
<code type="c">puts(p);//其中p是字符指针，可以带有转义字符，并且puts会自动在末尾增加一个换行符
</code>
<code>
char a[30] = {'\0'};//定义一个字符数组
char* str = a;//初始化字符指针指向字符数组，必须初始化，一定要初始化
gets(str);//从标准输入中读取整行，直到遇见换行符然后丢掉换行，然后在末尾加入一个空字符形成C字符串,它是有缺点是，因为不知道str可以存多少个，所以会造成越界
puts(str);//打印一行，然后加上换行符。
fgets(str,10,stdin)//它接受三个参数，第一个是str，第二个是读入的字符最大量，第三个是指明读取的源头，这里是标准输入(键盘)，当读到换行(回车),或者第9个字符停止，如果是换行，那么会将换行保存
fputs(str,stdout)//接受两个参数，第二个是需要输出的地方，这里是标准输出，也就是屏幕，并且与pust不同的是，它不在末尾添加换行
strlen(str)//计算字符长长度
strcat(str1,str2)//拼接字符串,将第二个字符串拼接到第一个字符串后，形成的新串为第一个字符串，没错，可能会越界
strncat(str1,str2,最大添加字符数)//是的，这不就改良版来了，为什么上面那个没有像gets一样被官方废除，因为gets是用户输入，这个函数只有程序员的操作
strcmp(str1,str2)//比较两个字符串//相同返回0
strcpy(str1,str2)//把str2复制到str1中
strlwr(str)//大写变小写
strupr(str)//小写变大写
========================================================
double acos(double x)//反余弦
double asin(double x)
double atan(double x)
double atan2(double x,double y)
...重点关注库函数的参数是什么类型
接下来没讲是几乎都是double
double frexp(double x,int *exponent)//分解浮点数，将指数存到exponent中
double ldexp(double x,int exponent)//返回x乘以2的exponent次幂
========================================================
</code>
<hr>
</pre>
        <h2>文件</h2>
        <pre>
<span style="color: red;font-size: 20px">文件操作</span>
<table>
    <tr>
        <th>文件使用模式</th>
        <th>处理方式</th>
        <th>指定文件不存在</th>
        <th>指定文件存在</th>
    </tr>
    <tr>
        <td>r</td>
        <td>读取（文本文件）</td>
        <td>出错</td>
        <td>正常</td>
    </tr>
    <tr>
        <td>w</td>
        <td>写入（文本文件）</td>
        <td>建立新文件</td>
        <td>原有内容丢失</td>
    </tr>
        <tr>
        <td>a</td>
        <td>添加（文本文件）</td>
        <td>建立新文件</td>
        <td>原有内容后添加</td>
    </tr>
        <tr>
        <td>rb</td>
        <td>读取（二进制文件）</td>
        <td>出错</td>
        <td>正常</td>
    </tr>
        <tr>
        <td>wb</td>
        <td>写入（二进制文件）</td>
        <td>建立新文件</td>
        <td>原有内容丢失</td>
    </tr>
        <tr>
        <td>ab</td>
        <td>添加（二进制文件）</td>
        <td>建立新文件</td>
        <td>在原有内容后添加</td>
    </tr>
        <tr>
        <td>r+</td>
        <td>可读取，又可写入</td>
        <td>出错</td>
        <td>打开文件时，文件指针位于文件开头，无论是读取内容还是写入内容，都可在文件中任意位置进行，且进行写入操作时，会覆盖原有位置的内容。</td>
    </tr>
    <tr>
        <td>w+</td>
        <td>写/读</td>
        <td>建立新文件</td>
        <td>打开文件时，文件指针位于文件开头，文件原有内容丢失，无论是读取内容还是写入内容，都可在文件中任意位置进行</td>
    </tr>
        <tr>
        <td>a+</td>
        <td>读/添加</td>
        <td>建立新文件</td>
        <td>打开文件时指针位于文件末尾，在文件原有末尾添加，读取内容时，可以在任意位置进行，但写入内容时，只会追加在文件尾部。</td>
    </tr>
        <tr>
        <td>rb+</td>
        <td>读写</td>
        <td>出错</td>
        <td>正常</td>
    </tr>
        <tr>
        <td>wb+</td>
        <td>写读</td>
        <td>建立新文件</td>
        <td>原有内容清除</td>
    </tr>
        <tr>
        <td>ab+</td>
        <td>读添加</td>
        <td>建立新文件</td>
        <td>文件末尾添加</td>
    </tr>


</table>
<code>
FILE *p;//定义文件指针
p=fopen(文件名，文件使用模式);打开文件
fclose(文件指针)//关闭文件
feof(文件指针)//判断文件结束，是末尾返回非0值
ch = getc(p);//从文件流中读取一个字符赋给ch
ch = fgetc(p);//从文件流中读取一个字符赋给ch
putc(ch,p);//将ch写入到文件中
fputc(ch,p);//将ch写入到文件中
fgets(字符变量,n,p);//从p(文件流)中提取n-1个字符给字符变量
fputs(字符变量,p);//将字符变量中字符写入到p(文件)中
fprintf(p,格式串,输出项表);//写入，本质用法和printf一样例如fprintf(p,"这个是%d",10);
fscanf(p,格式串,输入项表);//读取，本质和scanf一样
fwrite(buf,size,count,p);//写入从buf提取count个size字节大小的数据到文件中
fread(buf,size,count,p);//读取count个size字节大小的数据到buf中
ftell(p);//获取指针当前位于文件的位置，返回相对于文件开头的位移量
fseek(p,位移量,0);//0(SEEK_SET)文件开头、1(SEEK_CUR)当前、2(SEEK_END)文件结尾，让指针从文件开头位移《位移量》个位移量，《位移量》为负就是向文件头，为正就是向文件尾，0就是到第三个参数位置
rewind(p);//重置指针位于文件开头
</code>
        </pre>
        <h2>语义“贪心”法</h2>
        <pre>
请看这个代码<code>a---b</code>
恶心吧🤣🫵🏿，我们如果碰到怎么办？我们当然是问问更加头疼的编译器，看看它怎么做
它说：该死的程序员
好，正话不多说，我们开始废话：
C语言中使用这个规则：从左到右一个字符一个字符读入，如果该字符可以组成一个符号，那么就读入下一个字符，然后判断是否能够组成一个符号
如果可以并且这两个字符可能是另外符号的组成就再继续读入，直到读入的字符不可能组成有意义的符号。
上面的代码a---b
读入a，接着-
-可以组成自减--，所以继续读入
a--，此时--已经不可能和别的组成有意义的符号了，于是
保持再读入-，再读入b
也就是(a--)-b//这段代码执行是a-b，然后a自减，为什么？因为这是a--,使用a然后a才能自减
        </pre>
        <h2>深度理解函数声明</h2>
        <pre>
请看这个代码<code type="c">(*(void(*)())0)()</code>
爽吗？
要回答这个问题，真傻逼，不知道谁天天研究这些恶心的东西
行吧
float a;//就是定义一个浮点变量
float *g();//()优先级最高，所以g和()结合，也就是说g()，g是一个函数，然后才是float *，也就是返回类型为浮点指针的函数g
float (*g)();//现在*g表明g是一个指针，float表明返回类型为float,()表明是一个函数，结合起来，g是一个指向返回类型为浮点的函数，也就说g是一个函数指针
接下来一步步分析
(
*//此时*与后面最近的()形成一个解引用的目的
(void(*)())//首先是*表明指针,是匿名指针，然后和()结合就是匿名指针函数，指向没有返回值的函数,加上括号表明是一个强制转换
注意*不是和(void(*)())先结合，因为这样没有意义，应该是(void(*)())和0结合
(void(*)())0表示，将0强制转换为指针函数，指向无返回值的函数
然后才是与*结合*(void(*)())0，表示解引用0，解出来就是0指向的函数本身可以想象成f
然后(f)()
也就是调用f这个函数
(*(void(*)())0)()//也就是调用一个函数，这个函数是被强制转的0，0指向的是一个无返回值的函数
        </pre>
        <h2 style="color: #00feff">C语言编程有关问题</h2>
        如果页面太小，请点击下面链接
        <a href="../C.html" target="_blank">C</a>
        <iframe src="../C.html" title="C"></iframe>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
    <div class="block">
        <h1>C++总结</h1>
        <h2>基础</h2>
        <pre>
<code class="cpp">
/*-------------------------------------------------------------*/
/*命名空间*/
namespace N1
{
	int a;//1.命名空间可以定义变量
	int aplus(){}//2.也可以定义函数
	namespace N2//3.命名空间也可以嵌套定义
	{
		int b;
	}
}
namespace N1//4.编译器允许多个相同的命名空间，编译器会自动合成一个
{
	int a;//5.这是错误的，因为这同一个命名空间，重复定义了
}
/*6.命名空间使用*/
//"::"在C++中是作用域限定符
//命名空间名称::命名空间成员
int test_1()
{
	N1::a = 10;//将命名空间中的成员a赋值为10
}
/*7.使用using 命名空间名称::命名空间成员*/
using N1::a;
int test_2()
{
	a = 10;//这样就可以直接使用
}
/*8.使用using 命名空间名称 将所有成员导入*/
using namespace N1;
int test_3()
{
	a = 10;//将命名空间中N1所有成员都引入
}
/*-------------------------------------------------------------*/
/*函数重载*/
int add(int x,int y)
{
	return x + y;
}
double add(double x, double y)
{
	return x + y;
}
//函数名相同，接受形参不同就是重载
//形参不同指参数个数、类型、顺序不同
//仅仅是函数返回类型不同不能说重载
/*-------------------------------------------------------------*/
/*引用*/
int main()
{
	int a = 10;
	int& b = a;
	//1.和指针不同的是，这里的b不是引用变量，是给a取别名
	//也就是说没有创建任何什么什么类型的变量，只是别名，不占空间
	//2.引用在定义时必须初始化，这一点和指针也不一样
	//3.一个变量可以有多个引用
	//4.一个引用只能引用一个实体，不能改变,看下面
	int c = 20;
	b = c;//这句话是指将c的值赋给a，b还是引用a
	//5.引用也分常引用和普通引用
	const int& d = a;//可以
	const int e = 10;
	int& f = e;//不行，因为普通引用不能引用常量
	//6.引用可以作为参数，效果和传入指针类似
	//7.引用作为函数返回值要小心，不能将局部变量作为返回引用
	//因为函数销毁，局部变量销毁，引用个蛋
	//8.没有多级引用
}
</code>
        </pre>
        <h2>面向对象</h2>
        <pre><code class="cpp">
/*-------------------------------------------------------------*/
/*类*/
//c中结构体只能定义变量，但是C++中结构体还能定义函数
struct N//用结构体来定义类，默认可见度是公共
{
	int a;//成员变量
	int b()//成员函数
	{
		return 0;
	}
};//别忘记分号
//C++中还喜欢用class来定义
class N//用class定义类默认是私有
{
	int a;//成员变量
	int b()//成员函数
	{
		return 0;
	}
	void Show();
};//别忘记分号
void N::Show()//在类体外定义类中成员需要使用::作用域解析符指明哪个作用域
{
	cout << "" << endl;
}
/*-------------------------------------------------------------*/
/*构造函数*/
//与类名相同，目的不是开辟空间，是初始化对象
//并且只能赋初值，而不是初始化变量，因为可以在构造函数中多次赋值
/*-------------------------------------------------------------*/
/*析构函数*/
//无参无返回值，是真的无返回值，而不是void
//一个类有且仅有一个析构函数，不显示定义的话就使用默认的
//先构造的后析构，后构造的先析构，是的，使用的栈
/*-------------------------------------------------------------*/
/*拷贝构造函数*/
Data d1(2024,9,22);//Data类对象d1，构造函数参数为2024,9,22
Data d2(d1);//使用拷贝d1对象的构造参数来构建构造函数
/*-------------------------------------------------------------*/
/*static成员*/
//静态成员为所有类对象共享，不属于某个具体对象
//非静态变量归属于对象，静态函数不是对象的一部分，无法用静态函数访问对象中的变量
//静态成员变量一定在类外进行初始化，定义还是在类里面定义
class Test
{
private:
	static int _n;
};
// 静态成员变量的定义初始化
int Test::_n = 0;//虽然是私有，但是静态变量初始化可以从外部访问
//静态成员函数可以访问静态成员变量
/*
* 绕了半天就两个问题
* 1、静态成员函数可以调用非静态成员函数吗？
 2、非静态成员函数可以调用静态成员函数吗？
1.不可以
2.可以
*/
/*-------------------------------------------------------------*/
/*友元类*/
//友元类的所有成员函数都可以是另一个类的友元函数
// 都可以访问另一个类中非公有成员
class A
{
	friend class B;
	A(int n=0)
		:_n(n)//构造函数初始化列表中的变量
	{}
private:
	int _n;
};
class B
{
	void T(A& a)
	{
		a._n;//可以调用友元类中的私有变量
	}
};
//重点！
// 1.友元类是单向的，不具有交换性
// 2.友元关系不能传递
/*-------------------------------------------------------------*/
/*内部类*/
//定义在一个类中的类就是内部类
//唉😔，很可怜
//1.内部类是独立类，不属于外部类，不能通过外部调用内部类
//2.外部类对内部类没有优越访问权限
//3.内部类是外部类的友元类，就是说内部类可以访问外部所有成员，但是外部类不行
//4.外部类的大小与内部类无关
        </code></pre>
        <h2>内存管理</h2>
        <pre><code class="cpp">
/*C++内存管理*/
             程序中内存区域划分
--------------------------------------------
|                内核空间
|
|
|	        栈(向下增长)
|		     ↓
|
|
|		*内存映射段*
|
|
|		    ↑
|		堆(向上增长)
|
|
|
|	    数据段(全局数据、静态数据)
|
|           代码段(可执行、常量)
|
--------------------------------------------
栈又叫堆栈，用于存储非静态局部变量/函数参数/返回值。

内存映射段是高效的I/O映射，进程之间通信

堆用于存储运行时动态内存分配

数据段也称：静态区，存储全局数据，以及静态数据

代码段也叫常量区，存放可执行的代码和只读常量

栈开辟空间是从地址高处向下开辟的，所以是向下

堆区开辟空间，是先开辟空间地址较低处开始

int a = 10;
int b = 20;
int* c = (int*)malloc(sizeof(int) * 10);
int* d = (int*)malloc(sizeof(int) * 10);
在上面的四个变量中，a和b是存储在栈区，先开辟的地址高
也就是a的地址高于b

c和d是存储在堆区，后开辟的地址高
也就是d的地址高于c
后开辟的也不一定高，因为如果前面的某个地址被释放了，就会放前面去

----------------------------C中的内存管理--------------------------------------
malloc  calloc   realloc   free
1.malloc
开辟指定大小空间，成功返回首地址，并且是void*, 需要强制转换，失败就是NULL

2.calloc
开辟指定大小空间，给明个数，以及每个大小，成功为首地址，失败NULL
开辟好以后将每一个字节初始化为0

3.realloc
可以调整已经开辟好的动态内存大小
二个参数：
第一个是需要调整的内存的首地址
第二个是调整后的新大小
调整大小三种情况
1.原地 后面有足够空间
2.异地 后面没有，重新找新地方，自动释放原来地方，并且拷贝数据到新地方
3.失败 后面和堆区都没有足够空间

4.free
释放空间
---------------------- - 面向对象中的内存管理--------------------------------------
1.动态申请某个类型的空间
int* p1 = new int;//申请
delete p1;//销毁
等价于
int* p1 = (int*)malloc(sizeof(int));
free(p1);

2.动态申请多个类型的空间
int* p1 = new int[10];
delete[] p1;
等价于
int* p1 = (int*)malloc(sizeof(int) * 10);
free(p1);

3.动态申请某个类型空间并且初始化
int* p1 = new int(10);
delete p1;
等价于
int* p1 = (int*)malloc(sizeof(int));
*p1 = 10;
free(p1);

4.动态申请多个类型的空间并初始化
int* p1 = new int[10] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
delete[] p1;
等价于
int* p1 = (int*)malloc(sizeof(int) * 10);
for (int i = 0; i < 10; i++)
{
	p1[i] = i;
}
free(p1);

总的来说，new会调用构造函数，而delete会调用析构函数

operator new 和 operator delete 函数与malloc和free用法完全一样
operator new 和 operator delete的底层就是malloc和free
只不过前者加了一个抛异常
new 和 delete 的底层是 operator new 和 operator delete
不过 new 和 delete 分别加了调用构造函数和析构函数

注意malloc和free是函数
而 new 和 delete 是操作符
并且malloc 和free不会初始化
并且malloc 和free要手动计算大小
并且malloc返回的是void*，需要强制转换
new和delete还会调用构造函数和析构函数
----------------------------------------------------------------
内存泄露
1.堆内存泄露
	就通过malloc、new、等等分配的内存，堆被用完了
2.系统资源泄露
	使用系统提供的资源，但是没有释放，就是无数个‘后台’，不用，还挂着

如何避免：
1.良好设计
2.智能指针
3.泄露检测工具
        </code>
        </pre>
        <h2>《模板》入门</h2>
        <pre>
            <code class="cpp">
/*函数模板和类模板*/
交换两数(整形或者浮点)
C的解决办法
void Swa(int* p1, int* p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}
void Swb(double* p1, double* p2)
{
	double temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

C++:函数重载(函数名一样，根据传入参数自动选择)
void Swa(int* p1, int* p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}
void Swa(double* p1, double* p2)
{
	double temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

看上去，貌似C++合理了点，但是代码量是一样的
所以：
             泛型编程
编写与类型无关的通用代码，实现代码复用，模板是泛型编程的基础

模板分为：函数模板和类模板

函数模板
	模板与类型无关
函数模板的形式

----------------------------------------------------
template < typename T1,typename T2,...,typename Tn>
返回类型 函数名(参数列表)
{
	//函数体
}
----------------------------------------------------
template< typename T>
void Swa(T & x, T & y)
{
	T temp = x;
	x = y;
	y = temp;
}

注意template、typename是关键字，可以使用class替代，但是不能用struct
在c++中可以使用class替代struct

函数模板就是个蓝图，本身不是函数，是编译器产生具体函数的模具
编译器根据传入的实际参数类型来推演生成对应类型的函数以供调用
当使用int类型调用函数模板时，会将T确定为int类

隐式实例化：让编译器来推演类型
template< typename T>
T Add(const T& x, const T& y)//int Add(const int& x,const int& y)
{
	return x + y;
}
int main()
{
	int a = 10, b = 20;
	int c = Add(a, b);//在c++中形参是引用，从而不必像C那样传入&a，和&b
	return 0;
}

值得注意的是
int a = 10;
double b = 1.1;
int c = Add(a, b);
//编译是失败的，因为不会进行类型转换
//具体就是编译器见到第一个a是int，将T定为int
//然后见到b是double，又推演为double
//并且模板参数只有一个T，无法确定是哪一个是T
//所以我们就会有显式实例化

显式实例化：指定模板参数的实际类型
template< typename T>
T Add(const T& x, const T& y)
{
	return x + y;
}
int main()
{
	int a = 10;
	int b = 5;
	int c = Add< int>(a, b);//指明类型
	return 0;
}
//指定以后，如果不符合int，编译器会转化，但是转化不成功，还是报错
----------------------------------------------------------------
函数模板的匹配原则

1.非模板函数和同名模板函数可以同时存在，优先调用非模板函数
int Add(const int& x, const int& y)
{
	return x + y;
}
template< typename T>
T Add(const T& x, const T& y)
{
	return x + y;
}
int main()
{
	int a = 10;
	int b = 5;
	int c = Add(a, b);//调用的是非模板函数
	int d = Add< int>(a, b);//调用的实例化的模板函数
	return 0;
}
2.非模板函数(普通函数)可以将实参自动类型转化，但是模板函数不允许
3.如果模板函数比起非模板有着更好的匹配，那么就选择模板
----------------------------------------------------------------
类模板
格式：
template< class T1,class T2,...,class Tn>
calss 类模板名
{
	//类成员声明
}
--------------------------------------------
例如：
template< class T>
class Score
{
public:
	void Print()
	{
		cout << "" << endl;
	}
private:
	T _Math;
	T _English;
};

//类模板中成员函数的定义若是放在类外定义，需要加模板参数列表
template< class T>
class Score
{
public:
	void Print();
private:
	T _Math;
	T _English;
};
template< class T>//需要加上参数列表
void Score< T>::Print()//命名空间的引用
{
	cout << "" << endl;
}
注意：模板不支持分离编译，声明在.h文件中，定义在.cpp文件中是不允许的
实例化：
Score< int> s1;
Score< double> s2;
类模板不是类，实例化后的才是类
            </code>
        </pre>
        <h2>《模板》进阶</h2>
        <pre>
           <code>
非类型模板参数
模板的参数分为
	类型形参：class或者typename 后的
	非类型形参：使用一个常量作为参数，在模板中可以使用该参数作为一个常量

template< class T,size_t N>//size_t其实简单理解：无符号整型
class SA
{
public:
	size_t arraysize()
	{
		return N;
	}
private:
	T _arrayp[N];
};
使用非类型模板参数以后，就可以实例化对象的时候指定创建静态数组的大小
int main()
{
	SA< int, 10> a1;//在类成员中创建了大小为10的数组
	SA< int, 1000> a2;//创建了大小为1000的数组
}
重点：
1.非类型模板参数只允许使用整形家族(int,long int,unsigned int 等等)
2.浮点、类对象、字符串是不允许使用为非类型参数
3.非类型模板参数在编译时就要确定结果，编译器在编译阶段就要根据传入的非类型参数生成对应类或者函数

--------------------------------------------------------------------------------
模板的特化
步骤：
1.首先要有基础的函数模板
2.关键字template后面接一对空的尖括号<>
3.函数名后跟一对尖括号,尖括号指定需要特化的类型
4.函数形参表必须和模板函数的基础参数完全相同

template< class T>
bool IsEqual(T x, T y)
{
	return x == y;
}
cout << IsEqual(1, 1) << endl; //1
cout << IsEqual(1.1, 2.2) << endl; //0
这样使用是没有问题的，它的判断结果也是我们所预期的，但是我们也可能会这样去使用该函数模板
char a1[] = "2021dragon";
char a2[] = "2021dragon";
cout << IsEqual(a1, a2) << endl; //0
判断结果是这两个字符串不相等，这很好理解，因为我们希望的是该函数能够判断两个字符串的内容是否相等，而该函数实际上判断是确实这两个字符串所存储的地址是否相同，这是两个存在于栈区的字符串，其地址显然是不同的。
类似于上述实例，使用模板可以实现一些与类型无关的代码，但对于一些特殊的类型可能会得到一些错误的结果，此时就需要对模板进行特化，即在原模板的基础上，针对特殊类型进行特殊化的实现方式



//基础函数模板
template< class T>
bool IsEqual(T x, T y)
{
	return x == y;
}
//针对char*类型的特化
template<>
bool IsEqual< char*>(char* x, char* y)
{
	return strcmp(x, y) == 0;
}


全特化：将模板参数列表所有参数都确定化
偏特化：任何针对模板参数进一步进行条件限制设计的特化
偏特化包含部分特化以及参数进一步被限制
进一步被限制就是说，指明参数是全部引用，还是全部是指针的时候就调用

---------------------------------------------------------------------
模板的分离编译
//一个程序（项目）由若干个源文件共同实现，而每个源文件单独编译生成目标文件，最后将所有目标文件链接起来形成单一的可执行文件的过程称为分离编译模式。
在分离编译模式下，我们一般创建三个文件
一个头文件用于进行函数声明
一个源文件用于对头文件中声明的函数进行定义
最后一个源文件用于调用头文件当中的函数

程序运行经历的四个步骤：
1.预处理：头文件展开，去注释，宏替换，条件编译
2.编译检查代码，没有错误编译成汇编语言
3.汇编：把编译阶段生成的文件转成目标文件
4.链接：将生成的各个目标文件进行链接，生成可执行文件
模板分离编译失败的原因：
在函数模板定义的地方（Add.cpp）没有进行实例化，而在需要实例化函数的地方（main.cpp）没有模板函数的定义，无法进行实例化。
总的就是说，用的时候定义。不用就别定义。不要分离编译

           </code>
        </pre>
        <h2>继承和友元</h2>
        <pre>
            <code>
/*继承*/
在保持原有特性的基础上进行扩展，增加功能，这样的新类，称为派生类
举例：
class Person//父类
{
public:
	void Print()
	{
		cout << "" << endl;
	}
protected:
	string _name = "";//名字
	int _age = 18;//年龄
};

class Student : public Person//子类(派生类)
{
protected:
	int _stuid;//学号
};

class Teacher : public Person//子类(派生类)
{
protected:
	int _jobid;//工号
};
子类是继承自父类的
继承以后，父类中的成员，包括成员函数和成员变量都是子类的一部分，自动复写
继承方式和访问限定符
1.public
2.protected
3.private
public继承:基类的private派生类中不可见，其他按父类的限定
protected继承:基类的private在派生类不可见,其他父类的一律在子类中变成protected
private继承:基类的private在派生类中不可见,其他父类的一律在子类中变成private

使用继承时也可以不指明继承方式，使用class时默认为private，使用struct默认是public
----------------------------------------------
//基类
class Person
{
public:
	string _name = "张三"; //姓名
};
//派生类
class Student : Person //默认为private继承
{
protected:
	int _stuid;   //学号
};
-----------------------------------------------
//基类
class Person
{
public:
	string _name = "张三"; //姓名
};
//派生类
struct Student : Person //默认为public继承
{
protected:
	int _stuid;   //学号
};
---------------------------------------------- -
基类和派生类对象赋值转换
class Person//基类
{
protected:
	string _name;//姓名
	string _sex;//性别
	int _age;//年龄
};
class Student : public Person//派生类
{
protected:
	int _stuid;//学号
};

Student s;//定义了一个派生类对象
Person p = s;//派生类对象赋值给基类对象
Person* ptr = & s ;//派生类对象赋值给基类指针
Person& ref = s;//派生类对象赋值给基类引用
//感觉与我们的观点有点不同，怎么儿子可以给老子赋值了？
//不应该是 老子的东西可以赋值给儿子吗，毕竟儿子拥有老子的一切特性
这个现象就是《切片/切割》，就只是把派生类中基类的部分赋值
派生类对象赋值给指针，也同样切片了，基类指针指向的派生对象也只剩下基类中有的成员
同理，派生类对象赋值给引用也是

注意：基类对象不能赋值给派生类对象
但是基类指针可以通过强制转换赋值给派生类的指针
此时基类指针必须指向派生类对象才是安全的
基类指针当然可以指向派生，前面都说了，儿子可以赋值给老子

---------------------------------------------------------------------------
继承的作用域
子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问
这叫隐藏，也是重定义
class Person//父类
{
protected:
	int _num = 111;
};
class Student : public Person
{
protected:
	int _num = 999;
};

此时访问子类的_num成员是显示999

如果实在想要访问父类
加上作用域限定符
Person::_num
就是111了
-----------------------------------------------------
//父类
class Person
{
public:
	void fun(int x)
	{
		cout << x << endl;
	}
};
//子类
class Student : public Person
{
public:
	void fun(double x)
	{
		cout << x << endl;
	}
};
int main()
{
	Student s;
	s.fun(3.14);       //直接调用子类当中的成员函数fun
	s.Person::fun(20); //指定调用父类当中的成员函数fun
	return 0;
}
---------------------------------------------------- -
这不是函数重载，函数重载是在同一个作用域

-------------------------------------------------------
派生类的默认成员函数
//一共有6个
初始化和清理：构造函数和析构函数
拷贝和赋值：使用同类的对象去初始化一个新创建的对象，赋值是把一个对象赋值给另一个对象
取地址重载：普通对象和const对象的取地址
-------------------------------------------------------
class Person
{
public:
	Person(const string& name = "peter")//构造函数
		:_name(name)//初始化成员为构造函数中指定字符串
	{
		cout << "" << endl;
	}
	Person(const Person& p)//拷贝构造函数
		:_name(p.name)
	{
		cout << "" << endl;
	}
	Person& operator = (const Person& p)//赋值运算符重载函数
	{
		cout << "" << endl;
		if (this != &p)
		{
			_name = p.name;
		}
		return *this;
	}
	~Person()//析构函数
	{
		cout << "" << endl;
	}
private:
	string _name;//姓名
};

===========================================================================
//派生类
class Student : public Person
{
public:
	//构造函数
	Student(const string& name, int id)
		:Person(name) //调用基类的构造函数初始化基类的那一部分成员
		, _id(id) //初始化派生类的成员
	{
		cout << "Student()" << endl;
	}
	//拷贝构造函数
	Student(const Student& s)
		:Person(s) //调用基类的拷贝构造函数完成基类成员的拷贝构造
		, _id(s._id) //拷贝构造派生类的成员
	{
		cout << "Student(const Student& s)" << endl;
	}
	//赋值运算符重载函数
	Student& operator=(const Student& s)
	{
		cout << "Student& operator=(const Student& s)" << endl;
		if (this != &s)
		{
			Person::operator=(s); //调用基类的operator=完成基类成员的赋值
			_id = s._id; //完成派生类成员的赋值
		}
		return *this;
	}
	//析构函数
	~Student()
	{
		cout << "~Student()" << endl;
		//派生类的析构函数会在被调用完成后自动调用基类的析构函数
	}
private:
	int _id; //学号
};

===========================================================================
1.派生类的构造函数被调用时，会自动调用基类的构造函数初始化基类那一部分成员
如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表中显示调用基类的构造函数
2.派生类的拷贝构造函数必须调用基类的拷贝构造函数完成基类成员的拷贝构造
3.派生类的赋值运算符重载函数必须调用基类的赋值运算符重载函数完成基类成员的赋值
4.派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员
5.派生类对象初始化时，会先调用基类的构造函数再调用派生类的构造函数
6.派生类对象在析构时，会先调用派生类的析构函数再调用基类的析构函数
===========================================================================
1.派生类和基类的赋值运算符重载函数因为函数名相同构成隐藏，因此在派生类中调用
基类赋值运算符重载函数，需要使用作用限定符指定
2.派生类和基类的析构函数也会因为函数名相同构成隐藏，如果在派生类中调用，也需要指定

接下来该看继承和友元
            </code>
        </pre>
    </div>
    <div class="block">
        <h1>C++难点、混淆点总结</h1>
        <pre>
<strong>1.一个类的静态数据成员所表示属性是类的属性或对象的属性？</strong>
错误的，只是类的属性，因为静态数据成员，不会成为对象消失的时候消失的大怨种
又不是古代了，陪葬的恶习早没了，人都是独立个体，静态说我也是
--------------------------------------------------------------
<strong>2.静态成员函数对类的数据成员访问可以是静态数据成员也可以是非静态数据成员？</strong>
错误的，静态成员函数不随着对象的消失而消失，什么意思？就是说静态成员函数不接受隐含的this指针
所以它不能访问自己类的非静态成员（包括函数和数据）
不过你也可以结合上一题，静态成员是类的的属性。就能够大致理解了
一定会骂街：你这说的是人话吗？能不能讲明白点，臭傻蛋
好吧☝🏿☝🏻（我可不会骂人，我只是模仿你的语气）
this指针就是区别于外部变量和内部变量的作用，外部变量与内部变量是一样的很难区别(只有程序区别不了，毕竟人工智障)
这个时候程序给你一个工具，让你用这个工具来帮它区别开
但是问题是静态成员，是不随对象毁灭的，也就是说你上一秒指的，下一秒就没了
和男人的嘴一样。所以静态对象是没有this指针的
看下面程序，你就知道this指针是什么了
<code>
class Box {
    int length;  // 定义私有的整型成员变量length
public:
    Box(int length) {
        this->length = length;  // 构造函数，初始化成员变量length
    }

    int getLength() {
        return this->length;  // 访问成员变量length
    }

    void display() {
        std::cout << "Length: " << this->getLength() << std::endl;  // 类的成员函数，访问成员变量length和其他函数
    }
};
</code>
发现没有，成员函数形参是len，结果类成员数据也有叫len的，然后还执行赋值
如果没有this指针就是length = length;
你说可怕不？this指的就是类成员而不是传入的参数
疑问来了，为什么不改参数的名称？换一个，不就不用this指针了吗？
唉，你应该明白，总有人喜欢挑战极限
还记得模板吗？泛型编程
所有类和函数全部用模板生成，几百个模板，模板到最后，给自己都干傻了
如果你不知道这种笑话，那你总知道宏定义吧？
类似所有的代码全部用宏定义写。宏定义都不知道？
算了，右上角有个X号，退出。
--------------------------------------------------------------
<strong>3.inline函数可以是虚函数</strong>
类中定义的函数默认都是内联函数
在类中说明，类体外如果不加inline说明的定义，均不是内联了
包含循环语句和分支语句的函数不能成为内联
--------------------------------------------------------------
<strong>4.静态成员函数不能是虚函数</strong>
静态成员函数没有this指针，无法访问虚表，虚表就是实现继承多态的关键
--------------------------------------------------------------
<strong>5.构造函数不能是虚函数</strong>
因为对象中的虚表指针是在构造函数初始化列表阶段才初始化
--------------------------------------------------------------
<strong>6.析构函数可以是虚函数</strong>
--------------------------------------------------------------
<strong>7.对象访问普通函数更快还是虚函数更快？</strong>
对象访问普通函数比虚函数快，因为访问虚函数的时候，需要找到虚表指针，指针在虚表中找到对应虚函数，才能调用
--------------------------------------------------------------
<strong>8.</strong>


        </pre>
    </div>
    <div class="block">
        <h1>测试</h1>
        <h2>代码示例</h2>
        <pre>

        </pre>
    </div>
    <div class="block">
        <h1>测试</h1>
        <h2>代码示例</h2>
        <pre>

        </pre>
    </div>
    <!-- 添加更多的块 -->
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>


</body>
</html>
